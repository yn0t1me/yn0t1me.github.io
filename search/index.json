[{"content":"Vue3介绍 vue3比vue2好，性能提高了，支持ts语法，源码升级，多个一些新的api\n最主要的区别是vue3使用组合式API，而vue2使用的配置项API\nvue2的所有语法可以完全迁移到vue3，完全兼容\nVue3项目创建 方式一：使用vue-cli创建\n创建步骤同vue2，只是版本选项由vue2改选vue3，不再赘述\n方式二：使用vite创建\n创建工程 npm create vite@latest my-vue3-project --template vue 安装依赖 cd vue3_test2 npm install 运行 npm run dev 安装过程中询问是否安装create-vite，同意即可，选择前端框架为vue即可\nvite创建的项目如要使用vuex或vue-router，需要自己创建对应文件夹，完成配置即可\n常用api之setup 以往在组件中使用的是配置项API，即data，methods等等，现在vue3推荐我们使用组合式API，即将所有的属性，方法等等都写在setup方法中，然后通过return返回出去即可被使用（原先的配置项API依然支持）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 \u0026lt;template\u0026gt; \u0026lt;!--组件不需要放在一个标签内了--\u0026gt; {{ x }} \u0026lt;br\u0026gt; \u0026lt;h2\u0026gt;{{ name }}==={{ age }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;handleAdd\u0026#34;\u0026gt;点我年龄+1\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; } nav { padding: 30px; } nav a { font-weight: bold; color: #2c3e50; } nav a.router-link-exact-active { color: #42b983; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; import HelloWorld from \u0026#34;@/components/HelloWorld.vue\u0026#34;; export default { name: \u0026#39;App\u0026#39;, components: { HelloWorld }, data() { return { x: 100 } }, //使用组合式API setup() { // 定义变量 let name = \u0026#39;lqz\u0026#39; let age = 19 // 定义函数 function handleAdd() { age = age + 1 // 数据变了，页面没变 console.log(age) } // 要在模版中使用必须，return出去 return {name, age, handleAdd} } } \u0026lt;/script\u0026gt; 但是有一个问题，会发现点击后age的值发生变化，但页面没有相应的发生变化\n常用api之ref和reactive 要实现响应式，需要对数据进行处理\n基本数据类型使用ref包裹一下，使之变成响应式（变量变成了一个对象）\n在模版中可以直接使用 在setup中使用对象.value才能获取真正的值并对其进行操作 对象，数组类型，使用reactive包裹\n在模版和setup中都可以直接使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 \u0026lt;template\u0026gt; \u0026lt;!--组件不需要放在一个标签内了--\u0026gt; {{ x }} \u0026lt;br\u0026gt; \u0026lt;h2\u0026gt;{{ name }}==={{ age }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;handleAdd\u0026#34;\u0026gt;点我年龄+1\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;h2\u0026gt;姓名是：{{ person.name }}，年龄是：{{ person.age }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;handleChange\u0026#34;\u0026gt;点我修改刘亦菲的名字\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; } nav { padding: 30px; } nav a { font-weight: bold; color: #2c3e50; } nav a.router-link-exact-active { color: #42b983; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; import HelloWorld from \u0026#34;@/components/HelloWorld.vue\u0026#34;; import {ref, reactive} from \u0026#34;vue\u0026#34;; export default { name: \u0026#39;App\u0026#39;, components: { HelloWorld }, data() { return { x: 100 } }, //使用组合式API setup() { // 定义变量 let name = ref(\u0026#39;lqz\u0026#39;) let age = ref(19) let person = reactive({ name: \u0026#39;刘亦菲\u0026#39;, age: 19 }) // 定义函数 function handleAdd() { age.value = age.value + 1 // 数据变了，页面没变 console.log(age) } function handleChange() { person.name += \u0026#39;？\u0026#39; } // 要在模版中使用必须，return出去 return {name, age, handleAdd, person, handleChange} } } \u0026lt;/script\u0026gt; 计算和监听属性 在vue2中我们学习了计算属性和监听属性的配置项API的写法，在vue3的组合式API中，我们又该怎么写？\n组合式API的好处：\n将实现一个功能的属性，方法放在一起，易于阅读和维护\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;{{ fullname }}\u0026lt;/h2\u0026gt; \u0026lt;br\u0026gt; \u0026lt;button @click=\u0026#34;handleChange\u0026#34;\u0026gt;点我改名\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;h2\u0026gt;sum:{{ sum }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;sum++\u0026#34;\u0026gt;点我sum+1\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; } nav { padding: 30px; } nav a { font-weight: bold; color: #2c3e50; } nav a.router-link-exact-active { color: #42b983; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; import {ref, reactive, computed, watch} from \u0026#34;vue\u0026#34;; export default { name: \u0026#39;App\u0026#39;, setup() { const sum = ref(10) const person = reactive({ firstName: \u0026#39;邱\u0026#39;, lastName: \u0026#39;伟杰\u0026#39; }) let fullname = computed(() =\u0026gt; { return person.firstName + person.lastName; }) function handleChange() { person.firstName = \u0026#39;王\u0026#39; } watch(sum, (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;老数据：\u0026#34;, oldValue) console.log(\u0026#34;新数据：\u0026#34;, newValue) }) return {person, fullname, handleChange, sum} } } \u0026lt;/script\u0026gt; 生命周期 vue3的生命周期钩子函数与vue2稍有不同。\nvue3的生命周期钩子函数需要从 vue 库中导入，并在 setup() 函数中使用\nsetup() 函数的执行时机相当于选项式 API 中的 beforeCreate 和 created 的组合，其他钩子函数以函数的形式写在setup中，并传入一个箭头函数\n1 2 3 4 5 6 7 8 9 beforeCreate===\u0026gt;setup() created=======\u0026gt;setup() beforeMount ===\u0026gt;onBeforeMount mounted=======\u0026gt;onMounted beforeUpdate===\u0026gt;onBeforeUpdate updated =======\u0026gt;onUpdated ------下面的变了------ beforeUnmount ==\u0026gt;onBeforeUnmount unmounted =====\u0026gt;onUnmounted 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{ message }}\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted } from \u0026#39;vue\u0026#39;; export default { setup() { const message = ref(\u0026#39;Hello, Vue 3!\u0026#39;); const count = ref(0); // 挂载前 onBeforeMount(() =\u0026gt; { console.log(\u0026#39;Before Mount: Component is about to be mounted\u0026#39;); }); // 挂载后 onMounted(() =\u0026gt; { console.log(\u0026#39;Mounted: Component has been mounted\u0026#39;); }); // 更新前 onBeforeUpdate(() =\u0026gt; { console.log(\u0026#39;Before Update: Component is about to be updated\u0026#39;); }); // 更新后 onUpdated(() =\u0026gt; { console.log(\u0026#39;Updated: Component has been updated\u0026#39;); }); // 卸载前 onBeforeUnmount(() =\u0026gt; { console.log(\u0026#39;Before Unmount: Component is about to be unmounted\u0026#39;); }); // 卸载后 onUnmounted(() =\u0026gt; { console.log(\u0026#39;Unmounted: Component has been unmounted\u0026#39;); }); // 自定义方法 const increment = () =\u0026gt; { count.value++; }; return { message, count, increment }; } }; \u0026lt;/script\u0026gt; toRefs es6语法中的对象解压，使用后可以简化模板中的使用，无需使用对象.属性，可以直接通过属性调用\n1 2 3 4 5 6 7 // es6语法中的对象解压 return { ...toRefs(data) // 解压开，return了 // name:data.name, // age:data.age, // isShow:data.isShow, } 完整代码：\n解压前\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;{{ person.name }}==={{ person.age }}\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import {ref, reactive, computed, watch} from \u0026#34;vue\u0026#34;; export default { name: \u0026#39;App\u0026#39;, setup() { const person = reactive({ name: \u0026#39;邱伟杰\u0026#39;, age: 17 }) return {person} } } \u0026lt;/script\u0026gt; 解压后\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;{{ name }}==={{ age }}\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import {ref, reactive, toRefs} from \u0026#34;vue\u0026#34;; export default { name: \u0026#39;App\u0026#39;, setup() { const data = reactive({ name: \u0026#39;邱伟杰\u0026#39;, age: 17 }) return { // es6语法中的对象解压 ...toRefs(data) // 解压开return，相当于 // name:data.name, // age:data.age, } } } \u0026lt;/script\u0026gt; 回顾和扩展 常见ES6语法 变量和常量 对于var，let，const三个声明变量的关键字，他们的主要区别如下\nvar\n作用域：var 声明的变量是函数作用域（function-scoped），即在函数内部声明的变量只能在函数内部访问。\n提升（Hoisting）：var 声明的变量会被提升到其所在作用域的顶部，这意味着你可以在声明之前访问变量，但其值为 undefined。\n重复声明：在同一个作用域内，var 允许重复声明同一个变量\nlet\n作用域：let 声明的变量是块作用域（block-scoped），即在 {} 内声明的变量只能在该块内访问 提升（Hoisting）：let 声明的变量也会被提升，但在声明之前访问会抛出 ReferenceError，形成所谓的“暂时性死区”（Temporal Dead Zone, TDZ） 重复声明：在同一个作用域内，let 不允许重复声明同一个变量 const\n作用域：const 声明的变量也是块作用域（block-scoped） 提升（Hoisting）：let 声明的变量也会被提升，但在声明之前访问会抛出 ReferenceError，形成所谓的“暂时性死区”（Temporal Dead Zone, TDZ） 重复声明：在同一个作用域内，const 不允许重复声明同一个变量 不可变性：const 声明的变量必须初始化，且不能重新赋值。但对于对象和数组，虽然变量本身不能重新赋值，但其属性或元素可以修改 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script\u0026gt; function show(){ if(1==1){ var name = \u0026#34;武沛齐\u0026#34;; //函数作用域=Python } // 函数作用域，可以访问到name consolo.log(name); } show(); \u0026lt;/script\u0026gt; 1 2 3 4 5 6 7 \u0026lt;script\u0026gt; if(1==1){ let age = 19; // 块级作用域 } // 块级作用域，访问不到age console.log(age); \u0026lt;/script\u0026gt; 1 2 3 4 5 6 7 \u0026lt;script\u0026gt; if(1==1){ const age = 19; // 块级作用域 + 常量 } // 块级作用域，访问不到age console.log(age); \u0026lt;/script\u0026gt; 1 2 3 4 5 \u0026lt;script\u0026gt; const info = {id:1,value:18}; // info本身不能够进行赋值，但其属性或元素可以修改，这也是为什么用ref对一个const定义的变量包裹后，可以修改它的value值 info.value = 999; \u0026lt;/script\u0026gt; 2.模板字符串 在es5的语法中做字符串拼接需要使用加号实现\n1 let info = \u0026#34;我是\u0026#34; + \u0026#34;?\u0026#34; + \u0026#34;今年技术\u0026#34;; 在es6中，有了模板字符串\n模板字符串使用反引号来定义字符串，提供字符串拼接、嵌入表达式、多行字符串\n表达式需要用 ${} 包裹，然后在模板字符串中直接插入变量或计算结果 模板字符串支持多行字符串，不需要使用 \\n 来换行 还可以嵌入标签 1 2 3 4 5 6 \u0026lt;script\u0026gt; let name = \u0026#34;张开\u0026#34;; let age = 73; let info = `我叫${name}，今年${age}岁`; \u0026lt;/script\u0026gt; 3. 动态参数 剩余参数（Rest Parameters）data是数组类型，可以接收多余的所有参数：\n只能出现在函数参数列表的最后一位 它会将函数调用时传入的多余参数收集到一个数组中 1 2 3 4 5 6 7 8 \u0026lt;script\u0026gt; function info(v1,...data){ console.log(v1,data); } info(11); info(11,22); info(11,22,333,444,55); \u0026lt;/script\u0026gt; 扩展运算符（Spread Operator）用于将数组或对象展开为独立的元素\n1 2 3 4 5 6 7 8 9 \u0026lt;script\u0026gt; function info(v1,v2,v3,v4){ console.log(v1,v2,v3,v4); } info(11,22,333,444); nums = [22,33,44,55,66,77,88]; info(11,...nums) \u0026lt;/script\u0026gt; 4.解构赋值 解构赋值允许我们将数组或对象中的值快速提取到独立的变量中，主要包括数组解构、对象解构以及一些高级用法\n数组解构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;script\u0026gt; let nums = [11,22,33,44]; // 基本用法 let [n1,n2] = nums; console.log(n1); // 输出：11 console.log(n2); // 输出：22 // 跳过某些值 let [n1,,n2] = nums; console.log(n1); // 输出：11 console.log(n2); // 输出：33 // 提取剩余值 let [n1,...n2] = nums; console.log(n1); // 输出：11 console.log(n2); // 输出：[22,33,44] // 默认值 let nums = [11,22]; let [n1,n2,n3=33] = nums; console.log(n1); // 输出：11 console.log(n2); // 输出：22 console.log(n3); // 输出：33 \u0026lt;/script\u0026gt; 搭配函数传参\n1 2 3 4 5 6 7 \u0026lt;script\u0026gt; function getData(n1,[n2,n3,n4]){ console.log(n1,n2,n3,n4) } let nums = [11,22,33,44]; getData(100,nums); \u0026lt;/script\u0026gt; 对象解构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script\u0026gt; let info = {name: \u0026#34;Kimi\u0026#34;, age: 25, city: \u0026#34;Shanghai\u0026#34;}; // 基本用法 let {name,age,addr} = info; console.log(name); console.log(addr); // 提取部分属性 let {name,addr} = info; console.log(name); console.log(addr); // 重命名变量 let { name: fullName, age: years } = person; console.log(fullName); console.log(years); // 默认值 { name, age, city, sex=\u0026#34;male\u0026#34; } = person; console.log(city); \u0026lt;/script\u0026gt; 同样的，配合函数传参\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script\u0026gt; function getData(n1,{name,addr}){ //let {name,addr} = info; console.log(name); console.log(addr); } let info = {name:\u0026#34;武沛齐\u0026#34;,email:\u0026#34;wupeiqi@live.com\u0026#34;,addr:\u0026#34;北京\u0026#34;}; getData(111,info); \u0026lt;/script\u0026gt; Vue3中需要什么就要导入什么，不像vue2中可以直接去this对象中获取，this.$router this.$route。\n1 import {name,addr} from \u0026#39;vue\u0026#39; 5.箭头函数 注意：发送网络请求时，回调函数必须要使用箭头函数。（规范统一）\n语法差异 使用 =\u0026gt; 定义 如果函数体只有一条语句，可以省略大括号 {}，并且自动返回结果 不能有函数名（匿名函数） 传参 如果没有参数，可以使用一对空括号 () 来表示参数列表 如果只有一个参数，可以省略参数周围的括号 ()，直接写参数名 1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; function add(a, b) { return a + b; } f1(11,22); //箭头函数 const f2 = (a, b) =\u0026gt; a + b; // 简洁形式 f2(11,22); \u0026lt;/script\u0026gt; this关键字 普通函数的 this 是动态绑定的，取决于函数的调用方式 作为方法调用：this 指向调用它的对象 作为普通函数调用：this 指向全局对象（在严格模式下是 undefined） 箭头函数没有自己的 this，它会捕获其所在上下文的 this 值。换句话说，箭头函数的 this 是在其定义时确定的，而不是在调用时确定的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;script\u0026gt; var name = \u0026#34;源代码\u0026#34;; let info = { name: \u0026#34;武沛齐\u0026#34;, func: function () { console.log(this.name); // this执行调用它的对象即this=info，输出武沛齐 } } info.func(); //函数作为方法调用 function getData() { console.log(this.name); // this指向全局对象，this=window，输出源代码 } getData(); //作为普通函数调用 \u0026lt;/script\u0026gt; 调整：结果依然不变\n因为作为普通函数调用时，this指向全局对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script\u0026gt; var name = \u0026#34;源代码\u0026#34;; let info = { name: \u0026#34;武沛齐\u0026#34;, func: function () { console.log(this.name); // 函数内部默认都有this关键字,this=info对象 function getData() { console.log(this.name); // 函数内部默认都有this关键字，this=window } getData(); } } info.func(); \u0026lt;/script\u0026gt; 但如果是箭头函数就不一样了，箭头函数没有自己的 this，它会捕获其所在上下文的 this 值。在箭头函数定义时，是处在function函数内，此时this=info对象，所以箭头函数内的this=info对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;script\u0026gt; var name = \u0026#34;源代码\u0026#34;; let info = { name: \u0026#34;武沛齐\u0026#34;, func: function () { console.log(this.name); // 函数内部默认都有this关键字,this=info对象 let getData = () =\u0026gt; { console.log(this.name); } getData(); } } info.func(); \u0026lt;/script\u0026gt; 在vue2中，如果回调函数使用普通函数则会出现问题，就是this指向问题导致的\n案例如下（伪代码，模拟vue2项目中发生网络请求）：\n因为回调函数是普通函数，且是作为普通函数被调用而不是方法，因此该this实际上是window对象而不是我们期望的vue对象，从而导致vue对象中的data无法被正确的赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; let info = { data: null, send: function () { axios({ method: \u0026#34;post\u0026#34;, url: \u0026#34;https://api.luffycity.com/api/v1/auth/password/login/?loginWay=password\u0026#34;, data: { username: \u0026#34;alex\u0026#34;, password: \u0026#34;dsb\u0026#34; }, headers: { \u0026#34;content-type\u0026#34;: \u0026#34;application/json\u0026#34; } }).then(function (res) { console.log(this,res); this.data = res; }) } } info.send(); \u0026lt;/script\u0026gt; 如果使用箭头函数，就可以避免这个问题，它的this依赖于上下文，此时就是我们期望的vue对象，从而正确的对data进行赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; let info = { data: null, send: function () { axios({ method: \u0026#34;post\u0026#34;, url: \u0026#34;https://api.luffycity.com/api/v1/auth/password/login/?loginWay=password\u0026#34;, data: { username: \u0026#34;alex\u0026#34;, password: \u0026#34;dsb\u0026#34; }, headers: { \u0026#34;content-type\u0026#34;: \u0026#34;application/json\u0026#34; } }).then((res) =\u0026gt; { console.log(this,res); this.data = res; }) } } info.send(); \u0026lt;/script\u0026gt; 6.模块的导入导出 模块的导出 命名导出（Named Export） 默认导出（Default Export） 模块导入 命名导入（Named Import） 默认导入（Default Import） 命名空间导入（Namespace Import） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script\u0026gt; // mainComponent.js // 命名导出 export const add = (a, b) =\u0026gt; a + b; export const subtract = (a, b) =\u0026gt; a - b; export const multiply = (a, b) =\u0026gt; a * b; // 等价于 const add = (a, b) =\u0026gt; a + b; const subtract = (a, b) =\u0026gt; a - b; const multiply = (a, b) =\u0026gt; a * b; export { add, subtract, multiply }; // 默认导出，可以是一个函数、类、对象等 export default app; // 默认导出 \u0026lt;/script\u0026gt; 1 2 3 4 5 6 7 8 9 \u0026lt;script\u0026gt; // main.js // 命名导入 import { add, subtract } from \u0026#39;./mathUtils.js\u0026#39;; // 默认导入，可以通过任意名称导入 import app from \u0026#39;./mainComponent.js\u0026#39;; // 命名空间导入，将一个模块中的所有导出内容作为一个对象导入 import * as MathUtils from \u0026#39;./mathUtils.js\u0026#39;; \u0026lt;/script\u0026gt; 命名导出+命名导入\n命名导出+命名空间导入\n默认导出+默认导入\n关于环境 关于node.js 关于npm\n1 sudo npm install npm@latest -g 1 2 3 npm config set registry https://registry.npm.taobao.org npm install -g cnpm --registry=https://registry.npm.taobao.org vue-cli\n1 2 3 4 5 6 7 8 # 安装（最新版） sudo npm install -g @vue/cli # 安装（指定版本） sudo npm install -g @vue/cli@5.0.8 # 卸载 sudo npm uninstall -g @vue/cli 1 @vue/cli@5.0.8 创建项目 命令行创建 WebStorm 使用WebStorm创建项目，自动配置好项目启动按钮等，但是vuex，vue-router等组件需要手动安装，其他均已配置好\n项目部署 具体步骤如下：\n第一步：编译\n1 npm run build 在编译之前，要确保所有的依赖都已正确安装\n1 npm install 将项目打包成静态文件，通常输出到 dist 文件夹中\n第二步：将编译后的代码dist文件上传到服务器（阿里云、腾讯云）\n第三步：安装nginx + 配置 + 启动\n1 yum install nginx vim /etc/nginx/nginx.conf进入nginx的配置文件配置项目目录root\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 user nginx; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; # Load dynamic modules. See /usr/share/doc/nginx/README.dynamic. include /usr/share/nginx/modules/*.conf; events { worker_connections 1024; } http { log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 4096; include /etc/nginx/mime.types; default_type application/octet-stream; include /etc/nginx/conf.d/*.conf; server { listen 80; listen [::]:80; server_name _; # 项目目录 root /data/mysite; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; error_page 404 /404.html; location = /404.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } } 重启nginx\n1 systemctl restart nginx 第四步：访问 flex布局 传统的页面布局：div+css+float实现。\nflex布局（Flexible Box Layout）：实现更简单。\n1 2 3 4 \u0026lt;div class=\u0026#39;menu\u0026#39;\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;北京\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;上海\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 外层的div标签相当于一个容器，里面的两个div可视为该容器的元素\n容器 布局 将容器设置为flex布局\n1 2 3 4 5 6 7 8 9 10 \u0026lt;div class=\u0026#39;menu\u0026#39;\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;北京\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;上海\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .menu{ display:flex; } \u0026lt;/style\u0026gt; 2.主轴方向 1 2 flex-direction: row 主轴横向 flex-direction: column\t主轴纵向 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .menu { border: 1px solid red; width: 500px; display: flex; flex-direction: row; /*主轴=横向*/ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#39;menu\u0026#39;\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;北京\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;上海\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 3.元素对齐方式 1 2 3 justify-content: 定义子元素在主轴上的对齐方式 align-items: 定义子元素在交叉轴上的对齐方式 align-content: 定义多行子元素在交叉轴上的对齐方式，实现多行控制 对齐方式\n1 2 3 4 5 6 flex-start\t子元素排列在主轴的起始端 flex-end\t子元素排列在主轴的末端 center\t子元素在主轴方向上居中对齐 space-between\t子元素在主轴方向上均匀分布，第一个子元素靠起始端，最后一个子元素靠末端 space-around\t子元素在主轴方向上均匀分布，每个子元素的两侧都有相等的间距 space-evenly\t子元素在主轴方向上均匀分布，每个子元素之间的间距相等，包括第一个子元素和最后一个子元素与容器边界的间距 对主轴控制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .menu { border: 1px solid red; width: 500px; display: flex; flex-direction: row; /*主轴=横向*/ /*justify-content: space-evenly;*/ justify-content: space-between; } .menu .item{ width: 45px; height: 50px; border: 1px solid green; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#39;menu\u0026#39;\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;北京\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;上海\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 既控制主轴也控制副轴\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .menu { border: 1px solid red; width: 500px; height: 500px; display: flex; flex-direction: row; /*主轴=横向*/ /*justify-content: space-evenly;*/ justify-content: space-between; align-items: center; /*align-items: flex-start;*/ /*align-items: flex-end;*/ } .menu .item{ width: 45px; height: 50px; border: 1px solid green; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#39;menu\u0026#39;\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;北京\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;上海\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4.换行 当元素过多时，子元素可能会被压缩或溢出容器，此时就需要元素换行显示\n1 2 3 flex-wrap: nowrap; // 默认值，不换行 flex-wrap: wrap; // 换行 flex-wrap: wrap-reverse; // 换行，方向相反，主轴水平，从底向上换行，主轴垂直，从右向左换行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .menu { border: 1px solid red; width: 500px; height: 500px; display: flex; flex-direction: row; /*主轴=横向*/ /*justify-content: space-evenly;*/ justify-content: flex-start; /*align-items: center;*/ align-items: flex-start; /*align-items: flex-end;*/ flex-wrap: wrap; } .menu .item { width: 45px; height: 50px; border: 1px solid green; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#39;menu\u0026#39;\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;北京\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;上海\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 出现问题，换行后第二行元素并没有贴着第一行显示，而是空了很大的位置\n5.多行控制 1 2 控制多行显示时，行与行之间的排列 align-content: center; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .menu { border: 1px solid red; width: 500px; height: 500px; display: flex; flex-direction: row; /*主轴=横向*/ /*justify-content: space-evenly;*/ justify-content: flex-start; /*align-items: center;*/ align-items: flex-start; /*align-items: flex-end;*/ flex-wrap: wrap; align-content: center; } .menu .item{ width: 45px; height: 50px; border: 1px solid green; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#39;menu\u0026#39;\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;北京\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;上海\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 案例 存在问题：当数量刚好整除时，排列的没有任何问题，三个元素排满一排空间。但如果最后一行只剩一个或两个元素，就会单独占满一行，从而导致与前几行的排布不同\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .menu { border: 1px solid red; width: 500px; height: 500px; display: flex; flex-direction: row; /*主轴=横向*/ /*justify-content: space-between;*/ justify-content: space-around; /*横轴*/ align-items: flex-start; /*纵轴*/ flex-wrap: wrap; align-content: flex-start; /*多行文本，从顶部开始*/ } .menu .item { width: 150px; height: 50px; border: 1px solid green; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#39;menu\u0026#39;\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;北京\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;上海\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 元素 顺序 通过order值的大小决定同级元素之间的排布顺序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .menu { border: 1px solid red; width: 500px; height: 500px; display: flex; flex-direction: row; /*主轴=横向*/ /*justify-content: space-between;*/ justify-content: space-around; /*横轴*/ align-items: flex-start; /*纵轴*/ flex-wrap: wrap; align-content: flex-start; /*多行文本，从顶部开始*/ } .menu .item { width: 50px; height: 50px; border: 1px solid green; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#39;menu\u0026#39;\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39; style=\u0026#34;order: 1\u0026#34;\u0026gt;北京\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39; style=\u0026#34;order: 0\u0026#34;\u0026gt;上海\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39; style=\u0026#34;order: 2\u0026#34;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 剩余空间 通过flex-grow定义甚于空间的分布\n左对齐，仅自身宽度，右侧一大块剩余空间\n1 2 3 4 5 \u0026lt;div class=\u0026#39;menu\u0026#39;\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39; style=\u0026#34;\u0026#34;\u0026gt;北京\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39; style=\u0026#34;\u0026#34;\u0026gt;上海\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39; style=\u0026#34;\u0026#34;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 北京占自身宽度，上海和深圳按照2：1的比例把北京以外的剩余空间占满\n1 2 3 4 5 \u0026lt;div class=\u0026#39;menu\u0026#39;\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39; style=\u0026#34;\u0026#34;\u0026gt;北京\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39; style=\u0026#34;flex-grow: 2\u0026#34;\u0026gt;上海\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39; style=\u0026#34;flex-grow: 1\u0026#34;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 北京和深圳占自身宽度，上海将中间的剩余空间全部占满\n1 2 3 4 5 \u0026lt;div class=\u0026#39;menu\u0026#39;\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39; style=\u0026#34;\u0026#34;\u0026gt;北京\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39; style=\u0026#34;flex-grow: 2\u0026#34;\u0026gt;上海\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39; style=\u0026#34;\u0026#34;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 完整代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .menu { border: 1px solid red; width: 500px; height: 500px; display: flex; flex-direction: row; /*主轴=横向*/ /*justify-content: space-between;*/ justify-content: flex-start; /*横轴*/ } .menu .item { width: 50px; height: 50px; border: 1px solid green; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#39;menu\u0026#39;\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39; style=\u0026#34;\u0026#34;\u0026gt;北京\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39; style=\u0026#34;flex-grow: 2\u0026#34;\u0026gt;上海\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#39;item\u0026#39; style=\u0026#34;flex-grow: 1\u0026#34;\u0026gt;深圳\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 案例 通过计算右边距来解决上一个案例遗留的问题（当最后一行元素个数不是1，也不足以排满整行时，会出现错位）\n1 2 3 4 5 6 7 8 9 10 /*如果最后一个元素，是第3个，右边距=一个位置 + 所有空白位置/3（有三个空白位置）*/ \u0026lt;style\u0026gt; .course-list .item:last-child:nth-child(4n - 1) { margin-right: calc(24% + 4% / 3); } .course-list .item:last-child:nth-child(4n - 2) { margin-right: calc(48% + 8% / 3); } \u0026lt;/style\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .container { width: 1100px; margin: 0 auto; } .row1 { display: flex; flex-direction: row; justify-content: space-between; } .row1 .company { width: 210px; height: 180px; background-color: saddlebrown; } .row1 .pic { width: 266px; height: 180px; background-color: cadetblue; } .row2 .title { display: flex; flex-direction: row; justify-content: space-between; } .row2 .pic-list { display: flex; flex-direction: row; justify-content: space-between; } .row2 .pic-list .big { background-color: aquamarine; height: 610px; width: 210px; margin-right: 20px; } .row2 .pic-list .right-list { background-color: antiquewhite; flex-grow: 1; } .row2 .pic-list .right-list .group { display: flex; flex-direction: row; justify-content: space-between; flex-wrap: wrap; } .row2 .pic-list .right-list .phone { margin-bottom: 10px; border: 1px solid red; width: 200px; height: 300px; } .course-list { display: flex; justify-content: space-between; flex-wrap: wrap; } .course-list .item { width: 24%; height: 100px; background-color: skyblue; margin-top: 15px; } /*如果最后一个元素，是第3个，右边距=一个位置 + 所有空白位置/3（有三个空白位置）*/ .course-list .item:last-child:nth-child(4n - 1) { margin-right: calc(24% + 4% / 3); } .course-list .item:last-child:nth-child(4n - 2) { margin-right: calc(48% + 8% / 3); } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;company\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;pic\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;pic\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;pic\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;row2\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;div\u0026gt;手机\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;查看更多\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;pic-list\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;big\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right-list\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;group\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;phone\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;phone\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;phone\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;phone\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;group\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;phone\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;phone\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;phone\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;phone\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;course-list\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; vue-router 安装 npm install vue-router --save 需要手动创建并编写router/index.js文件，配置main.js和App.vue vue add router 一键完成所有配置 可以看到，需要配置的地方都自动完成配置了\n必备操作 快速上手（案例） 详细见：src-1.zip\nApp.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;menu\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;源代码教育\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/home\u0026#34;\u0026gt;首页\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/course\u0026#34;\u0026gt;课程\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/news\u0026#34;\u0026gt;资讯\u0026lt;/router-link\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; body{ margin: 0; } .container { width: 980px; margin: 0 auto; } .menu{ height: 48px; line-height: 48px; background-color: #499ef3; } .menu a{ text-decoration: none; margin: 0 10px; color: white; display: inline-block; } \u0026lt;/style\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; router/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import {createRouter, createWebHistory} from \u0026#39;vue-router\u0026#39; import HomeView from \u0026#39;../views/HomeView.vue\u0026#39; const routes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;Index\u0026#39;, component: HomeView }, { path: \u0026#39;/home\u0026#39;, name: \u0026#39;Home\u0026#39;, component: HomeView }, { path: \u0026#39;/course\u0026#39;, name: \u0026#39;Course\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/CourseView.vue\u0026#39;), }, { path: \u0026#39;/news\u0026#39;, name: \u0026#39;News\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/NewsView.vue\u0026#39;) } ] const router = createRouter({ history: createWebHistory(process.env.BASE_URL), routes }) export default router URL传值（GET） 可以在App.vue的router-link标签内的to属性中传递参数 1 2 3 4 5 6 7 8 9 //基础写法 \u0026lt;router-link to=\u0026#34;/course\u0026#34;\u0026gt;课程1\u0026lt;/router-link\u0026gt; //对象写法（根据path匹配路由） \u0026lt;router-link :to=\u0026#34;{path:\u0026#39;/course\u0026#39;}\u0026#34;\u0026gt;课程2\u0026lt;/router-link\u0026gt; //对象写法（根据name匹配路由） \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;Course\u0026#39;}\u0026#34;\u0026gt;课程3\u0026lt;/router-link\u0026gt; //对象写法，添加参数（path/name） \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;Course\u0026#39;,query:{size:21,page:9}}\u0026#34;\u0026gt;课程-21-9\u0026lt;/router-link\u0026gt; \u0026lt;router-link :to=\u0026#34;{path:\u0026#39;/course\u0026#39;,query:{size:22,page:19}}\u0026#34;\u0026gt;课程-22-19\u0026lt;/router-link\u0026gt; 在目标组件中接收参数 问题：Vue 的响应式系统是基于对象的属性访问和修改来工作的。当一个响应式对象的属性发生变化时，Vue 会自动触发视图的更新。然而，Vue Router 的 $route 对象是一个特殊的响应式对象，它只会在 路由路径（path） 或 路由名称（name）发生变化时触发组件的重新加载，因此如果在同一个组件内进行跳转（只有传递参数不同），页面默认不会刷新即我从/course?page=1\u0026amp;size=1跳转到/course?page=1\u0026amp;size=2，页面数据不变。该如何解决？\n使用 watch 监听 $route.query 的变化 通过给 \u0026lt;router-view\u0026gt; 添加一个动态的 key，使其在路由变化时重新加载组件 使用 beforeRouteUpdate 路由守卫 下列示例采用的是路由守卫解决\n1 2 3 4 5 6 7 // 小知识点 导入useRoute并实例化出类对象route，route.query就是存储了所有传递参数的对象 onBeforeRouteUpdate((to, from)中to就是跳转后的router对象，to.query存储了其传递的所有参数 短路特性，设置默认值0：route.query.page || 0 \u0026lt;script setup\u0026gt;\u0026lt;/script\u0026gt;在里面书写相当于在setup()中写 vue3要实现响应式，需要用ref包裹变量，变量被包裹后变成对象类型，可以通过对象.value改值 /* eslint-disable */让eslint不检查该文件的语法问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;script setup\u0026gt; /* eslint-disable */ import {ref} from \u0026#39;vue\u0026#39; import {useRoute, onBeforeRouteUpdate} from \u0026#39;vue-router\u0026#39; const route = useRoute(); const name = ref(\u0026#34;武沛齐\u0026#34;); const page = ref(route.query.page || 0); const size = ref(route.query.size || 0); onBeforeRouteUpdate((to, from) =\u0026gt; { page.value = to.query.page || 0; size.value = to.query.size || 0; }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;课程页面\u0026lt;/h1\u0026gt; \u0026lt;h3\u0026gt;讲师：{{ name }}\u0026lt;/h3\u0026gt; \u0026lt;div\u0026gt;当前页：{{ page }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;数量：{{ size }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 详细见：src-2.zip\nURL动态参数 上面一种情况是get请求时携带参数（Query String），参数跟在?后面，例如xxx.xxx.com/course?page=2\u0026amp;size=1\n除此之外，在路径中也可以携带参数\n1 2 \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;Detail\u0026#39;,params:{id:99},query:{size:22,page:19}}\u0026#34;\u0026gt;详细-99-22-19\u0026lt;/router-link\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;Detail\u0026#39;,params:{id:100},query:{size:11,page:19}}\u0026#34;\u0026gt;详细-100-11-19\u0026lt;/router-link\u0026gt; 组件内接收\n传递的参数对象存储在route.params中，同样的也会出现同页面跳转的不刷新问题，同样使用路由守卫手动赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;script setup\u0026gt; import {useRoute, onBeforeRouteUpdate} from \u0026#34;vue-router\u0026#34;; import {ref} from \u0026#34;vue\u0026#34;; const route = useRoute(); const v1 = ref(route.query); const v2 = ref(route.params); onBeforeRouteUpdate((to) =\u0026gt; { v1.value = to.query; v2.value = to.params; }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;详细\u0026lt;/h2\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;{{ v1 }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ v2 }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 详细见：src-3.zip\n路由嵌套 小tip：\n例如/pin是一个一级页面，旗下有/pin/hot，/pin/new等二级页面，当访问/pin时，应当将而二级页面的内容也渲染到页面中，即自动选择一个二级页面。有两种实现\n在配置二级路由时，如果没有匹配空，也给他配置一个组件即访问/pin会加载NewView.vue\n1 2 3 4 { path: \u0026#39;\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/NewView.vue\u0026#39;), }, 跳转\n在二级路由处配置跳转\n1 2 3 4 { path: \u0026#39;\u0026#39;, redirect: {name: \u0026#34;New\u0026#34;}, }, 一级路由配置时直接指向默认的二级路由\n当访问/pin时，直接指向/pin/new\n1 2 3 4 5 //旧 \u0026lt;router-link to=\u0026#34;/pins\u0026#34;\u0026gt;沸点\u0026lt;/router-link\u0026gt; //新（两种写法都可以） \u0026lt;router-link to=\u0026#34;/pins/new\u0026#34;\u0026gt;沸点\u0026lt;/router-link\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;New\u0026#39;}\u0026#34;\u0026gt;沸点\u0026lt;/router-link\u0026gt; App.vue\n1 2 3 4 5 \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;源代码教育\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/home\u0026#34;\u0026gt;首页\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/course\u0026#34;\u0026gt;课程\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/pins\u0026#34;\u0026gt;沸点\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/news\u0026#34;\u0026gt;资讯\u0026lt;/router-link\u0026gt; PinsView.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;上面的内容\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;左边菜单\u0026lt;/h3\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;Hot\u0026#39;}\u0026#34;\u0026gt;热点\u0026lt;/router-link\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;New\u0026#39;}\u0026#34;\u0026gt;最新\u0026lt;/router-link\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;Following\u0026#39;}\u0026#34;\u0026gt;关注\u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;右边的内容\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;PinsView\u0026#34; } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; router/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import {createRouter, createWebHistory} from \u0026#39;vue-router\u0026#39; import HomeView from \u0026#39;../views/HomeView.vue\u0026#39; const routes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#34;Index\u0026#34;, component: HomeView }, { path: \u0026#39;/home\u0026#39;, name: \u0026#39;Home\u0026#39;, component: HomeView }, { path: \u0026#39;/pins\u0026#39;, // name: \u0026#39;Pins\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/PinsView.vue\u0026#39;), children: [ { path: \u0026#39;\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/NewView.vue\u0026#39;), }, { path: \u0026#39;new\u0026#39;, name: \u0026#39;New\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/NewView.vue\u0026#39;), }, { path: \u0026#39;hot\u0026#39;, name: \u0026#39;Hot\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/HotView.vue\u0026#39;), }, { path: \u0026#39;following\u0026#39;, name: \u0026#39;Following\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/FollowingView.vue\u0026#39;), } ] }, { path: \u0026#39;/course\u0026#39;, name: \u0026#39;Course\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/CourseView.vue\u0026#39;) }, { path: \u0026#39;/detail/:id\u0026#39;, name: \u0026#39;Detail\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/DetailView.vue\u0026#39;) }, { path: \u0026#39;/news\u0026#39;, name: \u0026#39;News\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/NewsView.vue\u0026#39;) } ] const router = createRouter({ history: createWebHistory(), routes }) export default router 编程式导航 想要实现点击跳转到其他页面并加载组件，常见的有两种实现：\n一个就是我们前面使用的router-link标签，再一个就是我们的编程式导航\n在 Vue2的Router 中，可以通过 this.$router.push()、this.$router.replace() 和 this.$router.go() 等方法实现编程式导航\nthis.$router.push()与this.$router.replace()的语法和效果几乎相同，唯一的区别就是， this.$router.push()是在历史记录中push了一个新纪录，当点击回退时可以返回。而this.$router.replace()是replace当前记录，点击回退时无法返回原页面\nthis.$router.go() 方法用于在浏览器的历史记录中前进或后退指定的步数。\n在Vue3中，没有this.$router，需要我们手动导入并实例化一个router对象\n详细如下：\n传递一个对象，可以有name或者path，传参使用params和query\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;新闻页面\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;跳转\u0026#34; @click=\u0026#34;doClick\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import {useRouter} from \u0026#39;vue-router\u0026#39; const router = useRouter(); function doClick() { //跳转到首页 [Course,] // router.push({path:\u0026#34;/home\u0026#34;}) // router.push({name:\u0026#34;Home\u0026#34;}) // router.push({name: \u0026#34;Course\u0026#34;, query: {page: 10, size: 20}}) router.push({name: \u0026#34;Detail\u0026#34;, params: {id: 100}, query: {page: 10, size: 20}}) // router.replace({path:\u0026#34;/home\u0026#34;}) // router.replace({name:\u0026#34;Home\u0026#34;}) // router.replace({name: \u0026#34;Course\u0026#34;, query: {page: 10, size: 20}}) // router.replace({name: \u0026#34;Detail\u0026#34;, params: {id: 100}, query: {page: 10, size: 20}}) // router.replace({name: \u0026#34;Course\u0026#34;, query: {page: 10, size: 20}}) } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 登录跳转（含顶部） 与其他一级标题相同，只需要编写自己的页面，然后切换时就可以嵌入到router-view中，保留顶部\nApp.vue\n1 2 3 4 5 6 7 8 9 10 \u0026lt;nav\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;源代码教育\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/home\u0026#34;\u0026gt;首页\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/course\u0026#34;\u0026gt;课程\u0026lt;/router-link\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;New\u0026#39;}\u0026#34;\u0026gt;沸点\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/news\u0026#34;\u0026gt;资讯\u0026lt;/router-link\u0026gt; \u0026lt;div style=\u0026#34;float: right\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;Login\u0026#39;}\u0026#34;\u0026gt;登录\u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import {createRouter, createWebHistory} from \u0026#39;vue-router\u0026#39; import HomeView from \u0026#39;../views/HomeView.vue\u0026#39; const routes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#34;Index\u0026#34;, component: HomeView }, { path: \u0026#39;/home\u0026#39;, name: \u0026#39;Home\u0026#39;, component: HomeView }, { path: \u0026#39;/pins\u0026#39;, // name: \u0026#39;Pins\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/PinsView.vue\u0026#39;), children: [ { path: \u0026#39;\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/NewView.vue\u0026#39;), }, { path: \u0026#39;new\u0026#39;, name: \u0026#39;New\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/NewView.vue\u0026#39;), }, { path: \u0026#39;hot\u0026#39;, name: \u0026#39;Hot\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/HotView.vue\u0026#39;), }, { path: \u0026#39;following\u0026#39;, name: \u0026#39;Following\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/FollowingView.vue\u0026#39;), } ] }, { path: \u0026#39;/course\u0026#39;, name: \u0026#39;Course\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/CourseView.vue\u0026#39;) }, { path: \u0026#39;/detail/:id\u0026#39;, name: \u0026#39;Detail\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/DetailView.vue\u0026#39;) }, { path: \u0026#39;/news\u0026#39;, name: \u0026#39;News\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/NewsView.vue\u0026#39;) }, { path: \u0026#39;/login\u0026#39;, name: \u0026#39;Login\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/LoginView.vue\u0026#39;) } ] const router = createRouter({ history: createWebHistory(), routes }) export default router LoginView.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;script setup\u0026gt; import {ref} from \u0026#34;vue\u0026#34;; import {useRouter} from \u0026#34;vue-router\u0026#34;; const router = useRouter(); const username = ref(\u0026#34;\u0026#34;); const password = ref(\u0026#34;\u0026#34;); function doLogin() { if (username.value.length \u0026gt; 0 \u0026amp;\u0026amp; password.value.length \u0026gt; 0) { console.log(\u0026#34;登录成功\u0026#34;) router.replace({name: \u0026#34;Home\u0026#34;}) } else { console.log(\u0026#34;失败\u0026#34;) } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div style=\u0026#34;width: 400px;height: 200px;margin: 100px auto;\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; v-model=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;登录\u0026#34; @click=\u0026#34;doLogin\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 详见：src-4.zip\n登录跳转（不含顶部） 需要将登录与其他一级路由独立开来，路由结构如下图，这样就可以保证登录界面无顶部，而其他页面都有导航栏\n详见：src-5.zip\nApp.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; body { margin: 0; } .container { width: 980px; margin: 0 auto; } \u0026lt;/style\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 import {createRouter, createWebHistory} from \u0026#39;vue-router\u0026#39; import HomeView from \u0026#39;../views/HomeView.vue\u0026#39; const routes = [ { path: \u0026#39;/login\u0026#39;, name: \u0026#39;Login\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/LoginView.vue\u0026#39;) }, { path: \u0026#39;/\u0026#39;, component: HomeView, children: [ { path: \u0026#39;\u0026#39;, redirect: {name: \u0026#39;Index\u0026#39;}, }, { path: \u0026#39;index\u0026#39;, name: \u0026#39;Index\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/IndexView.vue\u0026#39;) }, { path: \u0026#39;/course\u0026#39;, name: \u0026#39;Course\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/CourseView.vue\u0026#39;) }, { path: \u0026#39;/news\u0026#39;, name: \u0026#39;News\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/NewsView.vue\u0026#39;) }, { path: \u0026#39;/pins\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/PinsView.vue\u0026#39;), children: [ { path: \u0026#39;\u0026#39;, redirect: {name: \u0026#39;New\u0026#39;}, }, { path: \u0026#39;new\u0026#39;, name: \u0026#39;New\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/NewView.vue\u0026#39;), }, { path: \u0026#39;hot\u0026#39;, name: \u0026#39;Hot\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/HotView.vue\u0026#39;), }, { path: \u0026#39;following\u0026#39;, name: \u0026#39;Following\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/FollowingView.vue\u0026#39;), } ] }, ] }, ] const router = createRouter({ history: createWebHistory(), routes }) export default router HomeView.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;menu\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;源代码教育\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/index\u0026#34;\u0026gt;首页\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/course\u0026#34;\u0026gt;课程\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/pins\u0026#34;\u0026gt;沸点\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/news\u0026#34;\u0026gt;资讯\u0026lt;/router-link\u0026gt; \u0026lt;div style=\u0026#34;float: right\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;Login\u0026#39;}\u0026#34;\u0026gt;登录\u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // @ is an alias to /src export default { name: \u0026#39;HomeView\u0026#39;, } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .menu { height: 48px; line-height: 48px; background-color: #499ef3; } .menu a { text-decoration: none; margin: 0 10px; color: white; display: inline-block; } \u0026lt;/style\u0026gt; PinsVIew.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;上面的内容\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;左边菜单\u0026lt;/h3\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;Hot\u0026#39;}\u0026#34;\u0026gt;热点\u0026lt;/router-link\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;New\u0026#39;}\u0026#34;\u0026gt;最新\u0026lt;/router-link\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;Following\u0026#39;}\u0026#34;\u0026gt;关注\u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;右边的内容\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;PinsView\u0026#34; } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 导航守卫（全局） main.js配置全局导航守卫\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import {createRouter, createWebHistory} from \u0026#39;vue-router\u0026#39; import HomeView from \u0026#39;../views/HomeView.vue\u0026#39; const routes = [ { path: \u0026#39;/login\u0026#39;, name: \u0026#39;Login\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/LoginView.vue\u0026#39;), }, ... ] const router = createRouter({ history: createWebHistory(), routes }) router.beforeEach((to, from, next) =\u0026gt; { // to，即将访问路由对象 // from，当前正要离开路由 // next() 继续向后执行，去to的页面 // next(false) 不跳转，还在当前页面。 // next(\u0026#34;/xxx\u0026#34;) next({name:\u0026#34;xxx\u0026#34;}) next({pat:\u0026#34;/xxx\u0026#34;}) 指定跳转目标 let token = sessionStorage.getItem(\u0026#34;isLogin\u0026#34;); if (token) { // 已登录，可以向目标地址访问 next(); return } // 未登录，判断要访问的是否是登录页面 if (to.name === \u0026#34;Login\u0026#34;) { next(); return; } // 未登录，指定跳转回登录页面 next({name: \u0026#34;Login\u0026#34;}); }) export default router LoginView.vue\n对于登录成功的用户，给sessionStorage中赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;template\u0026gt; \u0026lt;div style=\u0026#34;width: 400px;height: 200px;margin: 100px auto;\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; v-model=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;登录\u0026#34; @click=\u0026#34;doLogin\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import {useRouter} from \u0026#39;vue-router\u0026#39; import {ref} from \u0026#39;vue\u0026#39; const router = useRouter(); const username = ref(\u0026#34;\u0026#34;); const password = ref(\u0026#34;\u0026#34;); function doLogin() { //... if (username.value.length \u0026gt; 0 \u0026amp;\u0026amp; password.value.length \u0026gt; 0) { console.log(\u0026#34;登录成功\u0026#34;); sessionStorage.setItem(\u0026#34;isLogin\u0026#34;,true); router.replace({name: \u0026#34;Index\u0026#34;}) } else { console.log(\u0026#34;登录失败\u0026#34;); } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 详见：src-6.zip\n存储数据 cookie，超时时间+发送请求自动携带\nsessionStorage，当浏览器关闭时，自动清除\nlocalStorage，长时间在存储浏览器\n1 2 3 4 localStorage.setItem(key,value) localStorage.getItem(key) localStorage.removeItem(key) localStorage.clear() 常用cookie和localStorage，且localStorage操作比较方便\nvuex 安装 1 2 npm install vue-vuex --save 手动创建文件+配置 或\n1 vue add vuex （推荐） 使用示例 案例（vuex+存储+导航守卫） 梳理：\n1 2 3 4 5 6 导航守卫--\u0026gt;router/index.js中router.beforeEach方法检测localStorage中是否有token或username，如没有即未登录，还要访问除了登录页面以外的网页，直接跳转回登录 登录：commit触发login方法，将登录信息传递给vuex，vuex负责将信息存储到内存中state的username和token，以及localStorage中（当页面刷新时重新加载state中的username和token） homeView.vue：当state.username有数据时，登录按钮会变成用户的username且点击触发注销功能 注销：commit触发logout方法并且跳转回登录页面 state和localStorage的操作都放在vuex中，外部通过commit间接操作state，方便维护 router/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 import {createRouter, createWebHistory} from \u0026#39;vue-router\u0026#39; import HomeView from \u0026#39;../views/HomeView.vue\u0026#39; const routes = [ { path: \u0026#39;/login\u0026#39;, name: \u0026#39;Login\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/LoginView.vue\u0026#39;) }, { path: \u0026#39;/\u0026#39;, component: HomeView, children: [ { path: \u0026#39;\u0026#39;, redirect: {name: \u0026#39;Index\u0026#39;}, }, { path: \u0026#39;index\u0026#39;, name: \u0026#39;Index\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/IndexView.vue\u0026#39;) }, { path: \u0026#39;/course\u0026#39;, name: \u0026#39;Course\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/CourseView.vue\u0026#39;) }, { path: \u0026#39;/news\u0026#39;, name: \u0026#39;News\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/NewsView.vue\u0026#39;) }, { path: \u0026#39;/pins\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/PinsView.vue\u0026#39;), children: [ { path: \u0026#39;\u0026#39;, redirect: {name: \u0026#39;New\u0026#39;}, }, { path: \u0026#39;new\u0026#39;, name: \u0026#39;New\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/NewView.vue\u0026#39;), }, { path: \u0026#39;hot\u0026#39;, name: \u0026#39;Hot\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/HotView.vue\u0026#39;), }, { path: \u0026#39;following\u0026#39;, name: \u0026#39;Following\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/FollowingView.vue\u0026#39;), } ] }, ] }, ] const router = createRouter({ history: createWebHistory(), routes }) router.beforeEach((to, from, next) =\u0026gt; { // to，即将访问路由对象 // from，当前正要离开路由 // next() 继续向后执行，去to的页面 // next(false) 不跳转，还在当前页面。 // next(\u0026#34;/xxx\u0026#34;) next({name:\u0026#34;xxx\u0026#34;}) next({pat:\u0026#34;/xxx\u0026#34;}) 指定跳转目标 let token = localStorage.getItem(\u0026#34;token\u0026#34;); if (token) { // 已登录，可以向目标地址访问 next(); return } // 未登录，判断要访问的是否是登录页面 if (to.name === \u0026#34;Login\u0026#34;) { next(); return; } // 未登录，指定跳转回登录页面 next({name: \u0026#34;Login\u0026#34;}); }) export default router store/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import {createStore} from \u0026#39;vuex\u0026#39; export default createStore({ state: { username: localStorage.getItem(\u0026#39;username\u0026#39;), token: localStorage.getItem(\u0026#39;token\u0026#39;), }, getters: {}, mutations: { login(state, {username, token}) { state.username = username state.token = token //保存在localStorage中 localStorage.setItem(\u0026#39;username\u0026#39;, username) localStorage.setItem(\u0026#39;token\u0026#39;, token) }, logout(state) { state.username = \u0026#39;\u0026#39; state.token = \u0026#39;\u0026#39; //清除localStorage localStorage.removeItem(\u0026#39;username\u0026#39;) localStorage.removeItem(\u0026#39;token\u0026#39;) } }, actions: {}, modules: {} }) HomeView.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;menu\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;源代码教育\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/index\u0026#34;\u0026gt;首页\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/course\u0026#34;\u0026gt;课程\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/pins\u0026#34;\u0026gt;沸点\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/news\u0026#34;\u0026gt;资讯\u0026lt;/router-link\u0026gt; \u0026lt;div style=\u0026#34;float: right\u0026#34;\u0026gt; \u0026lt;a v-if=\u0026#34;name\u0026#34; @click=\u0026#34;doLogout\u0026#34;\u0026gt;{{ name }}\u0026lt;/a\u0026gt; \u0026lt;router-link v-else :to=\u0026#34;{name:\u0026#39;Login\u0026#39;}\u0026#34;\u0026gt;登录\u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import {ref} from \u0026#34;vue\u0026#34;; import {useStore} from \u0026#34;vuex\u0026#34;; import {useRouter} from \u0026#34;vue-router\u0026#34;; const router = useRouter(); const store = useStore(); const name = ref(store.state.username) function doLogout() { //localStorage清空 + state值清空 + 跳转登录 store.commit(\u0026#34;logout\u0026#34;) router.push({name: \u0026#39;Login\u0026#39;}); } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .menu { height: 48px; line-height: 48px; background-color: #499ef3; } .menu a { text-decoration: none; margin: 0 10px; color: white; display: inline-block; } \u0026lt;/style\u0026gt; LoginView.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;script setup\u0026gt; import {ref} from \u0026#34;vue\u0026#34;; import {useRouter} from \u0026#34;vue-router\u0026#34;; import {useStore} from \u0026#34;vuex\u0026#34;; const router = useRouter(); const store = useStore(); const username = ref(\u0026#34;\u0026#34;); const password = ref(\u0026#34;\u0026#34;); function doLogin() { if (username.value.length \u0026gt; 0 \u0026amp;\u0026amp; password.value.length \u0026gt; 0) { console.log(\u0026#34;登录成功\u0026#34;); //调用login方法 const response = { username: username.value, token: \u0026#34;ed5cf238-d8ce-49f9-a1cf-cef55d689a2b\u0026#34;, id: 1000 } store.commit(\u0026#34;login\u0026#34;, response) router.replace({path: \u0026#34;/index\u0026#34;}) console.log(\u0026#34;跳转成功\u0026#34;) } else { console.log(\u0026#34;失败\u0026#34;) } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div style=\u0026#34;width: 400px;height: 200px;margin: 100px auto;\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; v-model=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;登录\u0026#34; @click=\u0026#34;doLogin\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 详见：src10.zip\n案例（动态购物车） 实现点击按钮加入购物车，页面右上角显示购物车商品数量也实时+1\nNewsView.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;script setup\u0026gt; import {useStore} from \u0026#34;vuex\u0026#34;; const store = useStore(); function addCar() { //当前购物车数量+1 store.commit(\u0026#34;addCar\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h1\u0026gt;新闻页面\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;加入购物车\u0026#34; @click=\u0026#34;addCar\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; store/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import {createStore} from \u0026#39;vuex\u0026#39; export default createStore({ state: { username: localStorage.getItem(\u0026#39;username\u0026#39;), token: localStorage.getItem(\u0026#39;token\u0026#39;), car: 0, }, getters: {}, mutations: { login(state, {username, token}) { state.username = username state.token = token //保存在localStorage中 localStorage.setItem(\u0026#39;username\u0026#39;, username) localStorage.setItem(\u0026#39;token\u0026#39;, token) }, logout(state) { state.username = \u0026#39;\u0026#39; state.token = \u0026#39;\u0026#39; //清除localStorage localStorage.removeItem(\u0026#39;username\u0026#39;) localStorage.removeItem(\u0026#39;token\u0026#39;) }, addCar(state) { state.car += 1 console.log(state.car) } }, actions: {}, modules: {} }) HomeView.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;menu\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;源代码教育\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/index\u0026#34;\u0026gt;首页\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/course\u0026#34;\u0026gt;课程\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/pins\u0026#34;\u0026gt;沸点\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/news\u0026#34;\u0026gt;资讯\u0026lt;/router-link\u0026gt; \u0026lt;div style=\u0026#34;float: right\u0026#34;\u0026gt; \u0026lt;span\u0026gt;购物车有{{ carNum }}件商品\u0026lt;/span\u0026gt; \u0026lt;a v-if=\u0026#34;name\u0026#34; @click=\u0026#34;doLogout\u0026#34;\u0026gt;{{ name }}\u0026lt;/a\u0026gt; \u0026lt;router-link v-else :to=\u0026#34;{name:\u0026#39;Login\u0026#39;}\u0026#34;\u0026gt;登录\u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import {ref} from \u0026#34;vue\u0026#34;; import {useStore} from \u0026#34;vuex\u0026#34;; import {useRouter} from \u0026#34;vue-router\u0026#34;; const router = useRouter(); const store = useStore(); const name = ref(store.state.username) const carNum = ref(store.state.car) function doLogout() { //localStorage清空 + state值清空 + 跳转登录 store.commit(\u0026#34;logout\u0026#34;) router.push({name: \u0026#39;Login\u0026#39;}); } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .menu { height: 48px; line-height: 48px; background-color: #499ef3; } .menu a { text-decoration: none; margin: 0 10px; color: white; display: inline-block; } \u0026lt;/style\u0026gt; 但是运行发现，carNum数量确实加了，但是页面并没有变化（因为浏览器没有因此刷新）\n这就需要我们用到计算属性（购物车数量不同于用户名，登陆上了就不容易发生变化，相反，他是实时变化的，因此不适合使用普通的const对他进行一次赋值就放任不管，而是要实时检测数据，一旦发生变化，立刻更新）\n1 2 const name = ref(store.state.username) const carNum = ref(store.state.car) 同时，需要将数据备份到本地，当刷新后，从本地读取到内存中，实现记忆\nstore/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import {createStore} from \u0026#39;vuex\u0026#39; export default createStore({ state: { username: localStorage.getItem(\u0026#39;username\u0026#39;), token: localStorage.getItem(\u0026#39;token\u0026#39;), car: localStorage.getItem(\u0026#39;carNum\u0026#39;) || 0, }, getters: {}, mutations: { login(state, {username, token}) { state.username = username state.token = token //保存在localStorage中 localStorage.setItem(\u0026#39;username\u0026#39;, username) localStorage.setItem(\u0026#39;token\u0026#39;, token) }, logout(state) { state.username = \u0026#39;\u0026#39; state.token = \u0026#39;\u0026#39; //清除localStorage localStorage.removeItem(\u0026#39;username\u0026#39;) localStorage.removeItem(\u0026#39;token\u0026#39;) }, addCar(state) { state.car = parseInt(state.car) + 1 localStorage.setItem(\u0026#39;carNum\u0026#39;, state.car) } }, actions: {}, modules: {} }) HomeView.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;menu\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;源代码教育\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/index\u0026#34;\u0026gt;首页\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/course\u0026#34;\u0026gt;课程\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/pins\u0026#34;\u0026gt;沸点\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/news\u0026#34;\u0026gt;资讯\u0026lt;/router-link\u0026gt; \u0026lt;div style=\u0026#34;float: right\u0026#34;\u0026gt; \u0026lt;span\u0026gt;购物车有{{ carNum }}件商品\u0026lt;/span\u0026gt; \u0026lt;a v-if=\u0026#34;name\u0026#34; @click=\u0026#34;doLogout\u0026#34;\u0026gt;{{ name }}\u0026lt;/a\u0026gt; \u0026lt;router-link v-else :to=\u0026#34;{name:\u0026#39;Login\u0026#39;}\u0026#34;\u0026gt;登录\u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import {ref, computed} from \u0026#34;vue\u0026#34;; import {useStore} from \u0026#34;vuex\u0026#34;; import {useRouter} from \u0026#34;vue-router\u0026#34;; const router = useRouter(); const store = useStore(); const name = ref(store.state.username) const carNum = computed(() =\u0026gt; store.state.car) function doLogout() { //localStorage清空 + state值清空 + 跳转登录 store.commit(\u0026#34;logout\u0026#34;) router.push({name: \u0026#39;Login\u0026#39;}); } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .menu { height: 48px; line-height: 48px; background-color: #499ef3; } .menu a { text-decoration: none; margin: 0 10px; color: white; display: inline-block; } \u0026lt;/style\u0026gt; 详见：src-10.zip\nvue3-cookies 实现将数据在cookie中进行存取。\n安装 1 npm install vue3-cookies --save main.js配置\n1 2 3 4 5 6 7 import {createApp} from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; import VueCookies from \u0026#39;vue3-cookies\u0026#39; createApp(App).use(store).use(router).use(VueCookies).mount(\u0026#39;#app\u0026#39;) 使用\n1 2 3 4 5 import {useCookies} from \u0026#39;vue3-cookies\u0026#39; const {cookies} = useCookies(); cookies.set(\u0026#34;ts\u0026#34;, \u0026#34;123123\u0026#34;, \u0026#34;10s\u0026#34;) https://github.com/KanHarI/vue3-cookies\n使用示例 在上面的案例中，将username和token保存到cookie中，设置生效时间。\n对于常用的cookie操作，我们可以将其写到一个文件中封装为一个个函数，需要使用时引入即可\n/src/plugins/cookie.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import {useCookies} from \u0026#39;vue3-cookies\u0026#39; const {cookies} = useCookies(); export const getToken = () =\u0026gt; { return cookies.get(\u0026#39;token\u0026#39;) || \u0026#34;\u0026#34; } export const getUserName = () =\u0026gt; { return cookies.get(\u0026#39;username\u0026#39;) || \u0026#34;\u0026#34; } export const setUserToken = (user, token) =\u0026gt; { cookies.set(\u0026#39;username\u0026#39;, user, \u0026#34;10s\u0026#34;) cookies.set(\u0026#39;token\u0026#39;, token, \u0026#34;10s\u0026#34;) } export const clearUserToken = () =\u0026gt; { cookies.remove(\u0026#39;username\u0026#39;) cookies.remove(\u0026#39;token\u0026#39;) } 使用时只需要从cookie.js中导入需要使用的函数，然后直接调用即可\n修改后的/store/index.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import {createStore} from \u0026#39;vuex\u0026#39; import {getUserName, getToken, setUserToken, clearUserToken} from \u0026#34;@/plugins/cookie\u0026#34;; export default createStore({ state: { // username: localStorage.getItem(\u0026#39;username\u0026#39;), // token: localStorage.getItem(\u0026#39;token\u0026#39;), username: getUserName(), token: getToken(), car: localStorage.getItem(\u0026#39;carNum\u0026#39;) || 0, }, getters: {}, mutations: { login(state, {username, token}) { state.username = username state.token = token //保存在localStorage中 // localStorage.setItem(\u0026#39;username\u0026#39;, username) // localStorage.setItem(\u0026#39;token\u0026#39;, token) setUserToken(username, token) }, logout(state) { state.username = \u0026#39;\u0026#39; state.token = \u0026#39;\u0026#39; //清除localStorage // localStorage.removeItem(\u0026#39;username\u0026#39;) // localStorage.removeItem(\u0026#39;token\u0026#39;) clearUserToken() }, addCar(state) { state.car = parseInt(state.car) + 1 localStorage.setItem(\u0026#39;carNum\u0026#39;, state.car) } }, actions: {}, modules: {} }) 同样的，router/index.js中导航守卫的操作也需要更新\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import {getToken} from \u0026#34;@/plugins/cookie\u0026#34;; router.beforeEach((to, from, next) =\u0026gt; { let token = getToken(); if (token) { // 已登录，可以向目标地址访问 next(); return } // 未登录，判断要访问的是否是登录页面 if (to.name === \u0026#34;Login\u0026#34;) { next(); return; } // 未登录，指定跳转回登录页面 next({name: \u0026#34;Login\u0026#34;}); }) 详见：src11.zip\naxios 安装 1 2 npm install axios --save 手动配置 或\n1 vue add axios 因为我们需要在它本身的基础上进行拓展，因此直接选取npm安装然后手动配置\n主要配置文件时/src/plugins/axios.js\n使用示例 快速发送 axios.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* eslint-disable */ import axios from \u0026#34;axios\u0026#34;; axios.defaults.baseURL = \u0026#39;https://api.luffycity.com/api/\u0026#39;; // axios.defaults.headers.common[\u0026#39;Authorization\u0026#39;] = getToken(); // axios.defaults.headers.post[\u0026#39;Content-Type\u0026#39;] = \u0026#39;application/json\u0026#39;; let config = { // baseURL: process.env.baseURL || process.env.apiUrl || \u0026#34;\u0026#34; // timeout: 60 * 1000, // Timeout // withCredentials: true, // Check cross-site Access-Control }; const _axios = axios.create(config); export default _axios; LoginView.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 \u0026lt;script setup\u0026gt; import {ref} from \u0026#34;vue\u0026#34;; import {useRouter} from \u0026#34;vue-router\u0026#34;; import {useStore} from \u0026#34;vuex\u0026#34;; import _axios from \u0026#34;@/plugins/axios\u0026#34;; const router = useRouter(); const store = useStore(); const username = ref(\u0026#34;\u0026#34;); const password = ref(\u0026#34;\u0026#34;); function doLogin() { //发送网路请求 _axios.post(\u0026#34;/v1/auth/password/login/?loginWay=password\u0026#34;, { username: \u0026#34;alex\u0026#34;, password: \u0026#34;dsb\u0026#34; }).then((res) =\u0026gt; { // {\u0026#34;code\u0026#34;:-1,\u0026#34;msg\u0026#34;:\u0026#34;校验错误\u0026#34;,\u0026#34;data\u0026#34;:{\u0026#34;global_error\u0026#34;:[\u0026#34;密码错误\u0026#34;]}} console.log(\u0026#34;成功\u0026#34;, res.data); }).catch((error) =\u0026gt; { console.log(\u0026#34;失败\u0026#34;, error); }) if (username.value.length \u0026gt; 0 \u0026amp;\u0026amp; password.value.length \u0026gt; 0) { console.log(\u0026#34;登录成功\u0026#34;); //调用login方法 const response = { username: username.value, token: \u0026#34;ed5cf238-d8ce-49f9-a1cf-cef55d689a2b\u0026#34;, id: 1000 } store.commit(\u0026#34;login\u0026#34;, response) router.replace({path: \u0026#34;/index\u0026#34;}) console.log(\u0026#34;跳转成功\u0026#34;) } else { console.log(\u0026#34;失败\u0026#34;) } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div style=\u0026#34;width: 400px;height: 200px;margin: 100px auto;\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; v-model=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;登录\u0026#34; @click=\u0026#34;doLogin\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 详见：src12.zip\n拦截器 发送每个请求执行操作，每个请求返回的执行操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 /* eslint-disable */ import axios from \u0026#34;axios\u0026#34;; import {useRouter} from \u0026#34;vue-router\u0026#34;; import {useStore} from \u0026#34;vuex\u0026#34;; import {getToken} from \u0026#34;@/plugins/cookie\u0026#34;; const router = useRouter(); const store = useStore(); axios.defaults.baseURL = \u0026#39;https://api.luffycity.com/api/\u0026#39;; // axios.defaults.headers.common[\u0026#39;Authorization\u0026#39;] = getToken(); // axios.defaults.headers.post[\u0026#39;Content-Type\u0026#39;] = \u0026#39;application/json\u0026#39;; let config = { // baseURL: process.env.baseURL || process.env.apiUrl || \u0026#34;\u0026#34; // timeout: 60 * 1000, // Timeout // withCredentials: true, // Check cross-site Access-Control }; const _axios = axios.create(config); _axios.interceptors.request.use( function (config) { // Do something before request is sent // console.log(\u0026#34;请求前执行\u0026#34;); const token = getToken(); if (token) { config.headers[\u0026#39;token\u0026#39;] = token; } return config; } ); // 浏览器上有Token，但是Token在后端已经失效 _axios.interceptors.response.use( function (response) { // Do something with response data // 请求成功 200成功（登录失效了）{code:-1,msg:\u0026#34;登录失效\u0026#34;} {code:0,msg:data} {code:1000,msg:\u0026#34;认证失败\u0026#34;} if (response.data.code === 1000) { //认证失败，token过期，登录失败 -\u0026gt; 登录页面 store.commit(\u0026#34;logout\u0026#34;); router.replace({name: \u0026#34;Login\u0026#34;}); return Promise.reject(); } return response; }, function (error) { // Do something with response error // 请求失败自动执行此处的代码，返回的状态码：500（认证401） if (error.response.status === 401) { store.commit(\u0026#34;logout\u0026#34;); router.replace({name: \u0026#34;Login\u0026#34;}); } return Promise.reject(error); } ); export default _axios; 对于请求失败与否，从请求本身的角度来讲，200是请求成功，其他状态码比如401等等就属于请求失败，会触发响应拦截器的function (error)。但这种请求码有局限，类型太少了，因此企业会人为规定一些状态码，就不采用200这种形式\n而是在response中添加一个status参数来显示状态，例如0表示成功，-1表示失败等。这种就需要在响应拦截器的function (response)中人为做进一步区分。\n请求拦截器中可以用于在请求中携带token等等操作\n总之，有了拦截器就可以对发送的请求和服务器的响应高度定制，灵活控制\n详见：src-12.zip\n后端API 跨域问题 当前浏览器访问地址：http://localhost:8080/news\n点击发送网络请求：https://api.luffycity.com/api/xxxx/xxxx/ 本质上想要处理跨域，添加一些响应头即可。\n如果发送的网址，请求方式或者包含了不被允许的请求头，预检不通过，浏览器不会发起真实的请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from django.shortcuts import render from django.http import JsonResponse def user_list(request): info = {\u0026#34;code\u0026#34;: 0, \u0026#39;data\u0026#39;: \u0026#34;success\u0026#34;} response = JsonResponse(info) # 响应头 print(request.method) # 任意网址 response[\u0026#34;Access-Control-Allow-Origin\u0026#34;] = \u0026#34;*\u0026#34; # 任意的请求方式 response[\u0026#34;Access-Control-Allow-Methods\u0026#34;] = \u0026#34;*\u0026#34; # \u0026#34;PUT,DELETE,GET,POST\u0026#34; # 允许任意的请求头 response[\u0026#34;Access-Control-Allow-Headers\u0026#34;] = \u0026#34;*\u0026#34; return response 注意：测试时一定要移除csrf认证。\n现象（2个请求） 跨域时发送的是：\n简单请求：1个请求 复杂请求：2个请求 OPTIONS请求，预检 真正的请求 1 2 3 4 5 6 7 8 9 10 11 条件： ``1``、请求方式：HEAD、GET、POST ``2``、请求头信息： ``Accept ``Accept``-``Language ``Content``-``Language ``Last``-``Event``-``ID ``Content``-``Type` `对应的值是以下三个中的任意一个 ``application``/``x``-``www``-``form``-``urlencoded ``multipart``/``form``-``data ``text``/``plain 1 注意：同时满足以上两个条件时，则是简单请求，否则为复杂请求 如果非要避免这种情况，那就别跨域。\n主域名+API域名（有跨域）\n1 2 https://www.luffycity.com/free-course https://api.luffycity.com/api/v1/course/category/actual/?courseType=actual 主域名+API域名（无跨域，但要防止与前端使用的地址冲突）\n1 2 https://www.luffycity.com/free-course https://www.luffycity.com/api/... 最后跨域 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from django.shortcuts import render from django.http import JsonResponse def user_list(request): info = {\u0026#34;code\u0026#34;: 0, \u0026#39;data\u0026#39;: \u0026#34;success\u0026#34;} response = JsonResponse(info) # 响应头 print(request.method) # 任意网址 response[\u0026#34;Access-Control-Allow-Origin\u0026#34;] = \u0026#34;*\u0026#34; # 任意的请求方式 response[\u0026#34;Access-Control-Allow-Methods\u0026#34;] = \u0026#34;*\u0026#34; # \u0026#34;PUT,DELETE,GET,POST\u0026#34; # 允许任意的请求头 response[\u0026#34;Access-Control-Allow-Headers\u0026#34;] = \u0026#34;*\u0026#34; return response 写在中间件的process_response中\n在django的settings.py中将中间件用上即可\n1 2 3 4 5 6 7 8 9 10 11 12 from django.utils.deprecation import MiddlewareMixin class CorsMiddleware(MiddlewareMixin): def process_response(self, request, response): # 任意网址 response[\u0026#34;Access-Control-Allow-Origin\u0026#34;] = \u0026#34;*\u0026#34; # 任意的请求方式 response[\u0026#34;Access-Control-Allow-Methods\u0026#34;] = \u0026#34;*\u0026#34; # \u0026#34;PUT,DELETE,GET,POST\u0026#34; # 允许任意的请求头 response[\u0026#34;Access-Control-Allow-Headers\u0026#34;] = \u0026#34;*\u0026#34; return response ","date":"2025-02-27T19:08:25+08:00","permalink":"https://yn0t1me.github.io/p/vue3/","title":"Vue3"},{"content":"这是摘要\nVue介绍 前端发展史 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 1 html(5),css(3),javascript=(ECMA:5，补充es6语法,最新:13，bom:浏览器对象,dom:文档对象)--\u0026gt; 编写一个个的页面 -\u0026gt; 给后端(PHP、Python、Go、Java) -\u0026gt; 后端嵌入模板语法(dtl:django的模版语法 xx.html ) -\u0026gt; 后端渲染完数据 -\u0026gt; 返回数据给前端 -\u0026gt; 在浏览器中查看 -es6更新内容 箭头函数，模块导入，let -模版语法：例如django的模板语法，在index.html中写了python语法 {% %}---》模版语法 - 在{% %}中写入python语法的表达式，python解释器负责把python语法解析完转成 纯粹的html，css，js # 2 Ajax的出现 -\u0026gt; 后台发送异步请求，Render+Ajax混合 # 3 单用Ajax（加载数据，DOM渲染页面）：前后端分离的雏形 # 4 Angular框架的出现（1个JS框架）：出现了“前端工程化”的概念（前端也是1个工程、1个项目）：笨重，越来越少的人用了 # 5 React、Vue框架：当下最火的2个前端框架（Vue：国人写的，国人喜欢用，中小厂，全栈工程师，React：外国人喜欢用，大厂喜欢用） # 6 移动开发（Android+IOS） + Web（Web+微信小程序+支付宝小程序） + 桌面开发（Windows桌面）：前端 -\u0026gt; 大前端 # 7 可不可以一套编码，多端运行 ：一套代码在各个平台运行（大前端）：谷歌Flutter平台（Dart语言：和Java很像）可以运行在IOS、Android、PC端，桌面端支持不好---》部分公司在用，坑比较多 # 8 在Vue框架的基础性上 uni-app：一套编码 编到10个平台----》学习vue的性价比很高 # 9 在不久的将来 ，前端框架可能会一统天下 # ts和es： typescript：微软出的脚本语言，强类型，微软开发的一个开源的编程语言，通过在JavaScript的基础上添加静态类型定义构建而成 ecma：标准---》js语言，弱类型 typescript是js的超集 写前端可以使用js，也可以使用ts，ts兼容js的 js：历史遗留了很多坑，未来可能会被替代 大前端时代：html,css,js---\u0026gt;PC端(网页)，移动端（安卓，ios）,小程序(微信官方:标签是html5内容) 时期1\n时期2\nVue介绍 Vue 是一个 js 框架(jquery也是js框架)，同时也是一个渐进式框架(单个页面使用vue或者整个项目都使用vue)\n是一套用于构建用户界面的渐进式框架 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用 Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合 官网：https://cn.vuejs.org/\nVue 版本问题：两个版本（些许差距，基础都是一样的）\n2.x版本：老版本 3.x版本：完整支持ts语法,2020年至今 vue： 正处于转型期，大量公司还在用vue3，少量公司在用vue3 特点：\n通过 HTML、CSS、JavaScript构建应用\u0026ndash;》要有这些东西基础 不断繁荣的生态系统，可以在一个库和一套完整框架之间自如伸缩 20kB min+gzip 运行大小 超快虚拟 DOM 最省心的优化 M-V-VM思想\ndjango:MTV 其他的一些后端框架mvc架构 MVP：移动端会使用 Vue：M-V-VM 架构 Model ：vue对象的data属性里面的数据，这里的数据要显示到页面中，js里面有变量 View ：vue中数据要显示的HTML页面，在vue中，也称之为“视图模板” （HTML+CSS） ViewModel：vue中编写代码时的vm对象，它是vue.js的核心，负责连接 View 和 Model数据的中转，保证视图和数据的一致性，所以前面代码中，data里面的数据被显示在p标签中就是vm对象自动完成的（双向数据绑定：JS中变量变了，HTML中数据也跟着改变） 以后不需要咱们操作dom了\u0026mdash;\u0026gt; 因为有vm可以帮我们监听Model数据变化，自动改变View\njquery选择器，原生js 完全用不到了\u0026mdash;\u0026gt; jq已经完成自己的历史使命了，慢慢退出舞台了\n组件化开发：组件化开发：把某些可能会多次使用的 htm，css，js，写成单独的，以后直接引入即可\n单页面开发：如果是vue项目，整个项目其实就一个 index.html 页面，看到的页面变化，不是多个html页面在变化，而是组件的替换\nVue的快速使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 补充：工欲善其事必先利其器 ---\u0026gt; 咱们要开发vue，需要有一个比较趁手 集成开发工具(IDE) -vscode:微软出的，不仅可以写前端，还可以写python,go..... 免费的 -Jetbrains捷克的公司公司出的：全家桶：pycharm，goland，IDEA(java)，phpstorm，webstorm(前端)。。。 -收费，挺贵 全家桶的授权：599刀一年 单版本授权 199刀 一年 -破解：pycharm本身跟webstorm师出同门 -直接使用Pycharm---\u0026gt;vue的插件，就可以写vue了----\u0026gt;讲课用，不需要再多下一个编辑器 -直接下载webstorm--\u0026gt;破解方案跟pycharm完全一样 # 使用Pycharm开发---\u0026gt;下载后有vue代码提示，不下也能开发vue -新建一个项目（python项目也可以） -装一个vue的插件：setting中搜plugins---\u0026gt;vue---\u0026gt;安装---\u0026gt;ok---\u0026gt;apply # Vue 就是一个js框架----》把源代码下载下来(cdn)，引入到页面中去 -先用vue2的讲：基础内容是一样的 -拿到vue2的源码，放在咱们工程中--》js文件夹下vue.js -渐进式框架---》在一个html中使用vue---》跟之前使用jq是一模一样 第一步：创建项目\n直接和新建一个python项目一样，没区别，且不用管python解释器 第二步：安装Vue插件（提供代码提示，更方便开发，不下也可以开发Vue）\n第三步：Vue导入本地（如果采用远程导入如cdn，则不需要这一步）\n因为Vue就是一个框架，和jquery一样，我们都需要把源代码下载下来，引入到页面中\nVue.js v2.7.16版本的cdn地址 https://cdn.jsdelivr.net/npm/vue/dist/vue.js 将上述地址的源码复制到项目目录下的js/vue.js文件 第四步：开发第一个vue项目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;!-- 引入vue,跟之前引入jquery是一样的--\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!--以后在这div内部，就可以写vue的语法了,插值语法，把变量放在{{}}内，它就会把变量渲染在这--\u0026gt; \u0026lt;h1\u0026gt;{{name}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; // 写js代码,new实例化得到一个vue对象,传入配置项，用{}包裹的是js中的一个对象，有key，有value的格式 new Vue({ el: \u0026#39;#app\u0026#39;, // 根据id 找到div，这个div就被vue托管了，以后div中就可以写vue的语法了 data: { name: \u0026#39;lqz\u0026#39; // 定义了一个变量 name } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 文本插值 文本插值（Text Interpolation）是通过双大括号 {{ }} 实现的，用于将 Vue 实例的数据动态插入到 HTML 模板中。文本插值可以插入的内容类型非常灵活，可以插入变量，函数和短的表达式\n补充说明一下：\n1 2 3 4 5 python 字典 {\u0026#39;name\u0026#39;:\u0026#39;lqz\u0026#39;,\u0026#39;age\u0026#39;:19} js 对象\t{name:\u0026#34;lqz\u0026#34;,age:19} python和js都支持将其对应的字典和对象转换为json字符串 json 格式：字符串 {\u0026#34;name\u0026#34;:\u0026#34;lqz\u0026#34;,\u0026#34;age\u0026#34;:19} js的对象中，key可以不用引号包裹，这是es6的新语法，旨在开发者少写代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;渲染变量\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;我的名字:{{name}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;我的年龄:{{age}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;数组:{{l}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;数组取值:{{l[1]}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;对象:{{obj}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;对象取值:{{obj[\u0026#39;age\u0026#39;]}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;对象取值:{{obj.name}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;标签：{{s}}\u0026lt;/p\u0026gt; \u0026lt;h1\u0026gt;渲染函数--后面讲\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;渲染表达式：三目运算符,一定不要写太长\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{{age \u0026gt; 20 ? \u0026#39;男人\u0026#39; : \u0026#39;男孩\u0026#39;}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{age == 19}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { name: \u0026#39;lqz\u0026#39;, age: 19, l: [1, 2, 3], // js中叫数组，python中叫列表 obj: {name: \u0026#39;彭于晏\u0026#39;, age: 40}, // js中叫对象，python中叫字典 对象取值不加引号，会将key值当成一个变量 s: \u0026#39;\u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt;\u0026#39;, // 字符串 t: 10 \u0026gt; 9 ? \u0026#39;大于\u0026#39; : \u0026#39;小于\u0026#39; // 跟python中的三元表达式是一样的 t= 条件 ? \u0026#39;符合条件\u0026#39;:\u0026#39;不符合\u0026#39; // t:\u0026#39;大于\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 显示结果：\n指令 指令是什么？\n放在标签上,以v-开头的，称之为指令，每个指令都能完成相应操作，例如：\n\u0026lt;p v-html='js变量，函数，表达式'\u0026gt; \u0026lt;/p\u0026gt;\n下面我们来具体学习不同的指令有什么功能\n文本指令（操作文本相关） v-html：把变量的内容当html渲染到标签中去（变量是一个字符串，包裹的内容是标签，会被完整渲染为标签）\nv-text:把变量内容当字符串写到到标签中（变量是一个字符串，包裹的内容是标签，不会渲染成标签，而是文本内容），如果原来标签内文本部分有内容，会被清空\nv-show：只能跟 true 或 false 或 表达式运算结果是布尔类型，控制标签的显示与否\nv-if ：只能跟 true 或 false 或 表达式运算结果是布尔类型，控制标签的显示与否\nvue中面试题：v-if和v-show区别是什么？\nv-if:如果是false，不显示，标签也不存在（需要删除和添加标签，效率低） v-show,如果是false，不显示，但是标签存在，只是通过样式 dispaly=none控制的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;v-html\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{{s}}\u0026lt;/p\u0026gt; \u0026lt;p v-html=\u0026#34;s\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;div v-html=\u0026#34;s\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;h1\u0026gt;v-test\u0026lt;/h1\u0026gt; \u0026lt;p v-text=\u0026#34;s\u0026#34;\u0026gt;美女\u0026lt;/p\u0026gt; \u0026lt;h1\u0026gt;v-show和v-if\u0026lt;/h1\u0026gt; \u0026lt;div v-show=\u0026#34;b2\u0026#34;\u0026gt;美女\u0026lt;/div\u0026gt; \u0026lt;div v-if=\u0026#34;b1\u0026#34;\u0026gt;帅哥\u0026lt;/div\u0026gt; \u0026lt;div v-show=\u0026#34;b1\u0026#34;\u0026gt;美女\u0026lt;/div\u0026gt; \u0026lt;div v-if=\u0026#34;b2\u0026#34;\u0026gt;帅哥\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { s: \u0026#39;\u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt;\u0026#39;, b1: true, b2: false } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 显示效果\n补充小知识：MVVM的双向数据绑定 双向数据绑定：model的数据变，view也跟着变；只要view变化，model也跟着变化\n1 2 3 4 5 6 7 8 var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { s: \u0026#39;\u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt;\u0026#39;, b1: true, b2: false } }) 把实例化后的Vue对象赋值给变量vm，以后从vm中可以通过 vm._data 取到 实例化的时候的data，也可以从vm.变量名取到data中的变量\n在控制台修改变量的值，页面会立马跟着变化 \u0026mdash;\u0026gt; 以后只需要修改变量值即可，不需要操作dom了\n如图，直接修改vm.b2=true，就可以显示出原先被隐藏的内容，可见，修改Model即可修改View\n后端数据库的值改变并不会引起页面变化，只有通过ajax请求到数据后，前端将数据给到Model，Model的变化才会引起View的变化\n那么View变化是否也会引起Model改变呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;v-html\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{{s}}\u0026lt;/p\u0026gt; \u0026lt;p v-html=\u0026#34;s\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;div v-html=\u0026#34;s\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;h1\u0026gt;v-test\u0026lt;/h1\u0026gt; \u0026lt;p v-text=\u0026#34;s\u0026#34;\u0026gt;美女\u0026lt;/p\u0026gt; \u0026lt;h1\u0026gt;v-show和v-if\u0026lt;/h1\u0026gt; \u0026lt;div v-show=\u0026#34;b2\u0026#34;\u0026gt;美女\u0026lt;/div\u0026gt; \u0026lt;div v-if=\u0026#34;b1\u0026#34;\u0026gt;帅哥\u0026lt;/div\u0026gt; \u0026lt;div v-show=\u0026#34;b1\u0026#34;\u0026gt;美女\u0026lt;/div\u0026gt; \u0026lt;div v-if=\u0026#34;b2\u0026#34;\u0026gt;帅哥\u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { s: \u0026#39;\u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt;\u0026#39;, b1: true, b2: false, name: \u0026#39;\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 创建一个空的input框，当在页面上填入内容时，name也相应发生变化\n至此我们已经看到了Vue的双向数据绑定\n事件指令 v-on：给标签绑定一个事件，当触发这个事件，就会执行函数\n语法：v-on:事件名='函数'，可以简写成@事件名='函数'（常用）\n1 2 \u0026lt;button class=\u0026#34;btn btn-danger\u0026#34; v-on:click=\u0026#34;handleClick\u0026#34;\u0026gt;点我看美女\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn btn-danger\u0026#34; @click=\u0026#34;handleClick\u0026#34;\u0026gt;点我看美女2\u0026lt;/button\u0026gt; 补充一下关于前端各种技术的介绍\n1 2 3 -html：标签 -css：样式（好看） bootstrap是css样式，element-ui -js：动起来 jquery是js框架，vue是js框架，react 在给出函数定义的代码前，先补充一个关于es6语法中对象的写法\n1 2 3 4 5 6 7 es6 语法的对象写法 var obj = {\u0026#39;name\u0026#39;: \u0026#39;lqz\u0026#39;, \u0026#39;age\u0026#39;: 19} var obj1 = {name: \u0026#39;lqz\u0026#39;, age: 19} name = \u0026#39;lqz\u0026#39; age = 19 var onj2 = {name, age} // 等同于{name: \u0026#39;lqz\u0026#39;, age: 19} es6 对象写法 由此函数的定义就可以由方式一简化到方式二\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;#app\u0026#39;, // 变量写在data中 data: { zs:true, }, // 函数写在methods中 methods: { // 方式一：es5的语法 // handleClick: function () { // alert(\u0026#39;美女\u0026#39;) // } // 方式二：常用的es6的语法 handleClick() { alert(\u0026#39;美女\u0026#39;) }, handleShow(){ // 修改show的值为 !show // this代指的是vm对象，Vue对象 this.zs=!this.zs } }, // 函数写在这里 }) \u0026lt;/script\u0026gt; 完整代码及案例\n实现通过一个按钮控制一张图片的显示状态的切换\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;button class=\u0026#34;btn btn-danger\u0026#34; v-on:click=\u0026#34;handleClick\u0026#34;\u0026gt;点我看美女\u0026lt;/button\u0026gt;--\u0026gt; \u0026lt;button class=\u0026#34;btn btn-danger\u0026#34; @click=\u0026#34;handleClick\u0026#34;\u0026gt;点我看美女2\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;!-- 写个按钮，一点击就显示美女图片，再点击一次就不显示了--\u0026gt; \u0026lt;button @click=\u0026#34;handleShow\u0026#34;\u0026gt;看我美女显示和消失\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;!-- \u0026lt;img v-if=\u0026#34;zs\u0026#34; src=\u0026#34;https://tva1.sinaimg.cn/large/00831rSTly1gd1u0jw182j30u00u043b.jpg\u0026#34; alt=\u0026#34;\u0026#34; height=\u0026#34;500px\u0026#34; width=\u0026#34;500px\u0026#34;\u0026gt;--\u0026gt; \u0026lt;img v-show=\u0026#34;zs\u0026#34; src=\u0026#34;https://tva1.sinaimg.cn/large/00831rSTly1gd1u0jw182j30u00u043b.jpg\u0026#34; alt=\u0026#34;\u0026#34; height=\u0026#34;500px\u0026#34; width=\u0026#34;500px\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;#app\u0026#39;, // 变量写在data中 data: { zs:true, }, // 函数写在methods中 methods: { // 方式一：es5的语法 // handleClick: function () { // alert(\u0026#39;美女\u0026#39;) // } // 方式二：常用的，es6的语法 handleClick() { alert(\u0026#39;美女\u0026#39;) }, handleShow(){ // 修改show的值为 !show // this代指的是vm对象，Vue对象 this.zs=!this.zs } }, }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 属性指令 标签会有很多属性，比如\n1 2 3 4 \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; \u0026gt; \u0026lt;p name=\u0026#34;xxx\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;button class=\u0026#34;btn\u0026#34;\u0026gt;点我\u0026lt;/button\u0026gt; v-bind：可以将标签的任意属性动态的绑定为一个变量\n语法：v-bind:属性名=\u0026quot;变量\u0026quot;可以简写为:属性='变量'\n1 2 \u0026lt;img v-bind:src=\u0026#34;url\u0026#34; alt=\u0026#34;\u0026#34; width=\u0026#34;500px\u0026#34; height=\u0026#34;500px\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;url\u0026#34; alt=\u0026#34;\u0026#34; width=\u0026#34;500px\u0026#34; height=\u0026#34;500px\u0026#34;\u0026gt; 案例：点击按钮实现图片的切换（改变img标签的src属性）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;img v-bind:src=\u0026#34;url\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;--\u0026gt; \u0026lt;h1\u0026gt;点我随机弹美女图片\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;handleClick\u0026#34;\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;!-- \u0026lt;img v-bind:src=\u0026#34;url\u0026#34; alt=\u0026#34;\u0026#34; width=\u0026#34;500px\u0026#34; height=\u0026#34;500px\u0026#34;\u0026gt;--\u0026gt; \u0026lt;img :src=\u0026#34;url\u0026#34; alt=\u0026#34;\u0026#34; width=\u0026#34;500px\u0026#34; height=\u0026#34;500px\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { url: \u0026#39;https://tva1.sinaimg.cn/large/00831rSTly1gd1u0jw182j30u00u043b.jpg\u0026#39;, l: [\u0026#39;https://img2.woyaogexing.com/2022/10/13/05e406595e217e0c!400x400.jpg\u0026#39;, \u0026#39;https://img2.woyaogexing.com/2022/10/13/c03408591b068c18!400x400.jpg\u0026#39;, \u0026#39;https://img2.woyaogexing.com/2022/10/13/f810d999375f7f1c!400x400.jpg\u0026#39;] }, methods: { handleClick() { // 随机从生成0--3的数字 this.url = this.l[Math.floor(Math.random()*3)]; } } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; style和class（特殊的属性指令） 属性指令中，style和class属性特殊一点，因此单独拿出来讲，绑定语法与属性指令相同，只是被绑定的内容特殊\nclass属性可以绑定：字符串，数组（常用），对象\n常用数组，因为数组的结构与class属性相似，有多个class属性值，且数组方便实现添加与删除 1 2 3 4 5 6 // 字符串 class_str: \u0026#39;red size\u0026#39;, // 数组 class_list: [\u0026#39;red\u0026#39;, \u0026#39;size\u0026#39;], // 对象 class_obj: {red: true, size: false, back: false}, style 属性可以绑定： 字符串，数组，对象（常用）\n常用对象，因为style属性原本就键值的形式，与对象类型相似 1 2 3 4 5 6 7 8 // 字符串 style_str: \u0026#39;font-size: 50px;background: pink\u0026#39;, // 数组 style_list: [{\u0026#39;font-size\u0026#39;: \u0026#39;50px\u0026#39;}, {\u0026#39;background\u0026#39;: \u0026#39;pink\u0026#39;}, {\u0026#39;color\u0026#39;: \u0026#39;green\u0026#39;}], // 数组写法二，如果是 - 相连的两个单词,当键省略引号时，需要更改为驼峰形式 style_list: [{fontSize: \u0026#39;50px\u0026#39;}, {background: \u0026#39;pink\u0026#39;}, {color: \u0026#39;green\u0026#39;}], // 对象 style_obj: {fontSize: \u0026#39;50px\u0026#39;, background: \u0026#39;pink\u0026#39;, color: \u0026#39;green\u0026#39;}, 案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .red { color: crimson; } .back { background: greenyellow; } .size { font-size: 50px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;class的三种绑定方式\u0026lt;/h1\u0026gt; \u0026lt;!-- \u0026lt;div :class=\u0026#34;class_str\u0026#34;\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;div :class=\u0026#34;class_list\u0026#34;\u0026gt;--\u0026gt; \u0026lt;div :class=\u0026#34;class_obj\u0026#34;\u0026gt; 我是一个div \u0026lt;/div\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;h1\u0026gt;style的三种绑定方式\u0026lt;/h1\u0026gt; \u0026lt;!-- \u0026lt;div style=\u0026#34;font-size: 50px;background: pink;color: green\u0026#34;\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;div :style=\u0026#34;style_str\u0026#34;\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;div :style=\u0026#34;style_list\u0026#34;\u0026gt;--\u0026gt; \u0026lt;div :style=\u0026#34;style_obj\u0026#34;\u0026gt; 我是第二个div \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { // class:字符串，数组(常用，class由多个类组成，数组跟它最搭)，对象 class_str: \u0026#39;red size\u0026#39;, class_list: [\u0026#39;red\u0026#39;, \u0026#39;size\u0026#39;], // 如果咱么向数组末尾最近一个类名，div样式就变了 class_obj: {red: true, size: false, back: false}, // style :字符串，数组，对象 style_str: \u0026#39;font-size: 50px;background: pink\u0026#39;, style_list: [{\u0026#39;font-size\u0026#39;: \u0026#39;50px\u0026#39;}, {\u0026#39;background\u0026#39;: \u0026#39;pink\u0026#39;}, {\u0026#39;color\u0026#39;: \u0026#39;green\u0026#39;}], // style_list: [{fontSize: \u0026#39;50px\u0026#39;}, {background: \u0026#39;pink\u0026#39;}, {color: \u0026#39;green\u0026#39;}], // 跟上面一样，如果是 - 相连的两个单词可以改成驼峰形式 style_obj: {fontSize: \u0026#39;50px\u0026#39;, background: \u0026#39;pink\u0026#39;, color: \u0026#39;green\u0026#39;}, // style 来讲，它用的多 }, methods: {} }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 同样的，在浏览器控制台修改class_list或style_obj的内容可以达到修改View的效果\n条件渲染 也是一个指令：实现符合某个条件，就显示某个标签\n和python中的条件语句相似，在python中时if，elif，else\n而在vue中是v-if，v-else-if，v-else\n案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p v-if=\u0026#34;score\u0026gt;90\u0026#34;\u0026gt;优秀\u0026lt;/p\u0026gt; \u0026lt;p v-else-if=\u0026#34;score\u0026gt;70 \u0026amp;\u0026amp; score\u0026lt;=90\u0026#34;\u0026gt;良好\u0026lt;/p\u0026gt; \u0026lt;p v-else-if=\u0026#34;score\u0026gt;60 \u0026amp;\u0026amp; score\u0026lt;=70\u0026#34;\u0026gt;及格\u0026lt;/p\u0026gt; \u0026lt;p v-else\u0026gt;不及格\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { score: 98, }, }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 列表渲染 也是一个指令：实现循环渲染，相当于python中的for循环\nv-for指令\n可以循环数组 v-for=\u0026quot;(url,index) in urls\u0026quot; 第一个变量得到的是值，第二个变量得到其下标 可以循环对象 v-for=\u0026quot;(value,key) in obj\u0026quot; 第一个变量得到value，第二个变量key， 如果只用一个变量接收，则是value 可也循环数字 v-for=\u0026ldquo;i in num\u0026rdquo; 从1开始，循环到数字本身 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;把所有美女，一行行显示在页面中\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!-- \u0026lt;li v-for=\u0026#34;url in urls\u0026#34;\u0026gt;--\u0026gt; \u0026lt;li v-for=\u0026#34;(url,index) in urls\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;第{{index + 1}}张美女\u0026lt;/h3\u0026gt; \u0026lt;img :src=\u0026#34;url\u0026#34; alt=\u0026#34;\u0026#34; height=\u0026#34;100px\u0026#34; width=\u0026#34;100px\u0026#34;\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h1\u0026gt;循环对象\u0026lt;/h1\u0026gt; \u0026lt;!-- \u0026lt;p v-for=\u0026#34;(value,key) in obj\u0026#34;\u0026gt;key值为：{{key}},value值为：{{value}}\u0026lt;/p\u0026gt;--\u0026gt; \u0026lt;p v-for=\u0026#34;value in obj\u0026#34;\u0026gt;value值为：{{value}}\u0026lt;/p\u0026gt; \u0026lt;h1\u0026gt;循环数字\u0026lt;/h1\u0026gt; \u0026lt;p v-for=\u0026#34;i in num\u0026#34;\u0026gt;循环到了第：{{i}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { urls: [\u0026#39;https://img2.woyaogexing.com/2022/10/13/05e406595e217e0c!400x400.jpg\u0026#39;, \u0026#39;https://img2.woyaogexing.com/2022/10/13/c03408591b068c18!400x400.jpg\u0026#39;, \u0026#39;https://img2.woyaogexing.com/2022/10/13/f810d999375f7f1c!400x400.jpg\u0026#39;], obj: {name: \u0026#39;lqz\u0026#39;, age: 19, bobby: \u0026#39;篮球\u0026#39;} , // hash类型 hashmap map 字典 对象 都是没有顺序 num:4 }, }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 页面效果\n使用v-if和v-for写个购物车显示与不显示的案例\n补充：\n== 比较值是否一样 === 比较类型和值是否一样\nv-if判断购物车是否为空，非空显示数据，为空显示文字说明\nv-for在表格内循环生成商品内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container-fluid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-6 col-md-offset-3\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;!good_list.length==0\u0026#34;\u0026gt; \u0026lt;table class=\u0026#34;table table-striped table-bordered\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;商品id号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;商品名字\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;商品价格\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;商品数量\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;good in good_list\u0026#34;\u0026gt; \u0026lt;th scope=\u0026#34;row\u0026#34;\u0026gt;{{good.id}}\u0026lt;/th\u0026gt; \u0026lt;td\u0026gt;{{good.name}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{good.price}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{good.num}}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt; 空空如也 \u0026lt;/div\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;button @click=\u0026#34;handleClick\u0026#34;\u0026gt;点我刷新购物车\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { good_list: [] }, methods: { handleClick() { // 跟后端交互，拿到了数据 this.good_list = [ {id: 1, name: \u0026#39;小汽车\u0026#39;, price: 100000, num: 1}, {id: 2, name: \u0026#39;钢笔\u0026#39;, price: 6, num: 10}, {id: 3, name: \u0026#39;脸盆\u0026#39;, price: 12, num: 6}, {id: 4, name: \u0026#39;水杯\u0026#39;, price: 66, num: 5}, ] } } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 数据的双向绑定 v-model指令，主要针对input标签，其他标签一般不用\ninput标签有多种类型，如text，password，select\n我们先来讲text类型的input框的数据双向绑定\n当我们使用:value='变量'时，是单向的数据绑定，即页面变化时，变量不会跟着变化。因此一般不用它\n要实现数据的双向绑定，就需要使用v-model='变量'\n1 \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;v\u0026#34;\u0026gt; 案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;v-model 只针对于input\u0026lt;/h1\u0026gt; 请输入内容：\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;v\u0026#34;\u0026gt; ----\u0026gt;{{v}} \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { v: \u0026#39;美女\u0026#39; }, }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 事件处理 常见事件 常见的事件有click点击事件，dbclick双击事件，blur失去焦点，input内容变化触发，change内容发生变化，且失去焦点触发\n在input标签中主要是blur，input，change这三个事件\n下面是一个案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;失去焦点事件blur\u0026lt;/h1\u0026gt; \u0026lt;!-- 请输入名字：\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;name\u0026#34; @blur=\u0026#34;handleBlur\u0026#34;\u0026gt;--\u0026gt; \u0026lt;h1\u0026gt;change事件：数据发生变化才会触发\u0026lt;/h1\u0026gt; \u0026lt;!-- 请输入名字：\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;name\u0026#34; @change=\u0026#34;handleChange\u0026#34;\u0026gt;--\u0026gt; \u0026lt;h1\u0026gt;input事件：只要输入内容会触发\u0026lt;/h1\u0026gt; 请输入名字：\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;name\u0026#34; @input=\u0026#34;handleInput\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { name: \u0026#39;彭于晏\u0026#39; }, methods: { handleBlur() { alert(this.name) }, handleChange() { console.log(this.name) // 跟python中print一样 }, handleInput(){ console.log(this.name) } } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 过滤案例 补充1：数组的内置方法filter,传匿名函数进去，循环数组元素传入匿名函数，如果返回true就保留该元素，如果返回false，就不保留\n1 2 3 4 5 6 7 // 补充：数组的内置方法，filter,传匿名函数进去，匿名函数如果返回true这个就保留，如果返回false，就不保留 var l = [\u0026#39;a\u0026#39;, \u0026#39;at\u0026#39;, \u0026#39;atom\u0026#39;, \u0026#39;atommon\u0026#39;, \u0026#39;be\u0026#39;, \u0026#39;beyond\u0026#39;, \u0026#39;cs\u0026#39;, \u0026#39;csrf\u0026#39;, \u0026#39;csrffe\u0026#39;] var ll = l.filter(function (item) { return 条件判断 }) console.log(ll) 补充2：字符串的indexOf方法，返回子字符串出现的索引位置，如果大于-1，表示子字符串在当前字符串中\n1 2 3 var s=\u0026#39;lqz is handsome\u0026#39; var res=s.indexOf(\u0026#39;lqz\u0026#39;) // 如果lzq在字符串中，就返回lzq在字符串的索引位置，即0 console.log(res) 将两个知识点结合起来，就可以实现筛选出包含搜索值的数组元素\n1 2 3 4 5 6 var search = \u0026#39;a\u0026#39; var l = [\u0026#39;a\u0026#39;, \u0026#39;at\u0026#39;, \u0026#39;atom\u0026#39;, \u0026#39;atommon\u0026#39;, \u0026#39;be\u0026#39;, \u0026#39;beyond\u0026#39;, \u0026#39;cs\u0026#39;, \u0026#39;csrf\u0026#39;, \u0026#39;csrffe\u0026#39;] var ll = l.filter(function (item) { return item.indexOf(search) \u0026gt; -1 }) console.log(ll) 补充3：this指向问题\n1 2 3 4 5 6 7 8 9 10 11 12 methods: { handleInput() { // this 指向问题 // 这个位置this是vue对象 var _this = this this.dataList = this.dataList.filter(function (item) { // 这个匿名函数内的this 还是vue对象吗？其实是浏览器对象，所以我们得定义一个_this，在匿名函数内使用_this而不是this console.log(\u0026#39;----\u0026#39;, _this) return item.indexOf(_this.search) \u0026gt; -1 }) } } 补充4：箭头函数：没有自己的this，内部的this依然指向vue对象\n1 2 3 4 5 6 7 8 9 10 // 传统写法 var a=function (name,age){ console.log(name) } a(\u0026#34;lxx\u0026#34;) //es6 箭头函数 匿名函数的另一种写法 var a= (name,age) =\u0026gt;{ console.log(name) } 因此用箭头函数就可以解决this指向的问题，简化代码\n1 2 3 4 // 使用es6的语法解决 this.newdataList = this.dataList.filter(item =\u0026gt; { return item.indexOf(this.search) \u0026gt; -1 }) 还有一个小问题，当我们对datalist做过滤时，datalist会产生永久性改变，下次input框内容变化后，也是在上一次过滤后的datalist的基础上做过滤，即datalist会越过滤越小，显示的值会越来越少，当输入框回退输入值时，筛选的值不会回退。\n因此需要拷贝一个newdatalist，保持datalist不变，每次筛选都基于datalist生成newdatalist，然后循环newdatalist展示数据\n案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;过滤案例\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;search\u0026#34; @input=\u0026#34;handleInput\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in newdataList\u0026#34;\u0026gt;{{item}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { search: \u0026#39;\u0026#39;, dataList: [\u0026#39;a\u0026#39;, \u0026#39;at\u0026#39;, \u0026#39;atom\u0026#39;, \u0026#39;atommon\u0026#39;, \u0026#39;be\u0026#39;, \u0026#39;beyond\u0026#39;, \u0026#39;cs\u0026#39;, \u0026#39;csrf\u0026#39;, \u0026#39;csrffe\u0026#39;], newdataList: [\u0026#39;a\u0026#39;, \u0026#39;at\u0026#39;, \u0026#39;atom\u0026#39;, \u0026#39;atommon\u0026#39;, \u0026#39;be\u0026#39;, \u0026#39;beyond\u0026#39;, \u0026#39;cs\u0026#39;, \u0026#39;csrf\u0026#39;, \u0026#39;csrffe\u0026#39;] }, methods: { handleInput() { // this 指向问题 // 这个位置this是vue对象 // var _this = this // this.dataList = this.dataList.filter(function (item) { // console.log(\u0026#39;----\u0026#39;, _this) // this 还是vue对象吗？是浏览器对象 // return item.indexOf(_this.search) \u0026gt; -1 // }) // 使用es6的语法解决 this.newdataList = this.dataList.filter(item =\u0026gt; { // console.log(\u0026#39;----\u0026#39;, this) // 如果使用剪头函数，this还是vue（剪头函数没有自己的this） return item.indexOf(this.search) \u0026gt; -1 }) } } }) // 补充：数组的内置方法，filter,传匿名函数进去，匿名函数如果返回true这个就保留，如果返回false，就不保留 // var search = \u0026#39;a\u0026#39; // var l = [\u0026#39;a\u0026#39;, \u0026#39;at\u0026#39;, \u0026#39;atom\u0026#39;, \u0026#39;atommon\u0026#39;, \u0026#39;be\u0026#39;, \u0026#39;beyond\u0026#39;, \u0026#39;cs\u0026#39;, \u0026#39;csrf\u0026#39;, \u0026#39;csrffe\u0026#39;] // var ll = l.filter(function (item) { // return item.indexOf(search) \u0026gt; -1 // }) // console.log(ll) // 补充：字符串有个indexOf，返回索引，如果大于-1，表示字字符串在当前字符串中 // var s=\u0026#39;lqz is handsome\u0026#39; // var res=s.indexOf(\u0026#39;zoo\u0026#39;) // 如果me在字符串中，就返回me在字符串的索引位置 // console.log(res) // es6 的箭头函数 // 传统写法 // var a=function (name,age){ // console.log(name) // } // a(\u0026#34;lxx\u0026#34;) // //es6 箭头函数 匿名函数的另一种写法 // var a= (name,age) =\u0026gt;{ // console.log(name) // } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 事件修饰符 放在事件后的，修饰事件的，例如\n@click.once='函数'修饰点击事件只能被触发一次\n都有哪些常用的时间修饰符呢？\n.stop\t只处理自己的事件，不再冒泡给父标签（阻止事件冒泡） .self\t只处理自己的事件，子控件冒泡的事件不处理 .prevent\t阻止a链接的跳转 .once\t事件只会触发一次（适用于抽奖页面） 案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;点击子标签，父标签的事件也触发：事件冒泡\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;阻止事件冒泡：点子标签，父标签不触发 stop\u0026lt;/h2\u0026gt; \u0026lt;ul @click=\u0026#34;handleUl\u0026#34;\u0026gt; \u0026lt;li @click.stop=\u0026#34;handleLi\u0026#34;\u0026gt;点我看美女\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;点我看帅哥\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h1\u0026gt;点击子标签，父标签的事件也触发：事件冒泡\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;子标签的冒泡不处理：父标签写self，父标签只处理自己的事件，冒泡的事件不管\u0026lt;/h2\u0026gt; \u0026lt;ul @click.self=\u0026#34;handleUl\u0026#34;\u0026gt; \u0026lt;li @click=\u0026#34;handleLi\u0026#34;\u0026gt;点我看美女\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;点我看帅哥\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h1\u0026gt;prevent 阻止a链接的跳转\u0026lt;/h1\u0026gt; \u0026lt;a href=\u0026#34;http://www.liuqingzheng.top\u0026#34; @click.prevent=\u0026#34;handleA\u0026#34;\u0026gt;点我看美女\u0026lt;/a\u0026gt; \u0026lt;h1\u0026gt;once 只执行一次\u0026lt;/h1\u0026gt; \u0026lt;button @click.once=\u0026#34;handleButton\u0026#34;\u0026gt;点我秒杀\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: {}, methods: { handleLi() { console.log(\u0026#34;li被点击了\u0026#34;) }, handleUl() { console.log(\u0026#34;ul被点击了\u0026#34;) }, handleA() { console.log(\u0026#39;a被点击了,不会再跳转了\u0026#39;) }, handleButton() { alert(\u0026#39;秒杀成功\u0026#39;) } } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 按键修饰符 输入框除了上面提到的常用事件外，还有一个按键被按下和被抬起触发的事件\nkeydown：按键按下时触发 keyup：按键释放时触发（常用） keypress：按下字符键时触发（不支持功能键） 可以使用@keyup=\u0026quot;函数\u0026quot;绑定函数，再在函数中通过code判断被按下的按键\n1 2 3 4 5 handleKeyUp(event){ if(event.code==\u0026#39;Enter\u0026#39;) { console.log(\u0026#39;enter键被抬起了，开始搜索\u0026#39;) } } 同时对于常用的一些键，他给我们提供了对应的写法，如回车键\n1 \u0026lt;input type=\u0026#34;text\u0026#34; @keyup.enter=\u0026#34;函数\u0026#34;\u0026gt; 这样就不需要在函数中判断被触发的按键是不是回车，因为只有被按下的是回车键才会触发该函数\n函数中可以用$event来接收被按下的按键\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;按键修饰符\u0026lt;/h1\u0026gt; \u0026lt;!-- \u0026lt;input type=\u0026#34;text\u0026#34; c\u0026gt;--\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; @keyup.enter=\u0026#34;handleKeyUp($event)\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; @keyup.esc=\u0026#34;handleKeyUp($event)\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; @keyup.=\u0026#34;handleKeyUp($event)\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: {}, methods: { handleKeyUp(event) { console.log(\u0026#39;sdasfd\u0026#39;) if (event.code == \u0026#39;Enter\u0026#39;) { console.log(\u0026#39;enter键被抬起了，开始搜索\u0026#39;) } } } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; checkbox和radio的双向绑定 text类型的input标签实现数据绑定我们已经学过了，在表单中input标签还有checkbox和radio类型，要实现他们的双向数据绑定，下面我们来看看如何实现\ncheckbox的单选\t用v-model绑定一个布尔值\t只要选中布尔就为true，反之亦然\nradio的单选\tv-model绑定字符串\t选中字符串就是value对应的值\ncheckbox的多选\tv-model绑定一个数组\t多个选中，数组就有多个值\n这样实现表单数据的双向绑定后，只需要给登录按钮绑定一个点击事件，用ajax将数据传给后端即可\n案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;表单控制之checkbox单选\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;用户名：\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;密码：\u0026lt;input type=\u0026#34;password\u0026#34; v-model=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;isCheck\u0026#34;\u0026gt;记住密码\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; v-model=\u0026#34;gender\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt;男 \u0026lt;input type=\u0026#34;radio\u0026#34; v-model=\u0026#34;gender\u0026#34; value=\u0026#34;2\u0026#34;\u0026gt;女 \u0026lt;input type=\u0026#34;radio\u0026#34; v-model=\u0026#34;gender\u0026#34; value=\u0026#34;0\u0026#34;\u0026gt;未知 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;爱好(多选)：\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;hobby\u0026#34; value=\u0026#34;篮球\u0026#34;\u0026gt; 篮球 \u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;hobby\u0026#34; value=\u0026#34;足球\u0026#34;\u0026gt; 足球 \u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;hobby\u0026#34; value=\u0026#34;橄榄球\u0026#34;\u0026gt; 橄榄球 \u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;hobby\u0026#34; value=\u0026#34;乒乓球\u0026#34;\u0026gt; 乒乓球 \u0026lt;/p\u0026gt; \u0026lt;!-- \u0026lt;hr\u0026gt;--\u0026gt; \u0026lt;!-- 密码是否选中：{{isCheck}}--\u0026gt; \u0026lt;!-- \u0026lt;hr\u0026gt;--\u0026gt; \u0026lt;!-- 性别是：{{gender}}--\u0026gt; \u0026lt;!-- \u0026lt;hr\u0026gt;--\u0026gt; \u0026lt;!-- 爱好是：{{hobby}}--\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34; @click=\u0026#34;handleSubmit\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;.app\u0026#39;, data: { username: \u0026#39;\u0026#39;, password: \u0026#39;\u0026#39;, isCheck: false, gender: \u0026#39;\u0026#39;, hobby:[], }, methods: { handleSubmit(){ //假设发送ajax到后端了 console.log(this.username) console.log(this.password) console.log(this.isCheck) console.log(this.gender) console.log(this.hobby) } }, }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 购物车案例 js的循环方式 python，js，go，java for循环的区别\n1 2 3 4 5 6 7 8 9 10 11 12 -python中for循环只有基于迭代的循环，没有基于索引的循环 for xx in 可迭代对象 # 基于迭代 -js ： for xx in 对象 # 基于迭代 for i=0;i\u0026lt;10;i++ # 基于索引 -go： for i=0;i\u0026lt;10;i++ # 基于索引 for item range 变量 # 基于迭代 -java： for i=0;i\u0026lt;10;i++ # 基于索引 1.8之前只有这种 for xx in 对象 # 基于迭代 1.8后的语法 下面来看看js中常见的for循环\n最基本的 1 2 3 for (let i=0; i\u0026lt;3; i++) { console.log(i) } in 循环 es5的语法 1 2 for(let 成员 in 对象){ 循环的代码块 of es6的循环 1 2 3 for(item of arr){ console.log(\u0026#39;item =\u0026gt;\u0026#39;, item) } 数组foreach循环 (数组) 1 2 3 4 5 var a=[33,22,888] a.forEach(function (value,index){ console.log(value) console.log(index) }) jq $each 循环 1 2 3 4 5 6 7 8 9 $.each(可迭代对象,function (key,value) { }); // var a=[33,22,888] var obj={name:\u0026#39;lqz\u0026#39;,age:19} $.each(a,function (key,value){ console.log(key) console.log(value) }) 对于对象是key，value\n对于数组是index，value\n基本购物车 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;http://code.jquery.com/jquery-2.1.1.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container-fluid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-6 col-md-offset-3\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;margin-top: 30px\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;购物车案例\u0026lt;/h1\u0026gt; \u0026lt;table class=\u0026#34;table table-bordered\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;商品id\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;商品名字\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;商品价格\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;商品数量\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;good in goodList\u0026#34;\u0026gt; \u0026lt;th\u0026gt;{{good.id}}\u0026lt;/th\u0026gt; \u0026lt;td\u0026gt;{{good.name}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{good.price}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{good.count}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;buyGoods\u0026#34; :value=\u0026#34;good\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;hr\u0026gt; 选中的商品:{{buyGoods}} \u0026lt;hr\u0026gt; 总价格是：{{getPrice()}} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;.app\u0026#39;, data: { goodList: [ {id: \u0026#39;1\u0026#39;, name: \u0026#39;小汽车\u0026#39;, price: 150000, count: 2}, {id: \u0026#39;2\u0026#39;, name: \u0026#39;鸡蛋\u0026#39;, price: 2, count: 1}, {id: \u0026#39;3\u0026#39;, name: \u0026#39;饼干\u0026#39;, price: 10, count: 6}, {id: \u0026#39;4\u0026#39;, name: \u0026#39;钢笔\u0026#39;, price: 15, count: 5}, {id: \u0026#39;5\u0026#39;, name: \u0026#39;脸盆\u0026#39;, price: 30, count: 3}, ], buyGoods: [], }, methods: { getPrice() { var total = 0 // 方式一：数组的循环：循环计算选中的商品价格 // this.buyGoods.forEach(function (v,i){ // total+=v.price*v.count // }) // 方式二：es6 的 of 循环 for (item of this.buyGoods) { // console.log(item) total += item.price * item.count } return total } } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 带全选，全不选 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container-fluid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-6 col-md-offset-3\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;margin-top: 30px\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;购物车案例\u0026lt;/h1\u0026gt; \u0026lt;table class=\u0026#34;table table-bordered\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;商品id\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;商品名字\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;商品价格\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;商品数量\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;checkAll\u0026#34; @change=\u0026#34;handleCheckAll\u0026#34;\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;good in goodList\u0026#34;\u0026gt; \u0026lt;th\u0026gt;{{good.id}}\u0026lt;/th\u0026gt; \u0026lt;td\u0026gt;{{good.name}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{good.price}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{good.count}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;buyGoods\u0026#34; :value=\u0026#34;good\u0026#34; @change=\u0026#34;handleCheckOne\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;hr\u0026gt; 选中的商品:{{buyGoods}} \u0026lt;hr\u0026gt; 总价格是：{{getPrice()}} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;.app\u0026#39;, data: { goodList: [ {id: \u0026#39;1\u0026#39;, name: \u0026#39;小汽车\u0026#39;, price: 150000, count: 2}, {id: \u0026#39;2\u0026#39;, name: \u0026#39;鸡蛋\u0026#39;, price: 2, count: 1}, {id: \u0026#39;3\u0026#39;, name: \u0026#39;饼干\u0026#39;, price: 10, count: 6}, {id: \u0026#39;4\u0026#39;, name: \u0026#39;钢笔\u0026#39;, price: 15, count: 5}, {id: \u0026#39;5\u0026#39;, name: \u0026#39;脸盆\u0026#39;, price: 30, count: 3}, ], buyGoods: [], checkAll: false, }, methods: { getPrice() { var total = 0 for (item of this.buyGoods) { // console.log(item) total += item.price * item.count } return total }, handleCheckAll() { if (this.checkAll) { // 用户全选了，只需要把 buyGoods的值变为goodList this.buyGoods = this.goodList } else { this.buyGoods = [] } }, handleCheckOne() { // 判断buyGoods长度，是否等于goodList，如果等于说明用户全选了，把checkAll设置为true // 否则设置为false // if(this.buyGoods.length==this.goodList.length){ // // 说明用户通过单选，选全了 // this.checkAll=true // }else { // this.checkAll=false // } // 简写成 this.checkAll = (this.buyGoods.length == this.goodList.length) } } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 带加减 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container-fluid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-6 col-md-offset-3\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;margin-top: 30px\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;购物车案例\u0026lt;/h1\u0026gt; \u0026lt;table class=\u0026#34;table table-bordered\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;商品id\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;商品名字\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;商品价格\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;商品数量\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;checkAll\u0026#34; @change=\u0026#34;handleCheckAll\u0026#34;\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;good in goodList\u0026#34;\u0026gt; \u0026lt;th\u0026gt;{{good.id}}\u0026lt;/th\u0026gt; \u0026lt;td\u0026gt;{{good.name}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{good.price}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;button @click=\u0026#34;handleJian(good)\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; {{good.count}} \u0026lt;button @click=\u0026#34;good.count++\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;buyGoods\u0026#34; :value=\u0026#34;good\u0026#34; @change=\u0026#34;handleCheckOne\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;hr\u0026gt; 选中的商品:{{buyGoods}} \u0026lt;hr\u0026gt; 总价格是：{{getPrice()}} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;.app\u0026#39;, data: { goodList: [ {id: \u0026#39;1\u0026#39;, name: \u0026#39;小汽车\u0026#39;, price: 150000, count: 2}, {id: \u0026#39;2\u0026#39;, name: \u0026#39;鸡蛋\u0026#39;, price: 2, count: 1}, {id: \u0026#39;3\u0026#39;, name: \u0026#39;饼干\u0026#39;, price: 10, count: 6}, {id: \u0026#39;4\u0026#39;, name: \u0026#39;钢笔\u0026#39;, price: 15, count: 5}, {id: \u0026#39;5\u0026#39;, name: \u0026#39;脸盆\u0026#39;, price: 30, count: 3}, ], buyGoods: [], checkAll: false, }, methods: { getPrice() { var total = 0 for (item of this.buyGoods) { // console.log(item) total += item.price * item.count } return total }, handleCheckAll() { if (this.checkAll) { // 用户全选了，只需要把 buyGoods的值变为goodList this.buyGoods = this.goodList } else { this.buyGoods = [] } }, handleCheckOne() { // 判断buyGoods长度，是否等于goodList，如果等于说明用户全选了，把checkAll设置为true // 否则设置为false // if(this.buyGoods.length==this.goodList.length){ // // 说明用户通过单选，选全了 // this.checkAll=true // }else { // this.checkAll=false // } // 简写成 this.checkAll = (this.buyGoods.length == this.goodList.length) }, handleJian(item) { if (item.count \u0026lt;= 1) { alert(\u0026#39;太少了，受不了了\u0026#39;) } else { item.count-- } } } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; v-model进阶 我们来学习几个v-model的进阶操作\nlazy：双向数据绑定，只要修改输入框的值，就更新数据，耗费资源，加了lazy后，等输入动作结束后，变量再变化\nnumber：输入框，只接收数字部分，如果输入了 123asdfasd，只保留123 数字部分。但如果输入的是adbawjd112，就不会做任何操作\ntrim： 去掉输入内容前后的空白\n语法：v-model.lazy='变量'\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;v-model进阶\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; v-model.lazy=\u0026#34;a\u0026#34;\u0026gt;{{a}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; v-model.number=\u0026#34;b\u0026#34;\u0026gt;{{b}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; v-model.trim=\u0026#34;c\u0026#34;\u0026gt;{{c}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;.app\u0026#39;, data: { a: \u0026#39;\u0026#39;, b: \u0026#39;\u0026#39;, c: \u0026#39;\u0026#39;, }, }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; Vue生命周期 vue的实例：vm，以及后面学的组件：vc 它们有生命周期\n从创建开始，到销毁，总共有8个钩子函数(4对)，依次调用\n什么是钩子函数？\n主流编程思想\n1 2 3 4 5 面向过程编程 OOP编程：面向对象编程 AOP编程：面向切面编程（对面向对象编程的补充），java的spring框架大量的使用 -python中装饰器 AOP编程的体现 -drf源码，反序列化的源码，钩子函数，aop体现 而钩子就体现了aop编程的思想\n下面我们来介绍Vue的八个钩子函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 beforeCreate\t创建Vue实例，组件实例对象创建 之前调用 created\t创建Vue实例成功后调用（常用，可以在此处发送ajax请求后端数据） beforeMount\t渲染DOM之前调用 mounted\t渲染DOM之后调用 ---初始化完成了---- beforeUpdate\t重新渲染之前调用（数据更新等操作时，控制DOM重新渲染） updated\t重新渲染完成之后调用 ---一直循环调用这两个钩子---- ----销毁组件--- beforeDestroy\t销毁之前调用 destroyed\t销毁之后调用 案例：\n我们选择用观看组件的生命周期，因为vm实例的生命周期，在销毁时页面已经关闭，为了完整的看到Vue的生命周期，我们选择组件，它可以自由的创建和销毁\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;handleShow\u0026#34;\u0026gt;点我，组件显示和消失\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;lqz v-if=\u0026#34;show\u0026#34;\u0026gt;\u0026lt;/lqz\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; // 定义一个组件 `` es6语法的模版字符串 `lqz is ${变量}` Vue.component(\u0026#39;lqz\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;我是一个好看的组件{{ name }}\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;handleClick\u0026#34;\u0026gt;点我看美女\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;`, data() { return { name: \u0026#39;彭于晏\u0026#39;, t: \u0026#39;\u0026#39;, } }, methods: { handleClick() { this.name = \u0026#39;lqz\u0026#39; } }, beforeCreate() { console.log(\u0026#39;beforeCreate\u0026#39;) console.log(this.$data) // 数据部分 console.log(this.$el) // 模版 }, created() { console.log(\u0026#39;created\u0026#39;) console.log(this.$data) // 数据部分 console.log(this.$el) // 模版 // 启动一个定时器（实时前后端通信，web微信，开启了定时器一直在向后端发请求拿数据） this.t = setInterval(function () { console.log(\u0026#39;hello world\u0026#39;) }, 3000) // 过一段时间就执行，一直执行 // setTimeout() //延迟调用，执行一次 }, beforeMount() { console.log(\u0026#39;beforeMount\u0026#39;) console.log(\u0026#39;当前el状态：\u0026#39;, this.$el) console.log(\u0026#39;当前data状态：\u0026#39;, this.$data) }, mounted() { console.log(\u0026#39;mounted\u0026#39;) console.log(\u0026#39;当前el状态：\u0026#39;, this.$el) console.log(\u0026#39;当前data状态：\u0026#39;, this.$data) }, beforeUpdate() { console.log(\u0026#39;beforeUpdate\u0026#39;) console.log(\u0026#39;当前el状态：\u0026#39;, this.$el) console.log(\u0026#39;当前data状态：\u0026#39;, this.$data) }, updated() { console.log(\u0026#39;updated\u0026#39;) console.log(\u0026#39;当前el状态：\u0026#39;, this.$el) console.log(\u0026#39;当前data状态：\u0026#39;, this.$data) }, beforeDestroy() { console.log(\u0026#39;beforeDestroy\u0026#39;) console.log(\u0026#39;当前el状态：\u0026#39;, this.$el) console.log(\u0026#39;当前data状态：\u0026#39;, this.$data) }, destroyed() { console.log(\u0026#39;destroyed\u0026#39;) console.log(\u0026#39;当前el状态：\u0026#39;, this.$el) console.log(\u0026#39;当前data状态：\u0026#39;, this.$data) // 释放掉定时器 clearInterval(this.t) this.t = null }, } ) var vm = new Vue({ el: \u0026#39;.app\u0026#39;, data: { show: true }, methods: { handleShow() { this.show = !this.show } }, }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 总结：\n比较常用的几个钩子\ncreated：此时data的数据完成了初始化，在这里发送ajax请求去后端请求数据 updated：每次数据变化，页面更新完后，都会执行它 destroyed：组件销毁，会触发它，用于完成资源清理工作，例如关闭组件中启用的定时器等等 不管是vm实例还是组件实例，都有8个生命周期钩子函数，写了钩子函数，就会执行，不写就不会执行\n与后端交互(ajax,fetch和axios) 跨域问题： 前后端分离的项目会出现\n浏览器有个安全策略：不允许向不同域(地址+端口号)发送请求获取数据，这个安全策略叫做浏览器的同源策略 如何解决跨域问题？\n后端的cors(跨域资源共享)技术：就是在响应头中加入允许即可\nnginx做代理\n前后端数据交互主要有三种方式\n原生js发送ajax请求，jq发送ajax请求，fetch发送ajax请求，axios发送ajax请求\n原生：new XMLHttpRequest() 老api，坑很多\njq基于它封装，封装出了$.ajax ,屏蔽了很多问题\n官方觉得XMLHttpRequest坑很多，搞了个fetch，跟XMLHttpRequest是平级的，比它好用，但是不支持ie\naxios继续基于XMLHttpRequest封装了一个发送ajax请求的模块\n原生的和fetch是官方提供的，不需要导入，而jq和axios是第三方的框架或者模块，需要导入\n方式一：使用jq的ajax方法 原生js写ajax，jq帮咱们写好了，处理好了浏览器版本间的不兼容，可以直接用\n1 2 3 4 5 6 7 8 9 $.ajax({ url: \u0026#39;http://127.0.0.1:8000/test/\u0026#39;, type: \u0026#39;get\u0026#39;, success: data =\u0026gt; { // 后端返回json格式字符串，$.ajax拿到字符串，转成了js的对象，给了data this.name = data.name this.age = data.age } }) 方式二：使用fetch 解释一个关于es6箭头函数的小知识\n如果函数体内只有一行代码，可以省略return和{}\n1 2 3 4 5 var a = function (data) { return data + \u0026#39;lqz\u0026#39; } var a = data =\u0026gt; data + \u0026#39;lqz\u0026#39; 1 2 3 4 5 fetch(\u0026#39;http://127.0.0.1:8000/test/\u0026#39;).then(res =\u0026gt; res.json()).then(res =\u0026gt; { console.log(res) this.name = res.name this.age = res.age }) 方式三：使用第三方，axios(js模块，需要导入) 1 2 3 4 5 6 7 8 \u0026lt;script src=\u0026#34;https://unpkg.com/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; axios.get(\u0026#39;http://127.0.0.1:8000/test/\u0026#39;).then(res=\u0026gt;{ console.log(res.data) // 真正后端给的数据封装在res.data中 this.name = res.data.name this.age=res.data.age }) 从后端加载数据，显示电影的小案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;film in filmsList\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;电影标题：{{film.name}}\u0026lt;/h3\u0026gt; \u0026lt;img :src=\u0026#34;film.poster\u0026#34; alt=\u0026#34;\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;400px\u0026#34;\u0026gt; \u0026lt;p\u0026gt;简介：{{film.synopsis}}\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;.app\u0026#39;, data: { filmsList: [] }, methods: {}, created() { axios.get(\u0026#39;http://127.0.0.1:8000/films/\u0026#39;).then(res =\u0026gt; { this.filmsList = res.data.data.films }) } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 计算属性 1 2 3 4 5 computed: { 函数名(){ return XXX } } 将函数写在computed中\n特点：\n可以将函数当属性使用\n只有关联的数据发生变化，才会重新执行函数运算结果\n支持缓存，当数据未发生变化时，页面更新，他也不会变化\n案例：有个input，输入英文后，把首字母变成大写\n如果不采用计算属性，而是选择直接在插值语法中插入表达式或者函数，当页面其他部分发生变化，该数据也会重新计算，比较耗费资源\n采用计算属性，就相当于将函数当变量用，只有该函数相关的变量发生变化，才会重新计算函数，修改变量。切记该函数一定要return值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;计算属性\u0026lt;/h1\u0026gt; \u0026lt;!-- 最简单方式--\u0026gt; \u0026lt;h2\u0026gt;最简单方法首字母变大写\u0026lt;/h2\u0026gt; \u0026lt;!-- \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;name\u0026#34;\u0026gt;-\u0026amp;ndash;\u0026amp;gt;{{name.slice(0, 1).toUpperCase() + name.slice(1)}}--\u0026gt; \u0026lt;h2\u0026gt;使用函数实现，页面只要更新，这个函数就会重新执行,比较耗费资源\u0026lt;/h2\u0026gt; \u0026lt;!-- \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;name\u0026#34;\u0026gt;-\u0026amp;ndash;\u0026amp;gt;{{getUpper()}}--\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;age\u0026#34;\u0026gt;---\u0026gt;{{age}} \u0026lt;h3\u0026gt;通过计算属性实现：计算属性只有在它的相关依赖发生改变时才会重新求值\u0026lt;/h3\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;name\u0026#34;\u0026gt;---\u0026gt;{{upperName}} \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;.app\u0026#39;, data: { name: \u0026#39;\u0026#39;, age: 0 }, methods: { getUpper() { console.log(\u0026#39;我执行了\u0026#39;) return this.name.slice(0, 1).toUpperCase() + this.name.slice(1) } }, computed: { upperName() { console.log(\u0026#39;我是计算属性，我执行了\u0026#39;) return this.name.slice(0, 1).toUpperCase() + this.name.slice(1) } } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 案例2：通过计算属性重写过滤案例\n只要input框中search数据发生变化，newdataList会重新运算，只要一运算，v-for重新循环，就会显示新的过滤结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;过滤案例\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;search\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in newdataList\u0026#34;\u0026gt;{{item}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;#app\u0026#39;, data: { search: \u0026#39;\u0026#39;, dataList: [\u0026#39;a\u0026#39;, \u0026#39;at\u0026#39;, \u0026#39;atom\u0026#39;, \u0026#39;atommon\u0026#39;, \u0026#39;be\u0026#39;, \u0026#39;beyond\u0026#39;, \u0026#39;cs\u0026#39;, \u0026#39;csrf\u0026#39;, \u0026#39;csrffe\u0026#39;], }, // 只要input框中数据发生变化search，newdataList会重新运算，只要一运算，v-for重新循环，实现了联动 computed: { newdataList() { return this.dataList.filter(item =\u0026gt; { return item.indexOf(this.search) \u0026gt; -1 }) } } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 监听属性 监听categoryType变量，只要发生变化，执行对应的函数\n1 2 3 4 5 6 watch: { categoryType: function (val) { console.log(\u0026#39;name发生了变化\u0026#39;) console.log(val) } } 应用场景：前端有分类标签按钮，点击向后端发送请求，请求回相应分类的数据，展示\n如果不使用监听属性，需要给每一个标签绑定一个点击事件，触发函数去后端请求对应数据\n而使用监听属性，只需要在点击事件中对被监听变量进行赋值，就会自动触发函数发起请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;监听属性\u0026lt;/h1\u0026gt; \u0026lt;span @click=\u0026#34;categoryType=\u0026#39;美女\u0026#39;\u0026#34;\u0026gt;美女\u0026lt;/span\u0026gt;| \u0026lt;span @click=\u0026#34;categoryType=\u0026#39;帅哥\u0026#39;\u0026#34;\u0026gt;帅哥\u0026lt;/span\u0026gt;| \u0026lt;span @click=\u0026#34;categoryType=\u0026#39;老头\u0026#39;\u0026#34;\u0026gt;老头\u0026lt;/span\u0026gt; \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var vm = new Vue({ el: \u0026#39;.app\u0026#39;, data: { categoryType: \u0026#39;\u0026#39;, }, watch: { categoryType: function (val) { console.log(\u0026#39;name发生了变化\u0026#39;) console.log(val) // 向后端发送请求，请求回相应分类的数据，展示 } } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 组件化开发基础 作用：扩展 HTML 元素，封装可重用的代码，目的是复用\n例如：有一个轮播，可以在很多页面中使用，一个轮播有js，css，html\n组件把js，css，html放到一起，有逻辑，有样式，有html\n多组件页面和单组件页面\n官方推荐，以后一个组件是一个 xx.vue 文件 \u0026mdash;》webpack编译 Single-Page application，缩写为 SPA：以后vue项目只有一个页面，看到的页面变化都是组件间的切换\n全局组件 1 2 3 4 5 6 7 8 Vue.component(\u0026#39;navbar\u0026#39;, obj) obj = { template: ``, data() { return {} }, methods: {} } 在任意组件中都可以使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;全局组件\u0026lt;/h1\u0026gt; \u0026lt;navbar\u0026gt;\u0026lt;/navbar\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; // 定义一个全局组件，在任意组件中都可以使用 var obj = { template: ` \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;handleBack\u0026#34;\u0026gt;后退\u0026lt;/button\u0026gt; 我是一个组件--\u0026gt;{{ name }} \u0026lt;button\u0026gt;前进\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; `, data() { return { name: \u0026#39;lqz\u0026#39; } }, // 重点，data必须是个函数，返回一个对象，组件可以在多个地方重复使用，如果就是对象，导致多个组件的数据指向同一块内存地址，引起错乱 methods: { handleBack() { alert(\u0026#39;后退了\u0026#39;) } }, // 学的所有放在vm对象中的，都可以用 } Vue.component(\u0026#39;navbar\u0026#39;, obj) var vm = new Vue({ el: \u0026#39;.app\u0026#39;, data: {}, }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 局部组件\u0026ndash;\u0026gt;只能在某个组件中使用 1 2 3 4 5 6 7 8 9 components: { 组件名: { template: ``, data() { return {} }, methods: {} } } 如下案例中，局部组件只能在vm内使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;全局组件\u0026lt;/h1\u0026gt; \u0026lt;navbar\u0026gt;\u0026lt;/navbar\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;lqz\u0026gt;\u0026lt;/lqz\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; // 定义一个全局组件，在任意组件中都可以使用 var obj = { template: ` \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;handleBack\u0026#34;\u0026gt;后退\u0026lt;/button\u0026gt; 我是一个组件--\u0026gt;{{ name }} \u0026lt;button\u0026gt;前进\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; `, data() { return { name: \u0026#39;lqz\u0026#39; } }, // 重点，data必须是个函数，返回一个对象，组件可以在多个地方重复使用，如果就是对象，导致多个组件共用同一个对象的数据，出现错乱 methods: { handleBack() { alert(\u0026#39;后退了\u0026#39;) } }, // 学的所有放在vm对象中的，都可以用 components: {} // 全局组件下又可以定义局部组件，该组件可以在全局组件内部调用 } Vue.component(\u0026#39;navbar\u0026#39;, obj) var vm = new Vue({ el: \u0026#39;.app\u0026#39;, data: {}, components: { lqz: { template: ` \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;我是局部组件\u0026lt;/h3\u0026gt; \u0026lt;button\u0026gt;点我看美女\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;`, data() { return {} }, methods: {} } } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 组件通信 各个组件间，数据，方法，都是隔离的，要实现跨组件使用数据，就要实现组件通信\n父子通信之父传子（自定义属性） 在子组件中自定义属性接收父组件的变量，然后在子组件的props列表中声明属性名，就可以在子组件中使用父组件的值了\n1 2 3 \u0026lt;navbar :myname=\u0026#34;name\u0026#34; :age=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/navbar\u0026gt; props: [\u0026#39;myname\u0026#39;, \u0026#39;age\u0026#39;] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;通过自定义属性，实现父传子\u0026lt;/h1\u0026gt; \u0026lt;h3\u0026gt;父组件中name:{{name}}\u0026lt;/h3\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;navbar :myname=\u0026#34;name\u0026#34; :age=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/navbar\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; // 定义一个全局组件，在任意组件中都可以使用 Vue.component(\u0026#39;navbar\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;button\u0026gt;前进\u0026lt;/button\u0026gt; 名字是：{{ myname }}---\u0026gt;年龄是：{{ age }} \u0026lt;button\u0026gt;后退\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;`, props: [\u0026#39;myname\u0026#39;, \u0026#39;age\u0026#39;] }) var vm = new Vue({ el: \u0026#39;.app\u0026#39;, data: { name: \u0026#39;彭于晏\u0026#39;, age: 99 }, }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 父子通信之子传父(自定义事件) 点击按钮触发子组件事件handleClick 子组件执行函数this.$emit(\u0026lsquo;自定义事件名字\u0026rsquo;)，并将子组件的变量传递给自定义事件myevent 注册在子组件上的（在父组件内）自定义事件对应的函数handleReceive执行，即可将传递过来的子组件的变量赋值父组件的变量 本质：子组件把自己的值传出来，拿到父组件内，父组件内的函数实现赋值操作，将变量永久存储在父组件的变量中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;通过自定义事件，实现子传父\u0026lt;/h1\u0026gt; \u0026lt;h3\u0026gt;父组件中收到子组件传递对值为:{{name}}\u0026lt;/h3\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;navbar @myevent=\u0026#34;handleReceive\u0026#34;\u0026gt;\u0026lt;/navbar\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;navbar\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;iname\u0026#34;\u0026gt;---》{{ iname }} \u0026lt;br\u0026gt; \u0026lt;button @click=\u0026#34;handleClick\u0026#34;\u0026gt;点我吧iname传递到父组件中\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt;`, data() { return { iname: \u0026#39;\u0026#39; } }, methods: { handleClick() { // 触发自定义事件的执行，并且传入当前组件中的iname this.$emit(\u0026#39;myevent\u0026#39;, this.iname) // alert(this.iname) } } }) var vm = new Vue({ el: \u0026#39;.app\u0026#39;, data: { name: \u0026#39;\u0026#39;, }, methods: { handleReceive(iname) { this.name = iname } } }) //子组件点击按钮=\u0026gt;子组件执行函数this.$emit(\u0026#39;自定义事件名字\u0026#39;) =》注册在组件上的【自定义事件】对应的函数执行 \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; ref属性 对于组件间通信，vue提供了一个ref属性，可以放在任意标签\n放在普通标签,通过 this.$refs.ref对应的名字 就能拿到原生dom对象,使用原生操作该dom 放在自定义组件上,通过 this.$refs.ref对应的名字 就能拿到 组件对象，就可以调用对象的函数，使用对象的变量 父组件中，拿到了子组件对象，对象中的属性，方法可以直接用，直接改 通过ref，子传父\n因为在父中，可以拿到子的对象，子对象中的所有变量，方法，都可以直接用 通过ref，实现父传子\n因为在父中，可以拿到子的对象， 子对象.变量=父的变量 ref实现的还是父子之间的通信，要实现跨组件的通信，需要用到vuex\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;ref实现组件间通信\u0026lt;/h1\u0026gt; {{name}} \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;name\u0026#34; ref=\u0026#34;myinput\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;handleClick\u0026#34;\u0026gt;点我打印\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;navbar ref=\u0026#34;mynavbar\u0026#34;\u0026gt;\u0026lt;/navbar\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;button @click=\u0026#34;handleClick1\u0026#34;\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;navbar\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;iname\u0026#34;\u0026gt;---》{{ iname }} \u0026lt;br\u0026gt; \u0026lt;/div\u0026gt;`, data() { return { iname: \u0026#39;\u0026#39; } }, methods: { handleClick() { console.log(\u0026#39;执行了\u0026#39;) return \u0026#39;xxx\u0026#39; } } }) var vm = new Vue({ el: \u0026#39;.app\u0026#39;, data: { name: \u0026#39;\u0026#39;, }, methods: { handleClick() { console.log(this.$refs.myinput) console.log(this.$refs.myinput.value) this.$refs.myinput.value = \u0026#39;lqz is big\u0026#39; alert(this.name) }, handleClick1(){ console.log(this.$refs.mynavbar) // 相当于拿到了再组件中的this（组件对象） console.log(this.$refs.mynavbar.iname) // this.name=this.$refs.mynavbar.iname // 父组件中直接执行子组件的方法 // this.$refs.mynavbar.handleClick() // 调用子组件的方法 this.$refs.mynavbar.iname=\u0026#39;sssss\u0026#39; } } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 动态组件 \u0026lt;component\u0026gt;：动态地绑定多个组件到它的 is 属性，is属性等于哪个组件的name，就显示哪个组件\n场景： 组件是谁不确定，通过 is 确定显示那个组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;动态组件\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li @click=\u0026#34;myType=\u0026#39;home\u0026#39;\u0026#34;\u0026gt;首页\u0026lt;/li\u0026gt; \u0026lt;li @click=\u0026#34;myType=\u0026#39;goods\u0026#39;\u0026#34;\u0026gt;商品\u0026lt;/li\u0026gt; \u0026lt;li @click=\u0026#34;myType=\u0026#39;shopping\u0026#39;\u0026#34;\u0026gt;购物\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- 动态组件，is是哪个组件名字，这里就会显示那个组件--\u0026gt; \u0026lt;component :is=\u0026#34;myType\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;home\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;首页\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt;` }) Vue.component(\u0026#39;goods\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;商品\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt;` }) Vue.component(\u0026#39;shopping\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;购物\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt;` }) var vm = new Vue({ el: \u0026#39;.app\u0026#39;, data: { myType: \u0026#39;home\u0026#39;, }, }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;keep-alive\u0026gt; 保留状态，避免重新渲染\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;动态组件\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li @click=\u0026#34;myType=\u0026#39;home\u0026#39;\u0026#34;\u0026gt;首页\u0026lt;/li\u0026gt; \u0026lt;li @click=\u0026#34;myType=\u0026#39;goods\u0026#39;\u0026#34;\u0026gt;商品\u0026lt;/li\u0026gt; \u0026lt;li @click=\u0026#34;myType=\u0026#39;shopping\u0026#39;\u0026#34;\u0026gt;购物\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- 动态组件，is是哪个组件名字，这里就会显示那个组件--\u0026gt; \u0026lt;keep-alive\u0026gt; \u0026lt;component :is=\u0026#34;myType\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/keep-alive\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;home\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;首页\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt;` }) Vue.component(\u0026#39;goods\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;商品\u0026lt;/h2\u0026gt; 要搜索的商品：\u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;/div\u0026gt;` }) Vue.component(\u0026#39;shopping\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;购物\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt;` }) var vm = new Vue({ el: \u0026#39;.app\u0026#39;, data: { myType: \u0026#39;home\u0026#39;, }, }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; slot插槽 不具名插槽 在组件定义时预留一个slot标签，然后在使用时写在组件内的标签都会被插入到slot标签中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;插槽\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;home\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;https://pic.maizuo.com/usr/movie/0c5874a81c7969c8eb7ddee7b6ff46b3.jpg\u0026#34; alt=\u0026#34;\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;300px\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/home\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;home\u0026gt; \u0026lt;div\u0026gt; 我是div \u0026lt;/div\u0026gt; \u0026lt;/home\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;home\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;首页\u0026lt;/h2\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt;` }) var vm = new Vue({ el: \u0026#39;.app\u0026#39;, data: { myType: \u0026#39;home\u0026#39;, }, }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 具名插槽 在组件定义时为slot标签指定name\n使用插槽时指定slot属性值为对应的name，即可精准插入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!--使用插槽--\u0026gt; \u0026lt;home\u0026gt; \u0026lt;img src=\u0026#34;https://pic.maizuo.com/usr/movie/0c5874a81c7969c8eb7ddee7b6ff46b3.jpg\u0026#34; alt=\u0026#34;\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;300px\u0026#34; slot=\u0026#34;bottom\u0026#34;\u0026gt; \u0026lt;div slot=\u0026#34;top\u0026#34;\u0026gt; 我是div \u0026lt;/div\u0026gt; \u0026lt;/home\u0026gt; \u0026lt;!--组件定义--\u0026gt; Vue.component(\u0026#39;home\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;slot name=\u0026#34;top\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;p\u0026gt;我是子组件\u0026lt;/p\u0026gt; \u0026lt;slot name=\u0026#34;bottom\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt;` }) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;./js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;插槽\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;home\u0026gt; \u0026lt;img src=\u0026#34;https://pic.maizuo.com/usr/movie/0c5874a81c7969c8eb7ddee7b6ff46b3.jpg\u0026#34; alt=\u0026#34;\u0026#34; width=\u0026#34;200px\u0026#34; height=\u0026#34;300px\u0026#34; slot=\u0026#34;bottom\u0026#34;\u0026gt; \u0026lt;div slot=\u0026#34;top\u0026#34;\u0026gt; 我是div \u0026lt;/div\u0026gt; \u0026lt;/home\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;home\u0026#39;, { template: ` \u0026lt;div\u0026gt; \u0026lt;slot name=\u0026#34;top\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;p\u0026gt;我是子组件\u0026lt;/p\u0026gt; \u0026lt;slot name=\u0026#34;bottom\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt;` }) var vm = new Vue({ el: \u0026#39;.app\u0026#39;, data: { myType: \u0026#39;home\u0026#39;, }, }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; Vue-CLI 项目搭建 写一个一个独立的页面比较麻烦，这里就要引出一个前端工程化的概念，比如我们的python框架，开发后端接口就是一个独立的项目，那么能不能把前端开发也当成是一个项目呢？ vue是一个前端项目，需要webpack支持，同时vue官方提供了一个工具：vue-cli\nvue-cli：vue的脚手架，快速创建一个vue项目，带了很多文件\nvue2 中，都是使用vue-cli\nvue3中，可以使用vue-cli创建，官方更推荐使用 vite ，更块，更小\nVue-CLI 是基于nodejs的\nnodejs：是一门后端编程语言，js语法，运行在操作系统上，后端语言，跟python一样，是一个解释型语言，需要安装解释器 搭建node：下载自己平台对应的版本即可，添加环境变量\nnode：相当于python npm：包管理工具，相当于pip 安装 vue-cli：\n配置cnpm（淘宝定制，去淘宝镜像站下载，比npm下载更快）\n1 npm install -g cnpm --registry=https://registry.npmmirror.com 这样以后就可以用cnpm安装\n如果要永久替换，执行下述命令\n1 npm config set registry https://registry.npmmirror.com 永久替换后，使用npm指令就默认是去淘宝的镜像站下载\n安装vue-cli\n1 cnpm install -g @vue/cli 创建项目：\n使用vue脚手架，创建vue项目，装完脚手架，就会有个 vue 命令\nvue create 项目名 命令行创建 vue ui 图形化界面创建 命令行创建说明：\n第三方组件选择\nvue版本\n包管理文件\n创建成功后就可以使用pycharm打开项目了\nvue项目启动 方式一：终端执行npm run serve\n方式二：配置pycharm的启动按钮\nvue项目目录文件介绍 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 vue2_test # 项目名 node_modules # 类似于学的python的虚拟环境，主要放了当前项目所有的依赖，很多小文件，给别人发送项目需要把它删掉，执行命令npm install即可重新下载 public # 文件夹 favicon.ico # 网站小图标 index.html # 单页面应用(spa) \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; src # 重点：文件夹，以后咱们的代码，都写在这里，js，组件，启动文件 assets # 文件夹，放静态资源，图片，js，css logo.png # 图片 components # 文件夹，内部放所有的小组件，非页面组件 HelloWorld.vue # 写了一个默认的HelloWorld的组件，是以 .vue结尾都 router # 文件夹，vue-router模块安装了就会有，主要做路由配置 index.js # vue-router的js文件 store # 文件夹，vuex模块安装了就会有，主要做vuex的配置 index.js # vuex的js文件 views # 文件夹，放组件，放页面组件 AboutView.vue # 关于的页面组件 HomeView.vue # 首页的页面组件 App.vue # 根组件 vm对象就是它，它管理了index.html的id为app的div main.js # 整个入口，非常重要，很多全局配置 .gitignore # git忽略文件相关 babel.config.js# babel的配置，咱们不用管 jsconfig.json # 不需要关注 package.json # 重要：项目依赖的所有第三方模块 等同于python中 requirements.txt # 执行了 npm install -S axios,这里面就会多这一条 package-lock.json # 锁定版本 README.md # 项目介绍 vue.config.js # vue的配置文件 等同于 django中setting.py vue项目开发技巧 项目入口\nsrc/main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 模块的导入 import Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; // 修改vue的提示信息，关闭开发模式 Vue.config.productionTip = false // 不用动 new Vue({ router, store, render: h =\u0026gt; h(App) // 等同于data，method等等 }).$mount(\u0026#39;#app\u0026#39;) // 等同于el，与index.html中的div标签绑定 以后组件化开发，就是写一个个的组件，页面组件，小组件，每一个组件都是xx.vue：\nApp.vue：根组件\n如何开发一个组件？\n第一部分：\n1 2 3 4 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; # 组件必须套在一个标签内部，里面写上之前用反引号写的html内容 \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 第二部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script\u0026gt; export default { // 以后在这个对象中写咱们之前学的data，methods，watch，computed，生命周期钩子 name: \u0026#39;App\u0026#39;, data() { return { name: \u0026#39;lqz\u0026#39; } } , methods: { handleClick() { this.name = \u0026#39;彭于晏\u0026#39; } } } \u0026lt;/script\u0026gt; 第三部分：\n1 2 3 4 5 \u0026lt;style\u0026gt; h1 { background-color: red; } \u0026lt;/style\u0026gt; 如何在根组件中使用自定义的组件？ 例如，我们创建了一个名为HelloWorld.vue的组件\n自定义组件src/components/HelloWorld.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{ msg }}\u0026lt;/h1\u0026gt; x的值是：{{ x }},y的值是：{{ y }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;HelloWorld\u0026#39;, props: [\u0026#39;msg\u0026#39;], //父传子，自定义属性，接受 data() { return { x: 10, y: 20 } } } \u0026lt;/script\u0026gt; 根组件src/App.vue\n先导入自定义组件，再在components中注册为局部组件，在template中使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;我是h1\u0026lt;/h1\u0026gt; {{ name }} \u0026lt;br\u0026gt; \u0026lt;button @click=\u0026#34;handleClick\u0026#34;\u0026gt;点我名字变化\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;HelloWorld :msg=\u0026#34;msg\u0026#34;\u0026gt;\u0026lt;/HelloWorld\u0026gt; \u0026lt;!-- 自定义属性实现父传子--\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; h1 { background-color: red; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; // 把HelloWorld组件导入 import HelloWorld from \u0026#34;@/components/HelloWorld.vue\u0026#34;; export default { name: \u0026#39;App\u0026#39;, data() { return { name: \u0026#39;lqz\u0026#39;, msg: \u0026#39;你好啊\u0026#39; } }, methods: { handleClick() { this.name = \u0026#39;彭于晏\u0026#39; } }, components: { // 注册局部组件 HelloWorld } } \u0026lt;/script\u0026gt; es6导入导出语法 写vue项目，大量的看到：他们是es6的导入和导出语法，比如\n1 2 import App from \u0026#39;./App.vue\u0026#39; export default{} 1、可以在任意位置写xx.js,可以定义变量，定义函数\n2、导出某些变量、函数\n2.1 默认导出\n1 2 3 export default { name,print } 2.2 命名导出\n1 export const a =10 3、在想用的地方导入\n1 import 别名 form \u0026#39;路径\u0026#39; 4、使用\n1 2 别名.name 别名.print() 案例：在main.js中使用自己编写的test.js文件中的变量以及函数\nsrc/assets/js/test.js\n1 2 3 4 5 6 7 8 9 10 11 var name = \u0026#39;刘亦菲\u0026#39; var age = 99 function print() { console.log(\u0026#39;hello world\u0026#39;) console.log(age) } // 默认导出，才能在别的地方导入 export default {name, print} // export default {name: name, print: print} src/main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 模块的导入 import Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; // 修改vue的提示信息，关闭开发模式 Vue.config.productionTip = false //在这里使用test.js中定义的变量和函数，再导入之前，必须在test.js中导出才行 import test from \u0026#39;./assets/js/test.js\u0026#39; //使用print函数 test.print() console.log(test.name) //无法使用未导出的变量 console.log(test.age) // 不用动 new Vue({ router, store, render: h =\u0026gt; h(App) // 等同于data，method等等 }).$mount(\u0026#39;#app\u0026#39;) // 等同于el，与index.html中的div标签绑定 补充：如果一个包下有一个名为index.js 的文件，可以只导入到包这一层，index.js 可以省略\n1 2 3 import lqz from \u0026#39;./lqz/index\u0026#39; # 简写 import lqz from \u0026#39;./lqz\u0026#39; 学了es6的导入导出语法后，再回头理解一下main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 模块的导入 import Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; // 修改vue的提示信息，关闭开发模式 Vue.config.productionTip = false // 不用动 new Vue({ router, store, render: h =\u0026gt; h(App) // 等同于data，method等等 }).$mount(\u0026#39;#app\u0026#39;) // 等同于el，与index.html中的div标签绑定 App.vue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;我是h1\u0026lt;/h1\u0026gt; {{ name }} \u0026lt;br\u0026gt; \u0026lt;button @click=\u0026#34;handleClick\u0026#34;\u0026gt;点我名字变化\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;HelloWorld :msg=\u0026#34;msg\u0026#34;\u0026gt;\u0026lt;/HelloWorld\u0026gt; \u0026lt;!-- 自定义属性实现父传子--\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; h1 { background-color: red; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; // 把HelloWorld组件导入 import HelloWorld from \u0026#34;@/components/HelloWorld.vue\u0026#34;; export default { name: \u0026#39;App\u0026#39;, data() { return { name: \u0026#39;lqz\u0026#39;, msg: \u0026#39;你好啊\u0026#39; } }, methods: { handleClick() { this.name = \u0026#39;彭于晏\u0026#39; } }, components: { // 注册局部组件 HelloWorld } } \u0026lt;/script\u0026gt; 在App.vue中默认导出了以下内容。封装为一个对象，在main.js中命名为App\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { name: \u0026#39;App\u0026#39;, data() { return { name: \u0026#39;lqz\u0026#39;, msg: \u0026#39;你好啊\u0026#39; } }, methods: { handleClick() { this.name = \u0026#39;彭于晏\u0026#39; } }, components: { // 注册局部组件 HelloWorld } } 所以App就是App.vue定义的组件对象，同样的，在App.vue中引入HelloWorld组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // HelloWorld.vue \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{ msg }}\u0026lt;/h1\u0026gt; x的值是：{{ x }},y的值是：{{ y }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;HelloWorld\u0026#39;, props: [\u0026#39;msg\u0026#39;], //父传子，自定义属性，接受 data() { return { x: 10, y: 20 } } } \u0026lt;/script\u0026gt; 1 2 3 4 5 6 // App.vue components: { // 注册局部组件 // HelloWorld:HelloWorld HelloWorld } 等同于\n1 2 3 4 5 6 7 8 9 10 11 12 13 components: { HelloWorld:{ name: \u0026#39;HelloWorld\u0026#39;, props: [\u0026#39;msg\u0026#39;], //父传子，自定义属性，接受 data() { return { x: 10, y: 20 } } } } axios与后端交互处理跨域，携带数据，携带请求头 使用axios与后端交互 安装axios\n1 npm install -S axios 使用\n1 2 3 4 5 6 7 import axios from \u0026#39;axios\u0026#39; axios.get(\u0026#39;http://127.0.0.1:8000/user/\u0026#39;).then(res=\u0026gt;{ console.log(res) this.name=res.data.name this.age=res.data.age }) 后端需要添加响应头'Access - Control - Allow - Origin':'*'\n解决跨域问题（浏览器的同源策略）\n后端使用cors技术 使用nginx转发 前端做代理：只在测试阶段使用，上线后没有 处理跨域 在开发时，常用后端使用cors技术解决跨域问题，需要第三方库django-cors-headers\n安装\n1 pip install django-cors-headers 使用\n注册app\n1 2 3 4 5 INSTALLED_APPS = ( ... \u0026#39;corsheaders\u0026#39;, ... ) 添加中间件\n1 2 3 4 5 MIDDLEWARE = [ ... \u0026#39;corsheaders.middleware.CorsMiddleware\u0026#39;, ... ] 需要注意的是，它应该放在其他可能会生成响应的中间件之前，比如django.middleware.common.CommonMiddleware，这样才能正确地设置响应头\n其他配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 CORS_ALLOW_CREDENTIALS = True # 允许所有的源进行跨域访问 CORS_ORIGIN_ALLOW_ALL = True # 允许跨域访问的源列表 CORS_ORIGIN_WHITELIST = ( \u0026#39;*\u0026#39; ) # 指定允许的跨域请求方法 CORS_ALLOW_METHODS = ( \u0026#39;DELETE\u0026#39;, \u0026#39;GET\u0026#39;, \u0026#39;OPTIONS\u0026#39;, \u0026#39;PATCH\u0026#39;, \u0026#39;POST\u0026#39;, \u0026#39;PUT\u0026#39;, \u0026#39;VIEW\u0026#39;, ) # 指定允许的跨域请求头 CORS_ALLOW_HEADERS = ( \u0026#39;XMLHttpRequest\u0026#39;, \u0026#39;X_FILENAME\u0026#39;, \u0026#39;accept-encoding\u0026#39;, \u0026#39;authorization\u0026#39;, \u0026#39;content-type\u0026#39;, \u0026#39;dnt\u0026#39;, \u0026#39;origin\u0026#39;, \u0026#39;user-agent\u0026#39;, \u0026#39;x-csrftoken\u0026#39;, \u0026#39;x-requested-with\u0026#39;, \u0026#39;Pragma\u0026#39;, ) post请求携带数据 axios.post接收三个参数，第二个参数即参数对象，用{}包裹，构建要传递的参数键值对即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 handleSubmit() { axios.post(\u0026#39;http://127.0.0.1:8000/user/\u0026#39;, { username: this.username, password: this.password }).then(res =\u0026gt; { console.log(res.data) if (res.data.code == 100) { // 登录成功跳转到百度 location.href = \u0026#39;http://www.baidu.com\u0026#39; } else { alert(res.data.msg) } }) } 携带请求头 axios.post接收三个参数，第三个参数即请求头，同样是对象类型\n注意，请求头token需要在django-cors-headers的配置项CORS_ALLOW_HEADERS中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 请求头中带token handleSubmit1() { axios.post(\u0026#39;http://127.0.0.1:8000/user/\u0026#39;, { username: this.username, password: this.password }, { headers: {token: \u0026#39;asdfasdfasd\u0026#39;} } ).then(res =\u0026gt; { console.log(res.data) if (res.data.code == 100) { // 登录成功跳转到百度 location.href = \u0026#39;http://www.baidu.com\u0026#39; } else { alert(res.data.msg) } }) } props配置项指定默认值 props是组件间通信，父传子，自定义属性时，子组件接收父组件传入的数据使用的配置项\n基本使用 引入的路径 import Child from \u0026ldquo;@/components/Child\u0026rdquo;; @代表src目录 使用步骤 父组件将属性值传入子组件 \u0026lt;Child :msg=\u0026quot;msg\u0026quot;\u0026gt;\u0026lt;/Child\u0026gt; 子组件 props: ['msg'],在props中接收，无需在data中再次定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Child.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;button\u0026gt;后退\u0026lt;/button\u0026gt; {{ title }}----收到父组件传入的: {{ msg }} \u0026lt;button @click=\u0026#34;handleClick\u0026#34;\u0026gt;前进\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;Child\u0026#34;, props: [\u0026#39;msg\u0026#39;], data() { return { title: \u0026#39;好看的首页\u0026#39; } }, methods: { handleClick() { alert(\u0026#39;前进\u0026#39;) } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // App.vue \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;我是App\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;下面是局部组件\u0026lt;/h2\u0026gt; \u0026lt;Child :msg=\u0026#34;msg\u0026#34;\u0026gt;\u0026lt;/Child\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; h1 { background-color: red; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; // import Child from \u0026#34;./components/Child\u0026#34;; import Child from \u0026#34;@/components/Child\u0026#34;; // @ 代指src路径 export default { name: \u0026#39;App\u0026#39;, data() { return { msg:\u0026#39;给儿子的一条消息\u0026#39; } }, components: { Child } } \u0026lt;/script\u0026gt; 限制类型 1 2 3 props: { msg: String, }, 补充：\n\u0026lt;Child :msg=\u0026quot;true\u0026quot;\u0026gt;\u0026lt;/Child\u0026gt;接收到的msg是布尔类型，报错 \u0026lt;Child msg=\u0026quot;msg\u0026quot;\u0026gt;\u0026lt;/Child\u0026gt;接收到的msg是字符串，不报错 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // App.vue \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;我是App\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;下面是局部组件\u0026lt;/h2\u0026gt; \u0026lt;!-- \u0026lt;Child :msg=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/Child\u0026gt;--\u0026gt; \u0026lt;Child msg=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/Child\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; h1 { background-color: red; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; // import Child from \u0026#34;./components/Child\u0026#34;; import Child from \u0026#34;@/components/Child\u0026#34;; // @ 代指src路径 export default { name: \u0026#39;App\u0026#39;, data() { return { msg:\u0026#39;给儿子的一条消息\u0026#39; } }, components: { Child } } \u0026lt;/script\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // Child.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;button\u0026gt;后退\u0026lt;/button\u0026gt; {{ title }}----收到父组件传入的: {{ msg }} \u0026lt;button @click=\u0026#34;handleClick\u0026#34;\u0026gt;前进\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;Child\u0026#34;, props: { msg: String, }, data() { return { title: \u0026#39;好看的首页\u0026#39; } }, methods: { handleClick() { alert(\u0026#39;前进\u0026#39;) } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 限定类型，限定必要性，限定默认值 1 2 3 4 5 6 7 8 props: { msg: { type: String, //类型 required: false, //必要性 default: \u0026#39;老王\u0026#39; //默认值 }, xx:Boolean, }, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // App.vue \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;我是App\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;下面是局部组件\u0026lt;/h2\u0026gt; \u0026lt;Child\u0026gt;\u0026lt;/Child\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; h1 { background-color: red; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; // import Child from \u0026#34;./components/Child\u0026#34;; import Child from \u0026#34;@/components/Child\u0026#34;; // @ 代指src路径 export default { name: \u0026#39;App\u0026#39;, data() { return { msg: \u0026#39;给儿子的一条消息\u0026#39; } }, components: { Child } } \u0026lt;/script\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // Child.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;button\u0026gt;后退\u0026lt;/button\u0026gt; {{ title }}----收到父组件传入的: {{ msg }} \u0026lt;button @click=\u0026#34;handleClick\u0026#34;\u0026gt;前进\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;Child\u0026#34;, props: { msg: { type: String, //类型 required: false, //必要性 default: \u0026#39;老王\u0026#39; //默认值 }, }, data() { return { title: \u0026#39;好看的首页\u0026#39; } }, methods: { handleClick() { alert(\u0026#39;前进\u0026#39;) } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 混入 混入（minxin）：可以把多个组件共用的配置提取成一个混入对象\n现在有一个App.vue和子组件Child.vue都有点击弹出name属性的handleShowName方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // App.vue \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;我是App\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;handleShowName\u0026#34;\u0026gt;点我显示人名\u0026lt;/button\u0026gt; \u0026lt;Child\u0026gt;\u0026lt;/Child\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; h1 { background-color: red; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; // import Child from \u0026#34;./components/Child\u0026#34;; import Child from \u0026#34;@/components/Child\u0026#34;; // @ 代指src路径 export default { name: \u0026#39;App\u0026#39;, data() { return { name: \u0026#39;lqz\u0026#39; } }, methods: { handleShowName() { alert(this.name); } }, components: {Child}, } \u0026lt;/script\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Child.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;button @click=\u0026#34;handleShowName\u0026#34;\u0026gt;点我弹出名字\u0026lt;/button\u0026gt; {{ title }}---- \u0026lt;button\u0026gt;前进\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;Child\u0026#34;, data() { return { title: \u0026#39;首页\u0026#39;, name: \u0026#39;刘亦菲\u0026#39; } }, methods: { handleShowName() { alert(this.name) } }, } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 如果有十个组件都有这个方法，我们需要重写10遍吗？显然不现实，而混入就是用来解决这个问题的，将该方法提取为一个混入对象\n下面来看如何操作\n第一步：抽取共用的代码，定义混入\n1 2 3 4 5 6 7 8 // mixin/index.js export const hunhe = { methods: { handleShowName() { alert(this.name) } }, } 第二步：注册混入\n全局注册 只要注册了，所有组件都可以用，在main.js中注册\n1 2 import {hunhe} from \u0026#39;@/mixin\u0026#39; Vue.mixin(hunhe) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // main.js // 模块的导入 import Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; // 修改vue的提示信息，关闭开发模式 Vue.config.productionTip = false import {hunhe} from \u0026#39;@/mixin\u0026#39; Vue.mixin(hunhe) // 不用动 new Vue({ router, store, render: h =\u0026gt; h(App) // 等同于data，method等等 }).$mount(\u0026#39;#app\u0026#39;) // 等同于el，与index.html中的div标签绑定 局部注册 只在被注册的组件中可用，在xx.vue中注册\n1 2 import {hunhe} from \u0026#34;@/mixin\u0026#34;; mixins: [hunhe] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // App.vue \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;我是App\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;handleShowName\u0026#34;\u0026gt;点我显示人名\u0026lt;/button\u0026gt; \u0026lt;Child\u0026gt;\u0026lt;/Child\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; h1 { background-color: red; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; // import Child from \u0026#34;./components/Child\u0026#34;; import Child from \u0026#34;@/components/Child\u0026#34;; // @ 代指src路径 import {hunhe} from \u0026#34;@/mixin\u0026#34;; export default { name: \u0026#39;App\u0026#39;, data() { return { name: \u0026#39;lqz\u0026#39; } }, methods: {}, components: {Child}, mixins: [hunhe], } \u0026lt;/script\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Child.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;button @click=\u0026#34;handleShowName\u0026#34;\u0026gt;点我弹出名字\u0026lt;/button\u0026gt; {{ title }}---- \u0026lt;button\u0026gt;前进\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import {hunhe} from \u0026#34;@/mixin\u0026#34;; export default { name: \u0026#34;Child\u0026#34;, data() { return { title: \u0026#39;首页\u0026#39;, name: \u0026#39;刘亦菲\u0026#39; } }, methods: {}, mixins: [hunhe], } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 插件 基本使用 用于增强Vue，后期咱们学的vuex，vue-router，elementui都是基于插件的形式使用的\n下面我们来试着实现一个插件\n定义一个插件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //src/plugins/index.js import Vue from \u0026#39;vue\u0026#39; export default { install(a) { //参数a其实就是vue对象，因此下列代码的Vue可以用a代替 console.log(a) //写代码，加入混入 Vue.mixin({ methods: { handleShowName() { alert(this.name) } }, }) //写代码，给Vue对象上放变量 Vue.prototype.xxx = \u0026#39;qiu is nb\u0026#39; //写代码，给Vue对象上放函数 Vue.prototype.hello = () =\u0026gt; { alert(\u0026#34;123\u0026#34;) } } } 应用插件 在main.js中导入并使用插件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 模块的导入 import Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; // 修改vue的提示信息，关闭开发模式 Vue.config.productionTip = false // 使用刚刚定义的插件 import plugins from \u0026#34;@/plugins\u0026#34;; Vue.use(plugins)//自动调用插件内的install，完成对Vue的强化 // 不用动 new Vue({ router, store, render: h =\u0026gt; h(App) // 等同于data，method等等 }).$mount(\u0026#39;#app\u0026#39;) // 等同于el，与index.html中的div标签绑定 此时的Vue对象就经过了强化，加入了混入以及添加了xxx属性以及hello方法\n测试案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;我是App\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;handleShowName\u0026#34;\u0026gt;点我显示人名\u0026lt;/button\u0026gt; \u0026lt;Child\u0026gt;\u0026lt;/Child\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; h1 { background-color: red; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; // import Child from \u0026#34;./components/Child\u0026#34;; import Child from \u0026#34;@/components/Child\u0026#34;; // @ 代指src路径 export default { name: \u0026#39;App\u0026#39;, data() { return { name: \u0026#39;lqz\u0026#39; } }, methods: {}, components: {Child}, created() { console.log(this.xxx) this.hello() } } \u0026lt;/script\u0026gt; 进阶使用 可以在插件中将常用的第三方库导入，定义为一个属性，从而无需每一次在页面组件中使用都要重新导入 通过插件，把axios对象放到vue实例上定义为$http属性 Vue.prototype.$http = axios 以后要想使用axios发请求，无需导入，直接使用自己的$http属性即可 this.$http.get() 自定义指令 v-xx 定义很多全局组件 通过在插件中定义全局组件，导入插件后，可以在所有的vue中直接使用组件 element-ui就是通过这种方式实现的，在main.js中导入并使用ElementUI，就可以直接使用它定义好的美观的组件 scoped样式 当我们在某一组件中定义了style属性，默认该组件中的子组件也会应用该属性，造成污染\nscoped样式就是为了解决这一污染问题，加在组件的style标签内，表示写的样式，只在当前组件生效，不会影响到其他组件\n1 2 3 \u0026lt;style scoped\u0026gt; ... \u0026lt;style\u0026gt; 具名插槽的其他写法 在前面的学习中，我们使用了具名插槽\n1 2 3 4 5 6 7 8 \u0026lt;div slot=\u0026#34;bottom\u0026#34;\u0026gt; \u0026lt;form action=\u0026#34;\u0026#34;\u0026gt; \u0026lt;p\u0026gt;用户名：\u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;密码：\u0026lt;input type=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;button\u0026gt;登录\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;p\u0026gt;我是p标签\u0026lt;/p\u0026gt; \u0026lt;div/\u0026gt; 如我们所知，必须将所有标签包裹在一个div里，否则无法同时将form表单与p标签插入到插槽当中\n但这样生成的前端页面中也会有外层div的存在，也没有方式可以不要最外层的div也可以将两个标签作为整体插入到插槽中呢？\n我们可以使用template标签，同时，官方推荐我们采用v-slot:bottom的语法来指定插槽\n1 2 3 4 5 6 7 8 \u0026lt;template v-slot:bottom\u0026gt; \u0026lt;form action=\u0026#34;\u0026#34;\u0026gt; \u0026lt;p\u0026gt;用户名：\u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;密码：\u0026lt;input type=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;button\u0026gt;登录\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;p\u0026gt;我是p标签\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 项目中使用bootstrap，elementui 在使用Vue进行开发时有很多可以选择的前端组件库，帮助我们轻松构建美观的前端页面，常见的如下\niView：https://www.iviewui.com/view-ui-plus/guide/introduce app端的ui组件库：http://vant3.uihtm.com/#/zh-CN BootStrapVue：https://code.z01.com/bootstrap-vue/ 推荐使用elementui：https://element.eleme.cn/#/zh-CN/component/installation\nelementui的使用 安装\n1 npm i element-ui -S 在main.js中引入\n1 2 3 4 5 6 7 8 9 10 11 import Vue from \u0026#39;vue\u0026#39;; import ElementUI from \u0026#39;element-ui\u0026#39;; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; import App from \u0026#39;./App.vue\u0026#39;; Vue.use(ElementUI); new Vue({ el: \u0026#39;#app\u0026#39;, render: h =\u0026gt; h(App) }); 完整的main.js文件如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 模块的导入 import Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; import store from \u0026#39;./store\u0026#39; // 修改vue的提示信息，关闭开发模式 Vue.config.productionTip = false //使用elementui import ElementUI from \u0026#39;element-ui\u0026#39;; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; Vue.use(ElementUI); // 不用动 new Vue({ router, store, render: h =\u0026gt; h(App) // 等同于data，method等等 }).$mount(\u0026#39;#app\u0026#39;) // 等同于el，与index.html中的div标签绑定 使用\n直接去官网复制代码，贴进去即可 注意复制的完整性，包括templage，script，style内容 bootstrap的使用 因为bootstrap使用了jQuery的内容，因此要想使用bootstrap，还需要引入jQuery\n安装\ncnpm install jquery cnpm install bootstrap@3 在main.js中引入\n1 2 import \u0026#39;bootstrap\u0026#39; import \u0026#39;bootstrap/dist/css/bootstrap.min.css\u0026#39; 在vue的配置文件中vue.config.js中配置jQuery\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const {defineConfig} = require(\u0026#39;@vue/cli-service\u0026#39;) const webpack = require(\u0026#34;webpack\u0026#34;); module.exports = { configureWebpack: { plugins: [ new webpack.ProvidePlugin({ $: \u0026#34;jquery\u0026#34;, jQuery: \u0026#34;jquery\u0026#34;, \u0026#34;window.jQuery\u0026#34;: \u0026#34;jquery\u0026#34;, \u0026#34;window.$\u0026#34;: \u0026#34;jquery\u0026#34;, Popper: [\u0026#34;popper.js\u0026#34;, \u0026#34;default\u0026#34;] }) ] } }; 配置完成后的vue.config.js文件如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const { defineConfig } = require(\u0026#39;@vue/cli-service\u0026#39;); const webpack = require(\u0026#34;webpack\u0026#34;); module.exports = defineConfig({ configureWebpack: { plugins: [ new webpack.ProvidePlugin({ $: \u0026#34;jquery\u0026#34;, jQuery: \u0026#34;jquery\u0026#34;, \u0026#34;window.jQuery\u0026#34;: \u0026#34;jquery\u0026#34;, \u0026#34;window.$\u0026#34;: \u0026#34;jquery\u0026#34;, Popper: [\u0026#34;popper.js\u0026#34;, \u0026#34;default\u0026#34;] }) ] }, transpileDependencies: true }); 直接使用bootstrap样式，复制黏贴即可\nlocalStorage和sessionStorage 前端存储数据的地方\ncookie中：借助第三方插件，自己用js写 sessionStorage：关闭浏览器自动销毁 localStorage：永久存在，除非手动删除，或浏览器存满了 通过这三个东西就可以实现组件间通信\n1 2 3 4 5 6 7 8 9 10 11 # 使用：sessionStorage sessionStorage.setItem(\u0026#39;name\u0026#39;, \u0026#39;lqz\u0026#39;) // 存 sessionStorage.getItem(\u0026#39;name\u0026#39;) // 取 sessionStorage.clear() // 清空所有 sessionStorage.removeItem(\u0026#39;name\u0026#39;) // 根据键删除 # 使用：localStorage localStorage.setItem(\u0026#39;name\u0026#39;, \u0026#39;lqz\u0026#39;) localStorage.getItem(\u0026#39;name\u0026#39;) localStorage.clear() localStorage.removeItem(\u0026#39;name\u0026#39;) 某些不需要登陆就可以添加购物车的网站就是使用localStorage实现的，无需登录，数据存在本地，下次打开浏览器购物车数据还在\nvuex vuex：状态管理器，存取数据用的,可以跨组件通信（屏蔽了组件的父子关系）\n每一个Vuex应用的核心就是Store（仓库），我们可以说Store是一个容器，Store里面的状态与单纯的全局变量是不一样的，无法直接改变Store中的状态。想要改变状态需通过mutation去修改。\nvuex具体使用方法 store的创建 在 src根目录下创建文件夹store，并在其下index.js。需包含actions，mutations，state结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 引入vue import Vue from \u0026#39;vue\u0026#39; // 引入vuex import Vuex from \u0026#39;vuex\u0026#39; // 应用vue插件 Vue.use(Vuex) // actions响应组件中的动作 const actions = { } // mutations操作数据state const mutations = { } // 准备state存储数据 const state = { //状态对象 } // 创建store并导出 const store = new Vuex.Store({ actions, mutations, state, }) //默认导出store export default store 引入store 在main.js中引入store，全局组件都可以使用vuex\n1 2 3 4 5 6 import store from \u0026#39;./store\u0026#39; new Vue({ router, store, # 把store放在这里 render: h =\u0026gt; h(App) }).$mount(\u0026#39;#app\u0026#39;) 各个状态的核心概念 state state是状态数据，可以通过this.$store.state来直接获取状态，也可以利用vuex提供的mapState辅助函数将state映射到计算属性（computed）中去。\n例如，定义了如下state\n1 2 3 4 5 const state = { sum:0, realname:\u0026#39;张三\u0026#39;, age:19 } 可以通过插值引用直接取出state中的值：{{$store.state.sum}}\nmutations 更改 Vuex 的 store 中的修改状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的事件类型 (type)和一个回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数。\n例如，我们定义了如下mutations\n1 2 3 4 5 6 7 8 9 // 操作state中的数据 mutations :{ editTitle(state,value){ state.title = value; }, editSinger(state,value){ state.singer = value; } }, 使用methods方法，使用commit直接操作state中的数据\n1 2 3 4 5 \u0026lt;button @click=\u0026#34;editTitle(\u0026#39;Lover\u0026#39;)\u0026#34;\u0026gt;更改歌名\u0026lt;/button\u0026gt; editTitle(str){ this.$store.commit(\u0026#39;editTitle\u0026#39;,str); }, actions Action 提交的是 mutation，而不是直接变更状态。\n例如，我们定义了如下actions\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 相应组件中的动作，组件中可以通过dispatch发送， // actions 通过commit发送动作告知mutations actions:{ changeSing(context,value){ setTimeout(()=\u0026gt;{ context.commit(\u0026#39;editTitle\u0026#39;,value); },3000) }, changeSinger(context,value){ setTimeout(()=\u0026gt;{ context.commit(\u0026#39;editSinger\u0026#39;,value); },3000) } }, 使用methods方法，调用dispatch，传递mutation名与value，mutation再调用commit，传递回调函数以及value，真正实现state数据的修改\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;button @click=\u0026#34;changeSing(\u0026#39;EndGame\u0026#39;)\u0026#34;\u0026gt;三秒后更改歌名\u0026lt;/button\u0026gt; changeSing(str){ setTimeout(()=\u0026gt;{ this.$store.dispatch(\u0026#39;changeSing\u0026#39;,str); },3000) }, changeSinger(str){ setTimeout(()=\u0026gt;{ this.$store.dispatch(\u0026#39;changeSinger\u0026#39;,str); },3000) } 总结 在任意组件中，要获取state中的数据，只需要this.$store.state.变量即可\n要想修改state中的数据，有两种实现方式\n直接调用commit this.$store.commit(\u0026ldquo;motations中定义的函数\u0026rdquo;，参数) motations中定义的函数实现数据的变化 调用dispatch this.$store.dispatch(\u0026ldquo;actions中定义的函数\u0026rdquo;,参数) actions定义的函数进一步触发commit motations中定义的函数实现数据的变化 推荐使用dispatch，因为它更加安全，可以在里面进行权限校验，向后端发请求判断是否commit此次修改数据的请求\nvue-router spa:单页面应用，即只有一个主页面，页面的不同依赖的是组件的来回切换，需要借助于vue-router\nvue-router的具体使用 创建路由配置表 在项目的src目录下新建routes文件夹，创建index.js文件来统一管理路由配置表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import Vue from \u0026#39;vue\u0026#39; import VueRouter from \u0026#39;vue-router\u0026#39; //引入vue组件 import Home from \u0026#39;@/views/Home\u0026#39; import AboutView from \u0026#39;@/views/AboutView\u0026#39; Vue.use(VueRouter) // 注册路由，配置路由与vue组件的对应关系 const routes = [ { path: \u0026#39;/home\u0026#39;, name: \u0026#39;home\u0026#39;, component: Home }, { path: \u0026#39;/about\u0026#39;, name: \u0026#39;about\u0026#39;, component: AboutView }, ] const router = new VueRouter({ mode: \u0026#39;history\u0026#39;, base: process.env.BASE_URL, routes }) export default router 在main.js中注册 1 2 3 4 5 6 import router from \u0026#39;./router\u0026#39; new Vue({ router, render: h =\u0026gt; h(App) }).$mount(\u0026#39;#app\u0026#39;) 组件中使用路由 router-link 是 vue-router 提供的一个全局组件，它是用来做路由跳转，底层其实就是一个a标签\nrouter-view 是 vue-router 提供的一个全局组件，它是用来提供一个路由占位，用来挂载 URL 匹配到的组件。\nApp.vue文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/about\u0026#34;\u0026gt;Go to /about\u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;App\u0026#39;, data() { return {} }, } \u0026lt;/script\u0026gt; 使用 写好页面组件 在router/index.js中引入组件并配置路由与组件的对应关系 在main.js中注册 在单页面中插入路由占位\u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; 1 2 3 以后访问路径 http://192.168.1.5:8080/home 显示Home组件 http://192.168.1.5:8080/about 显示AboutView组件 在任意组件中，this.$router，拿到的就是导出的router对象\n总结 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 # 前端发展历史 -render返回一个一个页面---》ajax出现---（ajax+dom）实现局部刷新--》前端写很多页面html，js，css---》vue，react---》一套代码，处处运行(谷歌，uni-app) # vue的介绍 -js框架，vue2 vue3 -MVVM架构： m：model(js中数据) v：view vm:ViewModel 页面变，数据跟着变，数据变页面也变化 -组件化开发 -单页面开发---》页面间的跳转(vue-router) # vue的快速使用 -引入vue，new Vue实例对象，传入一些配置项data,methods，在被vue管理的标签中使用vue语法 # 插值语法 -{{变量，简单的表达式，函数}} -三目运算符---》python中的三元表达式 # 指令v-html和v-text -v-xx 写法，写在标签上的，统称为vue的指令 -\u0026lt;p v-html=\u0026#39;\u0026#39;\u0026gt;\u0026lt;/p\u0026gt; xss攻击 -v-text # v-if和v-show -控制标签显示与隐藏 # 双向数据绑定演示 # v-on 事件指令 -点击事件，双击事件，失去焦点。。。。 -@事件名=\u0026#39;函数\u0026#39; -v-on:事件名=\u0026#39;函数\u0026#39;，methods:{ handleClick(){},} -es6的对象写法 {变量，变量} {函数名(){},} # 属性指令v-bind -标签上的属性可以动态变化---》js的变量 -任意标签的任意属性上：name，id，class，style，src，href，自己定义的属性 -\u0026lt;p id=\u0026#39;id_p\u0026#39; class=\u0026#39;red\u0026#39; :aa=\u0026#39;aaaaa\u0026#39;\u0026gt;\u0026lt;/p\u0026gt; -img：src，a：href属性 -v-bind:src=\u0026#39;\u0026#39; -简写:src=\u0026#39;\u0026#39; # style和class的绑定 -class和style比较特殊的属性，控制样式 -:class= 字符串(空格表示多个类)，数组(合适)，对象(key值是类名，value值是布尔值) -:style= 字符串，数组(对象)，对象 -css中两个单词是用 font-size---》fontSize -\u0026lt;p :style=\u0026#39;{fontSize=\u0026#34;30px\u0026#34;}\u0026#39;\u0026gt;\u0026lt;/p\u0026gt; # 条件渲染 -v-if=条件 v-else-if=条件 v-else # 列表渲染v-for -放在标签上，循环多少次，标签就会显示多少次 -v-for=\u0026#39;item in 数组，对象，数字\u0026#39; # 购物车显示不显示小案例 # v-model的使用 -针对于input标签 :value=\u0026#39;变量\u0026#39;，单向数据绑定 -双向数据绑定：v-model=\u0026#39;变量\u0026#39; # blur，change，input事件 -input标签的 失去焦点，变化，输入内容就变化的事件 # 过滤案例 # 事件修饰符 -按钮只能点击一次 -只响应自己对事件 -阻止a标签跳转 -阻止事件冒泡 # 按键修饰符 -@keyup=\u0026#34;handleKey1\u0026#34;---》监控到用户点击那个键 表单控制\nv-model绑定：双向数据绑定 checkbox：单选:布尔和多选:数组 radio：单选:字符串 购物车案例\nv-for循环 插值语法放函数显示返回值： {{getprice()}} js循环的几种方式 checkbox的多选和单选 input的change事件 数量加减（插值语法可以直接放表达式） v-model进阶\nlazy，number，trim vue声明周期\nvue对象(vm)，vuecompoment对象(vc) 8个生命周期钩子函数，依次执行 created:有数据了，在此发送ajax请求，设置一些定时任务 destroyed：资源请理性的工作（清空定时器） 定时任务（setInterval），延迟任务（setTimeout） 前后端交互之jq的ajax\njquery的ajax\nfetch和axios发送请求\n补充：箭头函数\naxios发送get请求\naxios.get(url) axios发送post请求（请求头携带数据）\naxios.post(url,{name:\u0026rsquo;lqz\u0026rsquo;,age:19}) axios.post(url,json.stringify({name:\u0026rsquo;lqz\u0026rsquo;,age:19})) axios发送请求，请求头中带数据（jwt，认证session）\n1 2 3 4 5 axios.post(url, data, { headers: { \u0026#39;token\u0026#39;:\u0026#39;asdfads\u0026#39; } }) 显示电影小案例\n前后端交互的编码格式 urlencoded：form表单提交默认的格式，ajax提交默认格式 json:前后端分离项目常用的格式 form-data：上传文件使用这种格式 计算属性\n插值写函数，页面只要刷新，函数会重新运算，耗费资源\n1 2 3 computed:{ fucName(){} } 有缓存，直接把fucName当变量用，只有fucName函数的参数变化才重新运算\n监听属性\n只要被监听数据发送变化，就会触发某个函数的执行\n1 2 3 4 5 watch:{ name(){ 只要name属性发生变化，这个函数就会执行 } } 案例：过滤案例中输入内容变化就改变list属性的值\n局部和全局组件的定义\n自定义属性实现父传子\n在子组件上自定义的属性，传入父组件的值\n在子组件中的props定义属性\n1 2 3 \u0026lt;navbar :myname=\u0026#34;name\u0026#34; :age=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/navbar\u0026gt; props: [\u0026#39;myname\u0026#39;, \u0026#39;age\u0026#39;] 自定义事件实现子传父\nthis.$emit(事件名) 将子组件的值传递到父组件的事件触发的函数中 ref属性实现组件间通信\n放在普通标签，放在组件上 this.$refs.refname即可拿到标签对象或组件对象 动态组件\ncomponent标签通过is决定显示的组件是什么 插槽的使用\n不具名插槽 具名插槽 指定slot属性值 vue-cli创建项目并启动\nvue项目目录介绍\n","date":"2025-02-27T19:08:20+08:00","permalink":"https://yn0t1me.github.io/p/vue2/","title":"Vue2"},{"content":"当时跟着学的时候还没养成做笔记的习惯，因此该文是事后复习时写的，内容有些凌乱，见谅\n核心的功能模块\n认证模块，用户名密码登录或收集短信登录（60s有效） 角色管理，不同角色有不同权限和展示不同菜单 客户管理，对客户分级，客户的增删改查操作 交易中心 管理员给客户充值扣费 客户可以下单撤单 生成交易记录 对订单进行多维度搜索 wordker，执行订单并更新订单状态 单点知识 发送短信 阿里云短信服务来进行发送短信\n注册账号 开通服务 + 缴费 API服务、SDK服务 API接口 1 2 3 4 import requests # 处理签名和加密 res = requests.get(\u0026#34;......\u0026#34;,params={\u0026#34;key\u0026#34;:\u0026#34;xxx\u0026#34;,\u0026#39;token\u0026#39;:\u0026#39;...\u0026#39;}) - SDK服务 1 2 pip install aliyun-python-sdk-core pip install aliyun-python-sdk-dysmsapi 1 2 3 import xxxx xxxxx.send(...) 示例\n仅作参考，具体推荐依照官方文档进行配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from aliyunsdkcore.client import AcsClient from aliyunsdkcore.request import CommonRequest import json def sendSms(phone, message): # 替换为你的AccessKey信息 try: ACCESS_KEY_ID = \u0026#39;\u0026#39; ACCESS_KEY_SECRET = \u0026#39;\u0026#39; SIGN_NAME = \u0026#39;\u0026#39; # 签名名称 TEMPLATE_CODE = \u0026#39;\u0026#39; # 模板CODE PHONE_NUMBER = phone # 绑定的测试手机号 acs_client = AcsClient(ACCESS_KEY_ID, ACCESS_KEY_SECRET, TEMPLATE_CODE) request = CommonRequest() request.set_accept_format(\u0026#39;json\u0026#39;) request.set_domain(\u0026#39;dysmsapi.aliyuncs.com\u0026#39;) request.set_method(\u0026#39;POST\u0026#39;) request.set_version(\u0026#39;2017-05-25\u0026#39;) request.set_action_name(\u0026#39;SendSms\u0026#39;) # 设置短信模板参数 request.add_query_param(\u0026#39;PhoneNumbers\u0026#39;, PHONE_NUMBER) request.add_query_param(\u0026#39;SignName\u0026#39;, SIGN_NAME) request.add_query_param(\u0026#39;TemplateCode\u0026#39;, TEMPLATE_CODE) request.add_query_param(\u0026#39;TemplateParam\u0026#39;, json.dumps({\u0026#34;code\u0026#34;: message})) # 模板中的变量替换为实际的值 # 发送短信请求并获取返回结果 response = acs_client.do_action_with_exception(request) response_str = response.decode(\u0026#39;utf-8\u0026#39;) response_dict = json.loads(response_str) if response_dict[\u0026#39;Code\u0026#39;] == \u0026#34;OK\u0026#34;: return True return False except Exception as e: pass 权限和菜单管理 菜单 页面写死 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;html\u0026gt; {% if 角色 \u0026#34;管理员\u0026#34;%} \u0026lt;a href=\u0026#34;/xxx/x\u0026#34;\u0026gt;用户管理\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;/xxx/x\u0026#34;\u0026gt;级别管理\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;/xxx/x\u0026#34;\u0026gt;级别管理\u0026lt;/a\u0026gt; ... {% else %} \u0026lt;a href=\u0026#34;/xxx/x\u0026#34;\u0026gt;xxx管理\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;/xxx/x\u0026#34;\u0026gt;级别管理\u0026lt;/a\u0026gt; {% endif %} \u0026lt;/html\u0026gt; 菜单放在配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # settings.py ADMIN = [ {\u0026#34;title\u0026#34;:\u0026#34;用户管理\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;....\u0026#34; }, {\u0026#34;title\u0026#34;:\u0026#34;用户管理\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;....\u0026#34; }, {\u0026#34;title\u0026#34;:\u0026#34;用户管理\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;....\u0026#34; }, {\u0026#34;title\u0026#34;:\u0026#34;用户管理\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;....\u0026#34; }, ] USER = [ {\u0026#34;title\u0026#34;:\u0026#34;用户管理\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;....\u0026#34; }, {\u0026#34;title\u0026#34;:\u0026#34;用户管理\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;....\u0026#34; }, {\u0026#34;title\u0026#34;:\u0026#34;用户管理\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;....\u0026#34; }, {\u0026#34;title\u0026#34;:\u0026#34;用户管理\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;....\u0026#34; }, ] 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;html\u0026gt; {% if 角色 \u0026#34;管理员\u0026#34;%} {% for item in ADMIN%} \u0026lt;a href=\u0026#34;{{item.url}}\u0026#34;\u0026gt;{{item.title}}\u0026lt;/a\u0026gt; {%emdfor%} {% else %} {% for item in USER%} \u0026lt;a href=\u0026#34;{{item.url}}\u0026#34;\u0026gt;{{item.title}}\u0026lt;/a\u0026gt; {%emdfor%} {% endif %} \u0026lt;/html\u0026gt; 将菜单 + 角色写入数据库 1 2 3 4 # 在页面展示数据库 # 1.查询特定角色关联的所有的菜单 # 2.在页面上进行展示 如果选择配置文件的方式：\n菜单配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ADMIN = [ { \u0026#34;title\u0026#34;:\u0026#34;用户管理\u0026#34;, \u0026#34;children\u0026#34;:[ {\u0026#34;title\u0026#34;:\u0026#34;级别列表\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;....\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;level_list\u0026#34;,} {\u0026#34;title\u0026#34;:\u0026#34;级别列表\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;....\u0026#34;} {\u0026#34;title\u0026#34;:\u0026#34;级别列表\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;....\u0026#34;} ] }, { \u0026#34;title\u0026#34;:\u0026#34;订单管理\u0026#34;, \u0026#34;children\u0026#34;:[ {\u0026#34;title\u0026#34;:\u0026#34;订单列表\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;....\u0026#34;} {\u0026#34;title\u0026#34;:\u0026#34;订单列表\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;....\u0026#34;} {\u0026#34;title\u0026#34;:\u0026#34;订单列表\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;....\u0026#34;} ] }, ] 菜单选中和展开问题 1 2 3 1.获取当前用户请求的 URL pricepolicy/list/ 或 url对应的name 2. pricepolicy/list/ 配置 ADMIN中的URL -\u0026gt;默认选中 路径导导航问题 1 2 3 4 5 1.获取当前用户请求的 URL pricepolicy/list/ 或 url对应的name 2.获取上级，展示导航信息 3.设置菜单与下级关系 拓展：菜单多级关系\n权限 权限的判定，要考虑：正常的点击、非法的输入\n文件settings.py的方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 admin_permisions = { \u0026#34;level_list\u0026#34;:{...}, \u0026#34;level_edit\u0026#34;:{..., \u0026#39;parent\u0026#39;:\u0026#39;level_list\u0026#39;}, \u0026#34;level_add\u0026#34;:{... \u0026#39;parent\u0026#39;:\u0026#39;level_list\u0026#39;}, \u0026#34;level_delete\u0026#34;:{..\u0026#39;parent\u0026#39;:\u0026#39;level_list\u0026#39;.}, \u0026#34;user_list\u0026#34;:{...}, \u0026#34;user_edit\u0026#34;:{...}, \u0026#34;user_add\u0026#34;:{...}, \u0026#34;user_delete\u0026#34;:{...}, } user_permisions = { ... } 1 admin访问某个URL + 路由信息（name，namespace），获取当前URL /level/dedit/4/ -\u0026gt; 是否存在URL 1 在中间件中根据URL中的name进行权限的校验 数据库方式 实现的前置小知识 中间件 1 2 3 4 5 6 7 8 9 10 11 process_request，基于他实现用户是否已登录，继续；未登录则返回登录界面。 - return None，继续向后访问 - return 对象，直接返回。 process_view，权限校验 - return None，继续向后访问 - return 对象，直接返回。 - 在他的request对象中有 resolver_match ，包含当前请求的视图路由信息 .name-\u0026gt;sms_login admin = [\u0026#39;sms_login\u0026#39;,\u0026#34;xxx\u0026#34;] process_response 面向对象 1 2 mapping = {\u0026#34;1\u0026#34;: \u0026#34;ADMIN\u0026#34;, \u0026#34;2\u0026#34;: \u0026#34;CUSTOMER\u0026#34;} request.session[\u0026#39;user_info\u0026#39;] = {\u0026#39;role\u0026#39;: mapping[role], \u0026#39;name\u0026#39;: user_object.username, \u0026#39;id\u0026#39;: user_object.id} ajax请求 form表单 1 2 3 4 \u0026lt;form method=\u0026#39;get\u0026#39; action=\u0026#39;xxx\u0026#39; \u0026gt; \u0026lt;input /\u0026gt; \u0026lt;input type=\u0026#39;submit\u0026#39; /\u0026gt; \u0026lt;/form\u0026gt; ajax Ajax（Asynchronous JavaScript and XML）是一种在无需重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，本质上就是利用浏览器上XMLRequest\n基本步骤：\n创建XMLRequest对象 初始化请求：指定请求类型以及请求的URL 发送请求 处理响应 更新页面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; xhr = new XMLHttpRequest(); xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ // 已经接收到全部响应数据，执行以下操作 var data = xhr.responseText; console.log(data); } }; xhr.open(\u0026#39;POST\u0026#39;, \u0026#34;/test/\u0026#34;, true ); xhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded;\u0026#39;); xhr.send(\u0026#39;n1=1;n2=2;\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 利用jQuery类库，内部封装，使用简单了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;html\u0026gt; ... \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#39;jquery.js\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; $.ajax({ url:\u0026#34;....\u0026#34;, type:\u0026#34;post\u0026#34;, data:{n1:123,n2:456}, success:function(res){ console.log(res); } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 大致应用场景：\n提交数据，页面可以刷新 -\u0026gt; form表单 提交数据，页面不想刷新 -\u0026gt; ajax形式提交 csrftoken form表单 1 2 3 4 5 \u0026lt;form ...\u0026gt; {% csrf_token %} \u0026lt;!-- 表单字段 --\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; ajax方式 浏览器打开网址时，django在cookie中也给我们返回了一段值。\n1 2 3 4 5 6 7 8 9 10 11 $.ajax({ url:\u0026#34;...\u0026#34;, type:\u0026#34;get\u0026#34; data:{user:\u0026#34;wupeiqi\u0026#34;,pwd:\u0026#34;xxxx\u0026#34;}， header:{ \u0026#34;X-HTTP...\u0026#34;:\u0026#34;cookie中写的那段值\u0026#34; }, success:function(arg){ } }) 向后端发送请求 form - GET 1 2 3 \u0026lt;form method=\u0026#39;GET\u0026#39;\u0026gt; \u0026lt;/form\u0026gt; form - POST 1 2 3 4 \u0026lt;form method=\u0026#39;POST\u0026#39;\u0026gt; {% csrf_token %} ... \u0026lt;/form\u0026gt; ajax - GET 1 2 3 4 5 6 7 8 $.ajax({ url: \u0026#34;/xxx/xx\u0026#34;, type: \u0026#34;GET\u0026#34;, data: {mobile: \u0026#34;1888888\u0026#34;}, success: function (res) { console.log(res); } }) ajax - POST 1 2 3 4 5 6 7 8 9 10 11 $.ajax({ url: \u0026#34;/xxx/xx\u0026#34;, type: \u0026#34;POST\u0026#34;, data: {mobile: \u0026#34;1888888\u0026#34;}, headers:{ \u0026#34;X-CSRFTOKEN\u0026#34;:\u0026#34;....\u0026#34; }, success: function (res) { console.log(res); } }) ajax - PUT 1 2 3 4 5 6 7 8 9 10 11 $.ajax({ url: \u0026#34;/xxx/xx\u0026#34;, type: \u0026#34;PUT\u0026#34;, data: {mobile: \u0026#34;1888888\u0026#34;}, headers:{ \u0026#34;X-CSRFTOKEN\u0026#34;:\u0026#34;....\u0026#34; }, success: function (res) { console.log(res); } }) ajax - DELETE 1 2 3 4 5 6 7 8 9 10 11 $.ajax({ url: \u0026#34;/xxx/xx\u0026#34;, type: \u0026#34;DELETE\u0026#34;, data: {mobile: \u0026#34;1888888\u0026#34;}, headers:{ \u0026#34;X-CSRFTOKEN\u0026#34;:\u0026#34;....\u0026#34; }, success: function (res) { console.log(res); } }) ajax - serialize 携带所有参数，包括csrftoken\n1 2 3 4 5 6 7 $.ajax({ url:\u0026#34;/sms/login/\u0026#34;, type:\u0026#34;POST\u0026#34;, data:$(\u0026#34;#f1\u0026#34;).serialize() }) # 好处，不需要加csrf header csrf认证 请求体中 1 2 - 传统的form - jQuery $(\u0026#34;#smsForm\u0026#34;).serialize() + Ajax 请求体中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $.ajaxSetup({ beforeSend... }) $.ajax({ url:\u0026#34;...\u0026#34;, type:\u0026#34;GET\u0026#34;, data:{}, dataType:\u0026#34;JSON\u0026#34;, headers:{ ... }, success:function(res){ } }) django的自定义请求头 1 2 - 自动化添加 HTTP_ 前缀 - 自动化添加 HTTP_ 前缀，前端的-，转换成后端的_ form组件 自定义表单类 Django提供了两种自定义表单的方式：继承Form类和ModelForm类。前者你需要自定义表单中的字段，后者可以根据Django模型自动生成表单，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # app/forms.py # 自定义表单字段 from django import forms from .models import Contact class ContactForm1(forms.Form): name = forms.CharField(label=\u0026#34;Your Name\u0026#34;, max_length=255) email = forms.EmailField(label=\u0026#34;Email address\u0026#34;) # 根据模型创建 class ContactForm2(forms.ModelForm): class Meta: model = Contact fields = (\u0026#39;name\u0026#39;, \u0026#39;email\u0026#39;,) label用来给字段添加一个描述\n自定义错误字段信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from django import forms class LoginForm(forms.Form): username = forms.CharField( required=True, max_length=20, min_length=6, error_messages={ \u0026#39;required\u0026#39;: \u0026#39;用户名不能为空\u0026#39;, \u0026#39;max_length\u0026#39;: \u0026#39;用户名长度不得超过20个字符\u0026#39;, \u0026#39;min_length\u0026#39;: \u0026#39;用户名长度不得少于6个字符\u0026#39;, } ) password = forms.CharField( required=True, max_length=20, min_length=6, error_messages={ \u0026#39;required\u0026#39;: \u0026#39;密码不能为空\u0026#39;, \u0026#39;max_length\u0026#39;: \u0026#39;密码长度不得超过20个字符\u0026#39;, \u0026#39;min_length\u0026#39;: \u0026#39;密码长度不得少于6个字符\u0026#39;, } ) 对于基继承ModelForm类的表单, 我们可以在Meta选项下widget中来自定义错误信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from django.forms import ModelForm, Textarea from myapp.models import Author class AuthorForm(ModelForm): class Meta: model = Author fields = (\u0026#39;name\u0026#39;, \u0026#39;title\u0026#39;, \u0026#39;birth_date\u0026#39;) widgets = { \u0026#39;name\u0026#39;: Textarea(attrs={\u0026#39;cols\u0026#39;: 80, \u0026#39;rows\u0026#39;: 20}), # 关键是这一行 } labels = { \u0026#39;name\u0026#39;: \u0026#39;Author\u0026#39;, } help_texts = { \u0026#39;name\u0026#39;: \u0026#39;Some useful help text.\u0026#39;, } error_messages = { \u0026#39;name\u0026#39;: { \u0026#39;max_length\u0026#39;: \u0026#34;This writer\u0026#39;s name is too long.\u0026#34;, }, } 自定义表单输入widget Django表单的每个字段你都可以选择你喜欢的输入widget，比如多选，复选框。你还可以定义每个widget的css属性\n1 2 3 4 5 6 7 8 9 from django import forms class ContactForm(forms.Form): name = forms.CharField( max_length=255, widget=forms.Textarea( attrs={\u0026#39;class\u0026#39;: \u0026#39;custom\u0026#39;}, ), ) 表单的实例化与初始化 定义好一个表单类后，你就可以对其进行实例化或初始化。下面方法可以实例化一个空表单，但里面没有任何数据，可以通过 {{ form }}在模板中渲染\n1 form = ContactForm() # 空表单 有时我们需要对表单设置一些初始数据，我们可以通过initial方法或设置default_data，如下所示\n1 2 3 4 5 6 7 8 9 # initial方法初始化 form = ContactForm( initial={ \u0026#39;name\u0026#39;: \u0026#39;First and Last Name\u0026#39;, },) # default_data默认值 default_data = {\u0026#39;name\u0026#39;: \u0026#39;John\u0026#39;, \u0026#39;email\u0026#39;: \u0026#39;someone@hotmail.com\u0026#39;, } form = ContactForm(default_data) 用户提交的数据可以通过以下方法与表单结合，生成与数据结合过的表单(Bound forms)。Django只能对Bound forms进行验证\n1 form = ContactForm(data=request.POST, files=request.FILES) 其编辑修改类应用场景中，我们还要给表单提供现有对象实例的数据，而不是渲染一张空表单，这时我们可这么做。该方法仅适用于由模型创建的ModelForm，而不适用于自定义的表单\n1 2 contact = Contact.objects.get(id=1) form = ContactForm(instance = contact, data=request.POST) 表单的使用 继承Form类 编写字段 自定义编写\n生成HTML标签 + 携带数据 1 2 - 保留原来提交的数据，不再担心form表单提交时页面刷新。 - 显示默认值，做编辑页面显示默认值。 数据校验，对用户提交的数据格式校验 1 2 3 4 5 form = LoginForm(data=request.POST) if form.is_valid(): print(form.cleaned_data) else: print(form.errors) 继承ModelForm类 编写字段 选择字段\n1 2 3 4 5 6 class LevelModelForm(forms.ModelForm): class Meta: model = models.Level # 指定引用的表名 fields = [\u0026#39;title\u0026#39;, \u0026#39;percent\u0026#39;] # 引用的字段 fields = \u0026#34;__all__\u0026#34; # 引用全部字段 exclude = [\u0026#39;active\u0026#39;] # 排除某一字段 添加自定义字段\n1 2 3 4 5 6 7 8 class LevelModelForm(BootStrapForm, forms.ModelForm): xxx = forms.CharField(label=\u0026#39;xxx\u0026#39;) class Meta: model = models.Level # fields = \u0026#34;__all__\u0026#34; # exclude = [\u0026#39;active\u0026#39;] fields = [\u0026#39;title\u0026#39;, \u0026#39;xxx\u0026#39;, \u0026#39;percent\u0026#39;, ] 重写字段\n1 2 3 4 5 6 7 8 class LevelModelForm(BootStrapForm, forms.ModelForm): title = forms.ChoiceField(label=\u0026#39;xxx\u0026#39;, choices=((1, \u0026#34;xxx\u0026#34;), (2, \u0026#34;xxxxxx\u0026#34;))) class Meta: model = models.Level # fields = \u0026#34;__all__\u0026#34; # exclude = [\u0026#39;active\u0026#39;] fields = [\u0026#39;title\u0026#39;, \u0026#39;percent\u0026#39;, ] 生成HTML标签 + 插件 + 参数的配置 1 2 3 4 5 6 7 class LevelModelForm(BootStrapForm, forms.ModelForm): class Meta: model = models.Level fields = [\u0026#39;title\u0026#39;, \u0026#39;percent\u0026#39;, ] widgets = { \u0026#39;name\u0026#39;: forms.PasswordInput(render_value=True) } 表单验证 1 2 3 4 5 6 7 8 9 class LevelModelForm(BootStrapForm, forms.ModelForm): title = forms.CharField(validators=[]) class Meta: model = models.Level fields = [\u0026#39;title\u0026#39;, \u0026#39;percent\u0026#39;, ] def clean_percent(self): value = self.cleaned_data[\u0026#39;percent\u0026#39;] return value 保存更新 1 2 form = LevelModelForm(data=request.POST) form.save() 1 2 form = LevelModelForm(data=request.POST,install=对象) form.save() 1 2 3 4 5 6 # 输入字段少于数据库，手动添加 # 输入字段多余数据库b form = LevelModelForm(data=request.POST) # 或有 ,install=对象 form.instance.percent = 10 form.save() form的校验流程 每个字段的内部：required + validators + min_length + max_length 每个字段的钩子方法 1 2 3 4 5 6 7 8 9 10 def clean_username(self): user = self.cleaned_data[\u0026#39;username\u0026#39;] # 校验规则 # 校验失败 if len(user) \u0026lt; 3: from django.core.exceptions import ValidationError raise ValidationError(\u0026#34;用户名格式错误\u0026#34;) return user print(form.cleaned_data) clean 1 2 3 4 5 6 def clean(self): # 对所有值进行校验 from django.core.exceptions import ValidationError # 1.不返回值，默认 self.cleaned_data # 2.返回值，self.cleaned_data=返回的值 # 3.报错，ValidationError -\u0026gt; self.add_error(None, e) _post_clean 1 2 def _post_clean(self): pass form目的：生成标签 + 校验 生成标签 循环 + 单独某个字段 label页面显示文本信息 自定义错误位置，position 校验 定义 每个字段校验 字段上定义校验规则 正则、空、长度 clean_方法名 1 2 3 4 校验成功： self.cleaned_data[\u0026#34;字段\u0026#34;] = 值 校验失败 self.errors[\u0026#34;字段\u0026#34;] = 错误 * 所有字段校验 + clean 1 2 3 4 5 6 7 8 9 try: cleaned_data = self.clean() except ValidationError as e: self.add_error(None, e) else: if cleaned_data is not None: self.cleaned_data = cleaned_data self.errors[\u0026#34;__all__\u0026#34;] = 错误 + _post_clean - 校验源码 * form.is_valid * form.errors * form.fuull_clean() - 业务校验 1 2 3 4 5 6 7 8 9 10 11 form = 对象 if not form.is_valid(): print(form.errors) form.errors.username.0 form.errors.__call__.0 -\u0026gt; 模板语言中 form.errors.__ 不支持 form.non_field_errors() \u0026lt;==\u0026gt; form.errors.__call__ 在页面上去适合的位置显示错误信息 else: print(form.cleaned_data) ... - 拓展 1 2 如果想要让某个错误信息，展示在特定的字段旁，就可以使用： form.add_error(\u0026#34;password\u0026#34;, \u0026#34;用户名或密码错误\u0026#34;) form样式设置 思考：无论在使用Form还是ModelForm时，想要让页面好看，就需要将每个字段的插件中给他设置form-control样式\n循环写入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class LevelForm(forms.Form): title = forms.CharField( label=\u0026#34;标题\u0026#34;, required=True, # widget=forms.TextInput(attrs={\u0026#34;class\u0026#34;: \u0026#34;form-control\u0026#34;, \u0026#39;placeholder\u0026#39;: \u0026#34;请输入标题\u0026#34;}), ) percent = forms.CharField( label=\u0026#34;折扣\u0026#34;, required=True, help_text=\u0026#34;填入0-100整数表示百分比，例如：90，表示90%\u0026#34; ) def __init__(self,*args,**kwargs): super().__init__(*args,**kwargs) # {\u0026#39;title\u0026#39;:对象,\u0026#34;percent\u0026#34;:对象} for name,field in self.fields.items(): field.widget.attrs[\u0026#39;class\u0026#39;] = \u0026#34;form-control\u0026#34; field.widget.attrs[\u0026#39;placeholder\u0026#39;] = \u0026#34;请输入{}\u0026#34;.format(field.label) 1 2 3 4 5 6 7 8 9 10 11 12 class LevelModelForm(forms.ModelForm): class Meta: model = models.Level fields = [\u0026#39;title\u0026#39;, \u0026#39;percent\u0026#39;] def __init__(self,*args,**kwargs): super().__init__(*args,**kwargs) # {\u0026#39;title\u0026#39;:对象,\u0026#34;percent\u0026#34;:对象} for name,field in self.fields.items(): field.widget.attrs[\u0026#39;class\u0026#39;] = \u0026#34;form-control\u0026#34; field.widget.attrs[\u0026#39;placeholder\u0026#39;] = \u0026#34;请输入{}\u0026#34;.format(field.label) Bootstrap样式优化 super关键字 1 2 super是找父类中的成员吗？不准确。 super,就是根据类的继承关系（mro），逐步晚上找。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Base: def f1(self): print(\u0026#34;Base\u0026#34;) class Foo(Base): pass class Bar(Foo): def f1(self): print(\u0026#34;Bar\u0026#34;) super().f1() obj = Bar() # [Bar,Foo,Base] obj.f1() # Bar Base 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Base: def f1(self): print(\u0026#34;Base\u0026#34;) class Foo: def f1(self): print(\u0026#34;Foo\u0026#34;) super().f1() class Bar(Foo,Base): def f1(self): print(\u0026#34;Bar\u0026#34;) super().f1() obj = Bar() # [Bar,Foo,Base] obj.f1() # Bar Foo Base 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Base: def f1(self): print(\u0026#34;Base\u0026#34;) class Foo: def f1(self): print(\u0026#34;Foo\u0026#34;) super().f1() class Bar(Foo,Base): def f1(self): print(\u0026#34;Bar\u0026#34;) super().f1() obj = Foo() obj.f1() # Foo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from django.shortcuts import render, redirect from web import models from django import forms from django.urls import reverse class BootStrapForm: def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) # {\u0026#39;title\u0026#39;:对象,\u0026#34;percent\u0026#34;:对象} for name, field in self.fields.items(): field.widget.attrs[\u0026#39;class\u0026#39;] = \u0026#34;form-control\u0026#34; field.widget.attrs[\u0026#39;placeholder\u0026#39;] = \u0026#34;请输入{}\u0026#34;.format(field.label) class LevelForm(BootStrapForm, forms.Form): title = forms.CharField( label=\u0026#34;标题\u0026#34;, required=True, ) percent = forms.CharField( label=\u0026#34;折扣\u0026#34;, required=True, help_text=\u0026#34;填入0-100整数表示百分比，例如：90，表示90%\u0026#34; ) class LevelModelForm(BootStrapForm, forms.ModelForm): class Meta: model = models.Level fields = [\u0026#39;title\u0026#39;, \u0026#39;percent\u0026#39;] 局部去除bootstrap样式 + 修改字段样式 原理：\nform组件基本操作 显示默认值 Form 1 form = LevelForm(initial={\u0026#39;title\u0026#39;: \u0026#34;xxx\u0026#34;}) ModelForm 1 2 3 4 form = LevelForm(initial={\u0026#39;title\u0026#39;: \u0026#34;xxx\u0026#34;}) level_object = models.Level.objects.filter(id=pk).first() form = LevelModelForm(instance=level_object) Model 修改查询条件 models中的limit_choice_to字段 自定义choices和queryset 传入request以便后续条件复杂化\n模板 母版 inclusion_tag 队列 rabbitMQ，Linux命令+服务构建+python代码。 kafka，Linux命令+服务构建+python代码。 redis的列表 基于redis实现上述功能的过程和代码示例：\n安装redis 启动redis python操作redis 1 pip install redis 1 2 3 4 5 6 7 8 import redis conn = redis.Redis(host=\u0026#39;127.0.0.1\u0026#39;, port=6379, password=\u0026#39;qwe123\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) # 短信验证码 conn.set(\u0026#39;15131255089\u0026#39;, 9999, ex=10) value = conn.get(\u0026#39;15131255089\u0026#39;) print(value) 1 2 3 4 5 6 7 8 9 10 11 import redis conn = redis.Redis(host=\u0026#39;127.0.0.1\u0026#39;, port=6379, password=\u0026#39;qwe123\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) # 放值 # conn.lpush(\u0026#39;my_queue\u0026#39;, \u0026#34;root\u0026#34;) # conn.lpush(\u0026#39;my_queue\u0026#39;, \u0026#34;good\u0026#34;) # 取值 v1 = conn.brpop(\u0026#34;my_queue\u0026#34;, timeout=5) print(v1) worker和线性池 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 1.去redis中获取任务 # 2.再将此订单在数据库中的状态修改为 执行中 # 3.获取任务详细： 视频，10000 # 4.线程池或协程 from concurrent.futures import ThreadPoolExecutor def task(video_url): # 根据视频地址实现刷播放 # .. pass pool = ThreadPoolExecutor(50) for i in range(10000): pool.submit(task, \u0026#34;视频地址\u0026#34;) pool.shutdown() # 卡主，等待所有的任务执行完毕。 # 5.更新订单状态，已完成 分页组件 选项生成 页码逻辑和动态页码 分页组件的封装 优化 加入首页、尾页、上一页、下一页\nquerydict 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 http://127.0.0.1:8000/customer/list/?filter=wupeiqi\u0026amp;age=19 request.GET 对象 QueryDict类型 1.默认QueryDict不允许被修改 _mutable=False request.GET._mutable = True 2.设置值 request.GET.setlist(\u0026#34;name\u0026#34;,[123]) # filter=wupeiqi\u0026amp;age=19\u0026amp;name=123 request.GET.setlist(\u0026#34;name\u0026#34;,[123,32]) # filter=wupeiqi\u0026amp;age=19\u0026amp;name=123\u0026amp;name=32 3.调用urlencode方法，可以拼接 paramString = request.GET.urlencode() print(paramString) \u0026#34;filter=wupeiqi\u0026amp;age=19\u0026amp;name=123\u0026#34; ------测试----- import copy query_dict = copy.deepcopy(request.GET) query_dict._mutable = True query_dict.setlist(\u0026#39;page\u0026#39;,[1]) paramString = query_dict.urlencode() \u0026#34;filter=wupeiqi\u0026amp;age=19\u0026amp;page=1\u0026#34; query_dict._mutable = True query_dict.setlist(\u0026#39;page\u0026#39;,[2]) paramString = query_dict.urlencode() \u0026#34;filter=wupeiqi\u0026amp;age=19\u0026amp;page=2\u0026#34; request.GET._mutable = True request.GET.setlist(\u0026#39;page\u0026#39;,[3]) paramString = request.GET.urlencode() \u0026#34;filter=wupeiqi\u0026amp;age=19\u0026amp;page=3\u0026#34; 解决url参数携带问题 最终版 搜索组件 Q对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 django中有个Q对象 models.XX.objects.filter(id=1) models.XX.objects.filter(id__gt=1) models.XX.objects.filter(id__gte=1) models.XX.objects.filter(name__contains=\u0026#34;xx\u0026#34;) models.XX.objects.filter(id=1, age=19) 方式1： models.XX.objects.filter( Q(id=10) )\tmodels.XX.objects.filter( Q(id=10)\u0026amp;Q(age=19) )\tmodels.XX.objects.filter( Q(id=10)|Q(age=19) )\tmodels.XX.objects.filter( Q(id__gt=10)|Q(age__lte=19) )\tmodels.XX.objects.filter( Q( Q(id__gt=10)|Q(age__lte=19) ) \u0026amp; Q(name=19))\t方式2： q1 = Q() q1.connector = \u0026#39;OR\u0026#39; q1.children.append((\u0026#39;id\u0026#39;, 1)) q1.children.append((\u0026#39;age\u0026#39;, 10)) id=1 or age=10 q2 = Q() q2.connector = \u0026#39;ADN\u0026#39; q2.children.append((\u0026#39;size__gt\u0026#39;, 10)) q2.children.append((\u0026#39;name\u0026#39;, \u0026#39;root\u0026#39;)) size\u0026gt;10 and name=root con = Q() con.add(q1, \u0026#39;AND\u0026#39;) con.add(q2, \u0026#39;AND\u0026#39;) (id=1 or age=10 ) AND (size\u0026gt;10 and name=root) 普通搜索 组合搜索 权限按钮 没权限就不要显示\n在模板中自定义方法 filter 1 \u0026#34;xxxx\u0026#34;|upper simple_tag 不能用if做条件\n1 {% xxxx x1 x2 x3 %} 1 2 def xxx(): return \u0026#34;\u0026#34; inclusion_tag 1 2 def xxx(): return {\u0026#39;v1\u0026#39;:xx,\u0026#39;v2\u0026#39;:xx} 1 \u0026lt;h1\u0026gt;{{v1}}\u0026lt;/h1\u0026gt; 反向生成URL 1 2 3 4 5 6 7 8 path(\u0026#39;login/\u0026#39;, account.login, name=\u0026#34;login\u0026#34;) reverse(\u0026#34;login\u0026#34;) path(\u0026#39;level/edit/\u0026lt;int:pk\u0026gt;/\u0026#39;, level.level_edit,name=\u0026#34;level_edit\u0026#34;) reverse(\u0026#34;level/edit\u0026#34;,kwargs={\u0026#34;pk\u0026#34;:123}) re_path(r\u0026#39;level/(\\d+)/\u0026#39;, level.level_edit,name=\u0026#34;level\u0026#34;) reverse(\u0026#34;level/edit\u0026#34;,wargs=(111)) 实现 权限的粒度控制在按钮，根据是否具有权限来决定是否展示 响应按钮。\n1 {% permission request \u0026#34;user_add\u0026#34; v1=111 v2=111 %} 1 2 3 4 5 6 7 8 9 10 11 @register.simple_tag def demo(request, name, *args, **kwargs): print(request, name, args, kwargs) # 1.读取用户角色，获取权限字典 # 2.判断是否有权限 # 3.无权限，返回空 # 4.有权限，根据name生成URL return \u0026#34;....\u0026#34; 1 2 3 生成内容分为按钮的生成和表单中td标签的生成和th标点的生成 客户的增删改查与价格策略的差不多，删除操作都是生成一个cid在标签里后续通过js发送至后端， 但级别管理是通过url:level/delete/1来接收pk然后直接删除，没有模态框等操作，因此重写delete_url_permission方法 跳转链接 在生成URL时，需要读取当前URL中的参数并构造URL。例如：\n当前URL\n1 http://127.0.0.1:8000/customer/list/?keyword=xinchen\u0026amp;page=8 构造当前页面URL\n1 http://127.0.0.1:8000/customer/edit/1/?_filter=keyword%3Dxinchen%26page%3D8 1 2 3 4 5 6 param = request.GET.urlencode() # keyword=xinchen\u0026amp;page=8 new_query_dict = QueryDict(mutable=True) new_query_dict[\u0026#39;_filter\u0026#39;] = param new_query_dict.urlencode() _filter= 跳转回来时\n1 http://127.0.0.1:8000/customer/list/?keyword=xinchen\u0026amp;page=8 1 2 3 4 5 6 def policy_edit(request, pk): ... base_url = reverse(name, args=args, kwargs=kwargs) param_url = request.GET.get(\u0026#39;_filter\u0026#39;) url = \u0026#34;{}?{}\u0026#34;.format(base_url,param_url) return redirect(url) 事务 介绍 innodb引擎中支持事务，myisam不支持\n例如：A 给 B 转账 100，那就会涉及2个步骤。\nA 账户 减100 B 账户 加 100 这两个步骤必须同时完成才算完成，并且如果第一个完成、第二步失败，还是回滚到初始状态。\n事务，就是来解决这种情况的。 大白话：要成功都成功；要失败都失败。\n事务的具有四大特性（ACID）：\n原子性（Atomicity） 1 原子性是指事务包含的所有操作不可分割，要么全部成功，要么全部失败回滚。 一致性（Consistency） 1 执行的前后数据的完整性保持一致。 隔离性（Isolation） 1 一个事务执行的过程中,不应该受到其他事务的干扰。 持久性（Durability） 1 事务一旦结束,数据就持久到数据库 MySQL客户端 设置隔离级别 1 2 3 4 5 6 7 NSACTION ISOLATION LEVEL [隔离级别]; 常见隔离级别： READ UNCOMMITTED：允许读取未提交的数据。 READ COMMITTED：只能读取已提交的数据。 REPEATABLE READ：确保在同一事务中多次读取同样的记录结果是一致的。 SERIALIZABLE：最高的隔离级别，完全串行化的事务。 开始事务 1 2 START TRANSACTION; # BEGIN; 执行数据库操作 1 在事务中，你可以执行多个数据库操作，如INSERT、UPDATE、DELETE等。这些操作将被包含在当前事务中 提交或回滚事务 1 2 3 4 5 提交事务 COMMIT; 回滚所有操作 ROLLBACK; Python代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import pymysql conn = pymysql.connect(host=\u0026#39;127.0.0.1\u0026#39;, port=3306, user=\u0026#39;root\u0026#39;, passwd=\u0026#39;root123\u0026#39;, charset=\u0026#34;utf8\u0026#34;, db=\u0026#39;userdb\u0026#39;) cursor = conn.cursor() # 开启事务 conn.begin() try: cursor.execute(\u0026#34;update users set amount=1 where id=1\u0026#34;) int(\u0026#39;asdf\u0026#39;) cursor.execute(\u0026#34;update tran set amount=2 where id=2\u0026#34;) except Exception as e: # 回滚 print(\u0026#34;回滚\u0026#34;) conn.rollback() else: # 提交 print(\u0026#34;提交\u0026#34;) conn.commit() cursor.close() conn.close() Django操作 1 2 3 4 5 from django.db import transaction with transaction.atomic(): # 数据库操作A # 数据库操作B 锁 介绍 在用MySQL时，不知你是否会疑问：同时有很多做更新、插入、删除动作，MySQL如何保证数据不出错呢？\nMySQL中自带了锁的功能，可以帮助我们实现开发过程中遇到的同时处理数据的情况。对于数据库中的锁，从锁的范围来讲有：\n表级锁，即A操作表时，其他人对整个表都不能操作，等待A操作完之后，才能继续。 行级锁，即A操作表时，其他人对指定的行数据不能操作，其他行可以操作，等待A操作完之后，才能继续。 1 2 3 4 5 MYISAM支持表锁，不支持行锁； InnoDB引擎支持行锁和表锁。 即：在MYISAM下如果要加锁，无论怎么加都会是表锁。 在InnoDB引擎支持下如果是基于索引查询的数据则是行级锁，否则就是表锁。 所以，一般情况下我们会选择使用innodb引擎，并且在 搜索 时也会使用索引（命中索引）。\n在innodb引擎中，update、insert、delete的行为内部都会先申请锁（排它锁），申请到之后才执行相关操作，最后再释放锁。\n所以，当多个人同时像数据库执行：insert、update、delete等操作时，内部加锁后会排队逐一执行。\n而select则默认不会申请锁。\n如果，你想要让select去申请锁，则需要配合 事务 + 特殊语法来实现。\nfor update，排它锁，加锁之后，其他不可以读写\n1 2 3 begin; select * from L1 where name=\u0026#34;武沛齐\u0026#34; for update; -- name列不是索引（表锁） commit; 1 2 3 begin; -- 或者 start transaction; select * from L1 where id=1 for update;\t-- id列是索引（行锁） commit; 基于Python代码示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import pymysql import threading def task(): conn = pymysql.connect(host=\u0026#39;127.0.0.1\u0026#39;, port=3306, user=\u0026#39;root\u0026#39;, passwd=\u0026#39;root123\u0026#39;, charset=\u0026#34;utf8\u0026#34;, db=\u0026#39;userdb\u0026#39;) cursor = conn.cursor(pymysql.cursors.DictCursor) # cursor = conn.cursor() # 开启事务 conn.begin() cursor.execute(\u0026#34;select id,age from tran where id=2 for update\u0026#34;) # fetchall ( {\u0026#34;id\u0026#34;:1,\u0026#34;age\u0026#34;:10},{\u0026#34;id\u0026#34;:2,\u0026#34;age\u0026#34;:10}, ) ((1,10),(2,10)) # {\u0026#34;id\u0026#34;:1,\u0026#34;age\u0026#34;:10} (1,10) result = cursor.fetchone() current_age = result[\u0026#39;age\u0026#39;] if current_age \u0026gt; 0: cursor.execute(\u0026#34;update tran set age=age-1 where id=2\u0026#34;) else: print(\u0026#34;已售罄\u0026#34;) conn.commit() cursor.close() conn.close() def run(): for i in range(5): t = threading.Thread(target=task) t.start() if __name__ == \u0026#39;__main__\u0026#39;: run() Message组件 配置 1 2 3 # MESSAGE_STORAGE = \u0026#39;django.contrib.messages.storage.fallback.FallbackStorage\u0026#39; # MESSAGE_STORAGE = \u0026#39;django.contrib.messages.storage.cookie.CookieStorage\u0026#39; MESSAGE_STORAGE = \u0026#39;django.contrib.messages.storage.session.SessionStorage\u0026#39; 如图四个位置\n读取值 1 2 3 4 from django.contrib.messages.api import get_messages messages = get_messages(request) for msg in messages: print(msg) 1 2 3 4 5 \u0026lt;ul\u0026gt; {% for message in messages %} \u0026lt;li\u0026gt;{{ message.tags }} {{ message }}\u0026lt;/li\u0026gt; {% endfor %} \u0026lt;/ul\u0026gt; 源码分析 前戏：message是一个对象（包裹）。\n1 2 3 4 5 6 7 8 9 10 v1 = \u0026#34;wupeiqi\u0026#34; v2 = [\u0026#34;武沛齐\u0026#34;,123] class Message(object): def __init__(self, level, message, extra_tags=None): self.level = int(level) self.message = message self.extra_tags = extra_tags obj = Message(10,\u0026#34;哈哈哈哈\u0026#34;,\u0026#34;123\u0026#34;) 1 2 3 from django.contrib import messages messages.add_message(reqeust, messages.ERROR, \u0026#34;删除成功1\u0026#34;) messages.add_message(reqeust, messages.SUCCESS, \u0026#34;删除成功2\u0026#34;, extra_tags=\u0026#34;哈哈哈\u0026#34;) 【设置】中间件process_request加载 【设置】在视图函数中往message中写入值（内存） 【设置】中间件process_response，将内存中新增的数据写入到数据源 【新页面】中间件process_request加载 【新页面】在视图函数或模板中读取message中的信息（老的数据源加载的+新增的） 【设置】中间件process_response 1 2 used = True，则只保存新增部分。 added_new = True，老的数据源加载的+新增的都重新保存到数据源。 流程分析：\n1.1 process_request 1 给request._message赋值了一个SessionStorage对象 1.2 删除视图 1.3 request_response 2.1 process_request + 列表视图 2.2 request_response 组合搜索 具体实现：略\n使用 在视图函数中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from django.shortcuts import render from web import models from utils.pager import Pagination from django.db.models import Q from utils.group import Option, NbSearchGroup def my_transaction_list(request): \u0026#34;\u0026#34;\u0026#34;我的交易记录\u0026#34;\u0026#34;\u0026#34; # 第一步：配置和传参 search_group = NbSearchGroup( request, models.TransactionRecord, Option(\u0026#39;charge_type\u0026#39;), # choice ) # 第二步：获取条件 queryset = models.TransactionRecord.objects.filter(**search_group.get_condition) pager = Pagination(request, queryset) # 第三步：传入前端页面 context = { \u0026#34;pager\u0026#34;: pager, \u0026#34;keyword\u0026#34;: keyword, \u0026#34;search_group_row_list\u0026#34;: search_group } return render(request, \u0026#34;my_transaction_list.html\u0026#34;, context) 1 2 #母版 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{% static \u0026#39;css/search-group.css\u0026#39; %}\u0026#34;\u0026gt; 模板\n1 2 3 {% block content %} {% include \u0026#39;include/search_group.html\u0026#39; %} {% endblock %} 杂 在全局变量中定义自己的专属配置 1 2 from django.conf import settings 在settings文件中定义专属配置（名称必须大写） 面向对象小知识 super关键字 1 2 super是找父类中的成员吗？不准确。 super,就是根据类的继承关系（mro），逐步晚上找。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Base: def f1(self): print(\u0026#34;Base\u0026#34;) class Foo(Base): pass class Bar(Foo): def f1(self): print(\u0026#34;Bar\u0026#34;) super().f1() obj = Bar() # [Bar,Foo,Base] obj.f1() # Bar Base 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Base: def f1(self): print(\u0026#34;Base\u0026#34;) class Foo: def f1(self): print(\u0026#34;Foo\u0026#34;) super().f1() class Bar(Foo,Base): def f1(self): print(\u0026#34;Bar\u0026#34;) super().f1() obj = Bar() # [Bar,Foo,Base] obj.f1() # Bar Foo Base 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Base: def f1(self): print(\u0026#34;Base\u0026#34;) class Foo: def f1(self): print(\u0026#34;Foo\u0026#34;) super().f1() class Bar(Foo,Base): def f1(self): print(\u0026#34;Bar\u0026#34;) super().f1() obj = Foo() obj.f1() # Foo 项目 初始化基本流程：\n新建项目、虚拟环境、pip、project、app 新建数据库、配置数据库连接、精简化django 创建表结构（注册app、注释admin） urls.py路由配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 # from django.contrib import admin from django.urls import path from web.views import account from web.views import level from web.views import customer from web.views import policy from web.views import my_order from web.views import my_transaction urlpatterns = [ # path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;login/\u0026#39;, account.login, name=\u0026#34;login\u0026#34;), path(\u0026#39;sms/login/\u0026#39;, account.sms_login, name=\u0026#34;sms_login\u0026#34;), path(\u0026#39;sms/send/\u0026#39;, account.sms_send, name=\u0026#34;sms_send\u0026#34;), path(\u0026#39;logout/\u0026#39;, account.logout, name=\u0026#34;logout\u0026#34;), path(\u0026#39;home/\u0026#39;, account.home, name=\u0026#34;home\u0026#34;), path(\u0026#39;level/list/\u0026#39;, level.level_list, name=\u0026#34;level_list\u0026#34;), path(\u0026#39;level/add/\u0026#39;, level.level_add, name=\u0026#34;level_add\u0026#34;), path(\u0026#39;level/edit/\u0026lt;int:pk\u0026gt;/\u0026#39;, level.level_edit, name=\u0026#34;level_edit\u0026#34;), path(\u0026#39;level/delete/\u0026lt;int:pk\u0026gt;/\u0026#39;, level.level_delete, name=\u0026#34;level_delete\u0026#34;), path(\u0026#39;customer/list/\u0026#39;, customer.customer_list, name=\u0026#34;customer_list\u0026#34;), path(\u0026#39;customer/add/\u0026#39;, customer.customer_add, name=\u0026#34;customer_add\u0026#34;), path(\u0026#39;customer/edit/\u0026lt;int:pk\u0026gt;/\u0026#39;, customer.customer_edit, name=\u0026#34;customer_edit\u0026#34;), path(\u0026#39;customer/reset/\u0026lt;int:pk\u0026gt;/\u0026#39;, customer.customer_reset, name=\u0026#34;customer_reset\u0026#34;), path(\u0026#39;customer/delete/\u0026#39;, customer.customer_delete, name=\u0026#34;customer_delete\u0026#34;), path(\u0026#39;customer/charge/\u0026lt;int:pk\u0026gt;/\u0026#39;, customer.customer_charge, name=\u0026#34;customer_charge\u0026#34;), path(\u0026#39;customer/charge/\u0026lt;int:pk\u0026gt;/add\u0026#39;, customer.customer_charge_add, name=\u0026#34;customer_charge_add\u0026#34;), path(\u0026#39;policy/list/\u0026#39;, policy.policy_list, name=\u0026#34;policy_list\u0026#34;), path(\u0026#39;policy/add/\u0026#39;, policy.policy_add, name=\u0026#34;policy_add\u0026#34;), path(\u0026#39;policy/edit/\u0026lt;int:pk\u0026gt;/\u0026#39;, policy.policy_edit, name=\u0026#34;policy_edit\u0026#34;), path(\u0026#39;policy/delete/\u0026#39;, policy.policy_delete, name=\u0026#34;policy_delete\u0026#34;), path(\u0026#39;my/order/list/\u0026#39;, my_order.my_order_list, name=\u0026#34;my_order_list\u0026#34;), path(\u0026#39;my/order/add/\u0026#39;, my_order.my_order_add, name=\u0026#34;my_order_add\u0026#34;), path(\u0026#39;my/order/cancel/\u0026lt;int:pk\u0026gt;/\u0026#39;, my_order.my_order_cancel, name=\u0026#34;my_order_cancel\u0026#34;), path(\u0026#39;my/transaction/list/\u0026#39;, my_transaction.my_transaction_list, name=\u0026#34;my_transaction_list\u0026#34;), path(\u0026#39;transaction/list/\u0026#39;, my_transaction.transaction_list, name=\u0026#34;transaction_list\u0026#34;), ] settings.py配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 from pathlib import Path # Build paths inside the project like this: BASE_DIR / \u0026#39;subdir\u0026#39;. BASE_DIR = Path(__file__).resolve().parent.parent # Quick-start development settings - unsuitable for production # See https://docs.djangoproject.com/en/3.2/howto/deployment/checklist/ # SECURITY WARNING: keep the secret key used in production secret! SECRET_KEY = \u0026#39;django-insecure-9pt%1b%f2*\u0026amp;*)ipcfmzec\u0026amp;69r(e(q#(2m-$yx1m85g-4-pi%wz\u0026#39; # SECURITY WARNING: don\u0026#39;t run with debug turned on in production! DEBUG = True ALLOWED_HOSTS = [] # Application definition INSTALLED_APPS = [ # \u0026#39;django.contrib.admin\u0026#39;, # \u0026#39;django.contrib.auth\u0026#39;, # \u0026#39;django.contrib.contenttypes\u0026#39;, # \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;web.apps.WebConfig\u0026#39; ] MIDDLEWARE = [ # \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, # \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, \u0026#39;utils.md.AuthMiddleware\u0026#39; ] ROOT_URLCONF = \u0026#39;day06.urls\u0026#39; TEMPLATES = [ { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.template.backends.django.DjangoTemplates\u0026#39;, \u0026#39;DIRS\u0026#39;: [], \u0026#39;APP_DIRS\u0026#39;: True, \u0026#39;OPTIONS\u0026#39;: { \u0026#39;context_processors\u0026#39;: [ \u0026#39;django.template.context_processors.debug\u0026#39;, \u0026#39;django.template.context_processors.request\u0026#39;, # \u0026#39;django.contrib.auth.context_processors.auth\u0026#39;, \u0026#39;django.contrib.messages.context_processors.messages\u0026#39;, ], }, }, ] WSGI_APPLICATION = \u0026#39;day06.wsgi.application\u0026#39; # Database # https://docs.djangoproject.com/en/3.2/ref/settings/#databases DATABASES = { } # Password validation # https://docs.djangoproject.com/en/3.2/ref/settings/#auth-password-validators AUTH_PASSWORD_VALIDATORS = [ { \u0026#39;NAME\u0026#39;: \u0026#39;django.contrib.auth.password_validation.UserAttributeSimilarityValidator\u0026#39;, }, { \u0026#39;NAME\u0026#39;: \u0026#39;django.contrib.auth.password_validation.MinimumLengthValidator\u0026#39;, }, { \u0026#39;NAME\u0026#39;: \u0026#39;django.contrib.auth.password_validation.CommonPasswordValidator\u0026#39;, }, { \u0026#39;NAME\u0026#39;: \u0026#39;django.contrib.auth.password_validation.NumericPasswordValidator\u0026#39;, }, ] # Internationalization # https://docs.djangoproject.com/en/3.2/topics/i18n/ # LANGUAGE_CODE = \u0026#39;en-us\u0026#39; LANGUAGE_CODE = \u0026#39;zh-hans\u0026#39; TIME_ZONE = \u0026#39;UTC\u0026#39; USE_I18N = True USE_L10N = True USE_TZ = True # Static files (CSS, JavaScript, Images) # https://docs.djangoproject.com/en/3.2/howto/static-files/ STATIC_URL = \u0026#39;/static/\u0026#39; # Default primary key field type # https://docs.djangoproject.com/en/3.2/ref/settings/#default-auto-field DEFAULT_AUTO_FIELD = \u0026#39;django.db.models.BigAutoField\u0026#39; MENU = { \u0026#34;ADMIN\u0026#34;: [], \u0026#34;CUSTOMER\u0026#34;: [], } PERMISSION = { \u0026#34;ADMIN\u0026#34;: [], \u0026#34;CUSTOMER\u0026#34;: [], } # cache缓存配置 CACHES = { } # session配置 SESSION_ENGINE = \u0026#39;django.contrib.sessions.backends.cache\u0026#39; SESSION_CACHE_ALIAS = \u0026#39;default\u0026#39; # 自定义cookie过期时间 SESSION_COOKIE_AGE = 60 * 60 * 24 * 7 * 2 # 自定义配置 LOGIN_HOME = \u0026#34;/home/\u0026#34; MY_SESSION_KEY = \u0026#34;user_info\u0026#34; MY_LOGIN_URL = \u0026#34;/login/\u0026#34; MY_WHITE_URL = [\u0026#34;/login/\u0026#34;, \u0026#34;/sms/login/\u0026#34;, \u0026#34;/sms/send/\u0026#34;] MY_MENU = { \u0026#34;ADMIN\u0026#34;: [ { \u0026#39;text\u0026#39;: \u0026#34;用户信息\u0026#34;, \u0026#39;icon\u0026#39;: \u0026#34;fa-bed\u0026#34;, \u0026#39;children\u0026#39;: [ {\u0026#39;text\u0026#39;: \u0026#34;级别管理\u0026#34;, \u0026#39;url\u0026#39;: \u0026#34;/level/list\u0026#34;, \u0026#39;name\u0026#39;: \u0026#34;level_list\u0026#34;}, {\u0026#39;text\u0026#39;: \u0026#34;客户管理\u0026#34;, \u0026#39;url\u0026#39;: \u0026#34;/customer/list\u0026#34;, \u0026#39;name\u0026#39;: \u0026#34;customer_list\u0026#34;}, {\u0026#39;text\u0026#39;: \u0026#34;价格策略\u0026#34;, \u0026#39;url\u0026#39;: \u0026#34;/policy/list\u0026#34;, \u0026#39;name\u0026#39;: \u0026#34;policy_list\u0026#34;}, ] }, { \u0026#39;text\u0026#39;: \u0026#34;交易管理\u0026#34;, \u0026#39;icon\u0026#39;: \u0026#34;fa-bed\u0026#34;, \u0026#39;children\u0026#39;: [ {\u0026#39;text\u0026#39;: \u0026#34;交易记录\u0026#34;, \u0026#39;url\u0026#39;: \u0026#34;/transaction/list/\u0026#34;, \u0026#39;name\u0026#39;: \u0026#34;transaction_list\u0026#34;}, ] } ], \u0026#34;CUSTOMER\u0026#34;: [ { \u0026#39;text\u0026#39;: \u0026#34;用户信息\u0026#34;, \u0026#39;icon\u0026#39;: \u0026#34;fa-keyboard-o\u0026#34;, \u0026#39;children\u0026#39;: [ {\u0026#39;text\u0026#39;: \u0026#34;订单管理\u0026#34;, \u0026#39;url\u0026#39;: \u0026#34;/my/order/list\u0026#34;, \u0026#39;name\u0026#39;: \u0026#34;my_order_list\u0026#34;}, {\u0026#39;text\u0026#39;: \u0026#34;我的交易记录\u0026#34;, \u0026#39;url\u0026#39;: \u0026#34;/my/transaction/list/\u0026#34;, \u0026#39;name\u0026#39;: \u0026#34;my_transaction_list\u0026#34;}, ] } ], } MY_PPERMISSION_PUBLIC = { \u0026#34;home\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;主页\u0026#34;, \u0026#34;parent\u0026#34;: None}, \u0026#34;logout\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;注销\u0026#34;, \u0026#34;parent\u0026#34;: None}, } MY_PERMISSION = { \u0026#34;ADMIN\u0026#34;: { \u0026#34;level_list\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;级别列表\u0026#34;, \u0026#34;parent\u0026#34;: None}, \u0026#34;level_add\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;新建级别\u0026#34;, \u0026#34;parent\u0026#34;: \u0026#39;level_list\u0026#39;}, \u0026#34;level_edit\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;编辑级别\u0026#34;, \u0026#34;parent\u0026#34;: \u0026#39;level_list\u0026#39;}, \u0026#34;level_delete\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;删除级别\u0026#34;, \u0026#34;parent\u0026#34;: \u0026#39;level_list\u0026#39;}, \u0026#34;customer_list\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;客户列表\u0026#34;, \u0026#34;parent\u0026#34;: None}, \u0026#34;customer_add\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;新建客户\u0026#34;, \u0026#34;parent\u0026#34;: \u0026#39;customer_list\u0026#39;}, \u0026#34;customer_edit\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;编辑客户\u0026#34;, \u0026#34;parent\u0026#34;: \u0026#39;customer_list\u0026#39;}, \u0026#34;customer_reset\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;重置密码\u0026#34;, \u0026#34;parent\u0026#34;: \u0026#39;customer_list\u0026#39;}, \u0026#34;customer_delete\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;删除客户\u0026#34;, \u0026#34;parent\u0026#34;: \u0026#39;customer_list\u0026#39;}, \u0026#34;customer_charge\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;我的交易记录\u0026#34;, \u0026#34;parent\u0026#34;: \u0026#39;customer_list\u0026#39;}, \u0026#34;customer_charge_add\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;创建交易记录\u0026#34;, \u0026#34;parent\u0026#34;: \u0026#39;customer_list\u0026#39;}, \u0026#34;policy_list\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;价格策略\u0026#34;, \u0026#34;parent\u0026#34;: None}, \u0026#34;policy_add\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;创建价格策略\u0026#34;, \u0026#34;parent\u0026#34;: \u0026#39;policy_list\u0026#39;}, \u0026#34;policy_edit\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;编辑价格策略\u0026#34;, \u0026#34;parent\u0026#34;: \u0026#39;policy_list\u0026#39;}, \u0026#34;policy_delete\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;删除价格策略\u0026#34;, \u0026#34;parent\u0026#34;: \u0026#39;policy_list\u0026#39;}, \u0026#34;transaction_list\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;交易记录\u0026#34;, \u0026#34;parent\u0026#34;: None}, }, \u0026#34;CUSTOMER\u0026#34;: { \u0026#34;my_order_list\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;订单列表\u0026#34;, \u0026#34;parent\u0026#34;: None}, \u0026#34;my_order_add\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;新建订单\u0026#34;, \u0026#34;parent\u0026#34;: \u0026#39;my_order_list\u0026#39;}, \u0026#34;my_order_cancel\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;订单\u0026#34;, \u0026#34;parent\u0026#34;: \u0026#39;my_order_list\u0026#39;}, \u0026#34;my_transaction_list\u0026#34;: {\u0026#34;text\u0026#34;: \u0026#34;我的交易记录\u0026#34;, \u0026#34;parent\u0026#34;: None}, } } QUEUE_TASK_NAME = \u0026#34;YANG_TASK_QUEUE\u0026#34; # MESSAGE_STORAGE = \u0026#39;django.contrib.messages.storage.fallback.FallbackStorage\u0026#39; # MESSAGE_STORAGE = \u0026#39;django.contrib.messages.storage.cookie.CookieStorage\u0026#39; MESSAGE_STORAGE = \u0026#39;django.contrib.messages.storage.session.SessionStorage\u0026#39; MESSAGE_DANGER_TAG = 50 MESSAGE_TAGS = { MESSAGE_DANGER_TAG: \u0026#34;danger\u0026#34; } import os LOGGING = { \u0026#39;version\u0026#39;: 1, \u0026#39;disable_existing_loggers\u0026#39;: False, \u0026#39;handlers\u0026#39;: { \u0026#39;file\u0026#39;: { \u0026#39;level\u0026#39;: \u0026#39;ERROR\u0026#39;, \u0026#39;class\u0026#39;: \u0026#39;logging.FileHandler\u0026#39;, \u0026#39;filename\u0026#39;: os.path.join(BASE_DIR, \u0026#39;django_error.log\u0026#39;), }, }, \u0026#39;loggers\u0026#39;: { \u0026#39;django\u0026#39;: { \u0026#39;handlers\u0026#39;: [\u0026#39;file\u0026#39;], \u0026#39;level\u0026#39;: \u0026#39;ERROR\u0026#39;, \u0026#39;propagate\u0026#39;: True, }, }, } try: from .local_settings import * except ImportError: pass local_settings.py配置：\n放置数据库连接配置等线上与本地测试环境不同的设置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.mysql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;day06\u0026#39;, # 数据库名字 \u0026#39;USER\u0026#39;: \u0026#39;root\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;Qiuwj1029\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, # ip \u0026#39;PORT\u0026#39;: 3306, } } # cache缓存配置 CACHES = { \u0026#34;default\u0026#34;: { \u0026#34;BACKEND\u0026#34;: \u0026#34;django_redis.cache.RedisCache\u0026#34;, \u0026#34;LOCATION\u0026#34;: \u0026#34;redis://127.0.0.1:6379\u0026#34;, \u0026#34;OPTIONS\u0026#34;: { \u0026#34;CLIENT_CLASS\u0026#34;: \u0026#34;django_redis.client.DefaultClient\u0026#34;, \u0026#34;CONNECTION_POOL_KWARGS\u0026#34;: {\u0026#34;max_connections\u0026#34;: 100} # \u0026#34;PASSWORD\u0026#34;: \u0026#34;密码\u0026#34;, } } } 用户认证相关 用户名密码登录 1 2 3 4 form中各个字段放置的位置 form自定义字段中placeholder raise ValidationError(\u0026#34;用户名格式错误\u0026#34;) 视图函数中为指定字段添加报错信息 form.add_error(\u0026#34;username\u0026#34;, \u0026#34;用户名或密码错误\u0026#34;) 访问/login/ 来到account.py下的login()视图函数 用户看到login.html填写表单并提交，回到account.py下的login()视图函数 手机验证码登录 1 2 3 4 模板中利用name反向生成url {% url \u0026#39;login\u0026#39; %} form中label属性 json返回值对象 发送验证码及对应页面效果实现的js 点击短信登陆进行跳转 用户看到sms_login.html 发送验证码前置 发送验证码 登录成功 菜单和权限 访问权限 1 2 3 4 5 6 7 8 9 10 11 process_request，基于他实现用户是否已登录，继续；未登录则返回登录界面。 - return None，继续向后访问 - return 对象，直接返回。 process_view，权限校验 - return None，继续向后访问 - return 对象，直接返回。 - 在他的request对象中有 resolver_match ，包含当前请求的视图路由信息 .name-\u0026gt;sms_login admin = [\u0026#39;sms_login\u0026#39;,\u0026#34;xxx\u0026#34;] process_response 是否已登录 1 2 3 4 request中取出访问路径 request.path_info 白名单（登录页面）判断 从session中获取信息判断登录 登陆成功封装用户信息至request 菜单页面优化 layout.html 母版\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 {% load static %} {% load menu %} \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{% static \u0026#39;/plugins/bootstrap/css/bootstrap.min.css\u0026#39; %}\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{% static \u0026#39;/plugins/font-awesome/css/font-awesome.min.css\u0026#39; %}\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{% static \u0026#39;/css/commons.css\u0026#39; %}\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{% static \u0026#39;/css/menu.css\u0026#39; %}\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{% static \u0026#39;/css/nav.css\u0026#39; %}\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{% static \u0026#39;css/search-group.css\u0026#39; %}\u0026#34;\u0026gt; {% block css %}{% endblock %} \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;pg-header\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;nav\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;logo-area left\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{% url \u0026#39;home\u0026#39; %}\u0026#34;\u0026gt; \u0026lt;span style=\u0026#34;font-size: 18px;\u0026#34;\u0026gt;MY的管理平台\u0026lt;/span\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right-menu right clearfix\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;user-info right\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; class=\u0026#34;avatar\u0026#34; style=\u0026#34;text-decoration: none;\u0026#34;\u0026gt; \u0026lt;span style=\u0026#34;color: white;margin-right: 5px;\u0026#34;\u0026gt;{{ request.my_user.name }}\u0026lt;/span\u0026gt; \u0026lt;img class=\u0026#34;img-circle\u0026#34; style=\u0026#34;width: 35px;height: 35px;\u0026#34; src=\u0026#34;{% static \u0026#39;images/default.png\u0026#39; %}\u0026#34;\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;div class=\u0026#34;more-info\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{% url \u0026#39;logout\u0026#39; %}\u0026#34; class=\u0026#34;more-item\u0026#34;\u0026gt;注销\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;pg-body\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;left-menu\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;menu-body\u0026#34;\u0026gt; {% my_menu request %} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right-body\u0026#34;\u0026gt; \u0026lt;ol class=\u0026#34;breadcrumb\u0026#34;\u0026gt; {% for text in request.my_user.text_list %} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;{{ text }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; {% endfor %} \u0026lt;/ol\u0026gt; \u0026lt;div style=\u0026#34;padding: 20px\u0026#34;\u0026gt; {% block content %}{% endblock %} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;{% static \u0026#39;js/JQuery3.6.0.js\u0026#39; %}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;{% static \u0026#39;plugins/bootstrap/js/bootstrap.min.js\u0026#39; %}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;{% static \u0026#39;js/menu.js\u0026#39; %}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {% block js %}{% endblock %} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; home.html\n只需继承layout.html并拓展即可\n1 2 3 4 5 6 {% extends \u0026#39;layout.html\u0026#39; %} {% block content %} \u0026lt;h3\u0026gt;欢迎\u0026lt;/h3\u0026gt; {% endblock %} 动态菜单 顶部导航（注销） 权限校验 顶部导航栏与关联菜单选中样式 按钮显示权限 1 2 3 4 check_permission:有无权限 has_permission:用于控制页面的显示，有对应权限则展示页面 其他方法:根据传入的url的name与参数反向生成url 编辑处需要处理跳转时的参数携带问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 from django.http import QueryDict from django.template import Library from django.conf import settings from django.urls import reverse from django.utils.safestring import mark_safe register = Library() def check_permission(request, name): # print(request, name, args, kwargs) # \u0026lt;WSGIRequest: GET \u0026#39;/customer/list/\u0026#39;\u0026gt; customer_add () {} # 1.获取当前登录用户角色 role = request.my_user.role # 2.根据角色获取权限字典 permission_dict = settings.MY_PERMISSION[role] # 3.判断权限 if name in permission_dict: return True if name in settings.MY_PPERMISSION_PUBLIC: return True @register.simple_tag def add_permission(request, name, *args, **kwargs): # 3.1无权限，返回空 if not check_permission(request, name): return \u0026#34;\u0026#34; # 3.2有权限，通过name反向生成URL url = reverse(name, args=args, kwargs=kwargs) tpl = \u0026#34;\u0026#34;\u0026#34;\u0026lt;a href=\u0026#34;{}\u0026#34; class=\u0026#34;btn btn-success\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;glyphicon glyphicon-plus-sign\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;新建 \u0026lt;/a\u0026gt;\u0026#34;\u0026#34;\u0026#34;.format(url) return mark_safe(tpl) @register.simple_tag def edit_permission(request, name, *args, **kwargs): # 3.1无权限，返回空 if not check_permission(request, name): return \u0026#34;\u0026#34; # 3.2有权限，通过name反向生成URL url = reverse(name, args=args, kwargs=kwargs) # 根据当前用户请求获取GET参数 param = request.GET.urlencode() # page=9\u0026amp;xx=12 if param: new_query_dict = QueryDict(mutable=True) new_query_dict[\u0026#39;_filter\u0026#39;] = param filter_string = new_query_dict.urlencode() tpl = \u0026#34;\u0026#34;\u0026#34;\u0026lt;a href=\u0026#34;{}?{}\u0026#34; class=\u0026#34;btn btn-primary btn-xs\u0026#34;\u0026gt;编辑\u0026lt;/a\u0026gt;\u0026#34;\u0026#34;\u0026#34;.format(url, filter_string) return mark_safe(tpl) tpl = \u0026#34;\u0026#34;\u0026#34;\u0026lt;a href=\u0026#34;{}\u0026#34; class=\u0026#34;btn btn-primary btn-xs\u0026#34;\u0026gt;编辑\u0026lt;/a\u0026gt;\u0026#34;\u0026#34;\u0026#34;.format(url) return mark_safe(tpl) @register.simple_tag def delete_permission(request, name, *args, **kwargs): # 3.1无权限，返回空 if not check_permission(request, name): return \u0026#34;\u0026#34; # 3.2有权限，通过name反向生成URL pk = kwargs.get(\u0026#39;pk\u0026#39;) tpl = \u0026#34;\u0026#34;\u0026#34;\u0026lt;a cid=\u0026#34;{}\u0026#34; class=\u0026#34;btn btn-danger btn-xs btn-delete\u0026#34;\u0026#34;\u0026gt;删除\u0026lt;/a\u0026gt;\u0026#34;\u0026#34;\u0026#34;.format(pk) return mark_safe(tpl) @register.simple_tag def delete_url_permission(request, name, *args, **kwargs): # 3.1无权限，返回空 if not check_permission(request, name): return \u0026#34;\u0026#34; url = reverse(name, args=args, kwargs=kwargs) tpl = \u0026#34;\u0026#34;\u0026#34;\u0026lt;a href=\u0026#34;{}\u0026#34; class=\u0026#34;btn btn-danger btn-xs btn-delete\u0026#34;\u0026gt;删除\u0026lt;/a\u0026gt;\u0026#34;\u0026#34;\u0026#34;.format(url) return mark_safe(tpl) @register.filter def has_permission(request, others): name_list = others.split(\u0026#39;,\u0026#39;) for name in name_list: if check_permission(request, name): return True return False 级别管理 级别列表 1 如果用户没有对应权限就不要显示按钮 新增级别 编辑级别 删除级别 客户管理 客户列表 1 2 3 4 5 6 7 8 9 读取客户列表页面展示 问题： 如果关联的级别被删除该怎么处理？ 1.删除级别时判断是否有下属客户，有则不允许删除 2.自动将级别设为某个级别 3.不做任何处理，后续客户查询校验level_active=1 模板的时间格式 级别处显示对象而非level.title 1.主动连表查询 2.models中重写__str__方法指定输出 视图函数\n模板\n新建客户 1 2 3 4 5 6 7 8 9 10 11 12 13 14 新增form2.html模板，一行填写两个字段（栅栏样式） 新增重复密码字段 展示级别条件筛选（active=1） 1.models中limit_choice_to 2.自定义choices和queryset 展示级别管理-页面插件（select -\u0026gt; radio) 1.局部去除bootstrap样式 2.修改下拉框为radio框 提交保存 1.models表单验证，正则 2.自定义钩子，保证密码一直 3.models添加validators 4.保存（手动添加creator字段） 5.跳转回页面 编辑客户 1 和添加的页面不同，新建一个form 重置密码 删除客户（对话框和ajax） 1 2 3 4 5 6 模态对话框的触发方式 1.data-target属性 2.绑定点击函数 3.一键绑定 删除逻辑实现 删除成功后页面处理 交易记录列表 视图函数\n模板\n充值扣款添加颜色\n充值和扣款（对话框） 模板\n视图函数\n价格策略 价格策略列表 新建价格策略 编辑价格策略 删除价格策略 订单管理（用户） 我的订单列表 下单 输入：视频地址、数量（提示价格策略） 数据库操作（事务 + 锁） 创建订单记录 创建交易记录 扣款 写入redis队列（等待执行） 撤销订单（待执行） 数据库操作 更新订单状态 生成交易记录 归还扣款 我的订单列表 message\n新建订单 撤销订单 我的交易记录 客户 管理员 模板与客户无异\nWorker 执行worker去执行订单的执行。\n","date":"2025-02-27T18:57:50+08:00","permalink":"https://yn0t1me.github.io/p/order_trading_platform/","title":"项目：订单交易平台"},{"content":"前言 前后端分离 django的FBV和CBV FBV：function base views，即编写函数来处理业务请求（函数） 1 2 3 4 5 6 from django.contrib import admin from django.urls import path from app01 import views urlpatterns = [ path(\u0026#39;users/\u0026#39;, views.users), ] 1 2 3 4 5 6 7 8 from django.http import JsonResponse def users(request,*args, **kwargs): if request.method == \u0026#34;GET\u0026#34;: return JsonResponse({\u0026#34;code\u0026#34;:1000,\u0026#34;data\u0026#34;:\u0026#34;xxx\u0026#34;}) elif request.method == \u0026#39;POST\u0026#39;: return JsonResponse({\u0026#34;code\u0026#34;:1000,\u0026#34;data\u0026#34;:\u0026#34;xxx\u0026#34;}) ... CBV，class base views，即编写类来处理业务请求（类加反射） 1 2 3 4 5 6 from django.contrib import admin from django.urls import path from app01 import views urlpatterns = [ path(\u0026#39;users/\u0026#39;, views.UserView.as_view()), ] 1 2 3 4 5 6 7 8 from django.views import View class UserView(View): def get(self, request, *args, **kwargs): return JsonResponse({\u0026#34;code\u0026#34;: 1000, \u0026#34;data\u0026#34;: \u0026#34;xxx\u0026#34;}) def post(self, request, *args, **kwargs): return JsonResponse({\u0026#34;code\u0026#34;: 1000, \u0026#34;data\u0026#34;: \u0026#34;xxx\u0026#34;}) 其实，CBV和FBV的底层实现本质上相同的。\ndrf 1 2 3 4 5 6 # django中的CBV class View() # drf框架中的CBV class APIViews(View) # 自定义的类 class UserInfo(APIViews) 创建项目 django配置 创建纯净python项目并配置虚拟环境 安装django库并完成基础的项目配置 1 2 3 4 5 6 # 安装django库 pip install django==3.2 # 创建项目目录 django-admin startproject day13 . # 创建一个app python manage.py startapp api 纯净版django项目（对settings.py文件操作） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 INSTALLED_APPS = [ # \u0026#39;django.contrib.admin\u0026#39;, # \u0026#39;django.contrib.auth\u0026#39;, # \u0026#39;django.contrib.contenttypes\u0026#39;, # \u0026#39;django.contrib.sessions\u0026#39;, # \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, ] MIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, # \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, # \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, # \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, # \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, ] TEMPLATES = [ { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.template.backends.django.DjangoTemplates\u0026#39;, \u0026#39;DIRS\u0026#39;: [], \u0026#39;APP_DIRS\u0026#39;: True, \u0026#39;OPTIONS\u0026#39;: { \u0026#39;context_processors\u0026#39;: [ \u0026#39;django.template.context_processors.debug\u0026#39;, \u0026#39;django.template.context_processors.request\u0026#39;, # \u0026#39;django.contrib.auth.context_processors.auth\u0026#39;, # \u0026#39;django.contrib.messages.context_processors.messages\u0026#39;, ], }, }, ] 配置项目启动按钮 测试简单实例 1 2 3 4 5 6 7 # api/views.py from django.shortcuts import render, HttpResponse def home(request): return HttpResponse(\u0026#34;成功\u0026#34;) 1 2 3 4 5 6 7 8 9 10 # day13/urls.py # from django.contrib import admin from django.urls import path from api import views urlpatterns = [ # path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;home/\u0026#39;, views.home), ] 配置drf 安装drf框架 1 pip install djangorestframework==3.13.1 settings.py配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 INSTALLED_APPS = [ # \u0026#39;django.contrib.admin\u0026#39;, # \u0026#39;django.contrib.auth\u0026#39;, # \u0026#39;django.contrib.contenttypes\u0026#39;, # \u0026#39;django.contrib.sessions\u0026#39;, # \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;api.apps.ApiConfig\u0026#39;, \u0026#39;rest_framework\u0026#39;, ] MIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, # \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, # \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, # \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, ] TEMPLATES = [ { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.template.backends.django.DjangoTemplates\u0026#39;, \u0026#39;DIRS\u0026#39;: [], \u0026#39;APP_DIRS\u0026#39;: True, \u0026#39;OPTIONS\u0026#39;: { \u0026#39;context_processors\u0026#39;: [ \u0026#39;django.template.context_processors.debug\u0026#39;, \u0026#39;django.template.context_processors.request\u0026#39;, # \u0026#39;django.contrib.auth.context_processors.auth\u0026#39;, # \u0026#39;django.contrib.messages.context_processors.messages\u0026#39;, ], }, }, ] ################## drf匿名用户 ################## # 在request中源码可以找到 REST_FRAMEWORK = { \u0026#34;UNAUTHENTICATED_USER\u0026#34;: None } 简单实例 1 2 3 4 5 6 7 8 9 # from django.contrib import admin from django.urls import path from api import views urlpatterns = [ # path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;home/\u0026#39;, views.home), path(\u0026#39;user/\u0026#39;, views.UserView.as_view()), ] 1 2 3 4 5 6 7 8 9 10 11 12 from django.shortcuts import render, HttpResponse from rest_framework.views import APIView from rest_framework.response import Response def home(request): return HttpResponse(\u0026#34;成功\u0026#34;) class UserView(APIView): def get(self, request): return Response(\u0026#34;返回成功\u0026#34;) request oop知识 getattr：\n__getattr__：\n只有在属性查找失败时才会被调用（即在对象的 __dict__ 和类的 __dict__ 中都找不到属性时）。 它是一个“后备”方法，通常用于动态地提供属性或方法。 __getattribute__：\n是一个更底层的方法，会在每次属性访问时被调用，无论属性是否存在。 它的优先级高于 __getattr__，并且可以完全控制属性的访问行为。 直接访问或利用反射 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Foo(object): def __init__(self, name, age): self.name = name self.age = age def show(self): return 123 obj = Foo(\u0026#34;小三\u0026#34;, 19) # obj.name # obj.age # obj.show() # v1=obj.show v1 = getattr(obj, \u0026#39;show\u0026#39;) # \u0026lt;bound method Foo.show of \u0026lt;__main__.Foo object at 0x000001D9870DBFD0\u0026gt;\u0026gt; print(v1()) __getattr__ 当对象.一个不存在的成员时触发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Foo(object): def __init__(self, name, age): self.name = name self.age = age def show(self): return 123 def __getattr__(self, item): print(\u0026#34;-----\u0026gt;\u0026#34;, item) return 999 obj = Foo(\u0026#34;小三\u0026#34;, 19) # 不触发 __getattr # obj.name # obj.age # obj.show() # 触发 __getattr__ (不存在的成员) # print(obj.xxx) v2 = getattr(obj, \u0026#34;xxxx\u0026#34;) print(v2) # -----\u0026gt; xxxx # 999 getattribute 只要执行 对象.xxx都会执行__getattribute__ 父类object中的__getattribute__的处理机制 对象中有值，返回 对象中无值，报错 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Foo(object): def __init__(self, name, age): self.name = name self.age = age def show(self): return 123 def __getattribute__(self, item): print(\u0026#34;-----\u0026gt;\u0026#34;, item) return 999 obj = Foo(\u0026#34;小三\u0026#34;, 19) print(obj.name) print(obj.age) print(obj.xxx) # -----\u0026gt; name # 999 # -----\u0026gt; age # 999 # -----\u0026gt; xxx # 999 类分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class HttpRequest(object): def __init__(self): pass def v1(self): print(\u0026#34;v1\u0026#34;) def v2(self): print(\u0026#34;v2\u0026#34;) class Request(object): def __init__(self, req, xx): self._request = req self.xx = xx req = HttpRequest() req.v1() req.v2() request = Request(req, 111) request._request.v1() request._request.v2() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class HttpRequest(object): def __init__(self): pass def v1(self): print(\u0026#34;v1\u0026#34;) def v2(self): print(\u0026#34;v2\u0026#34;) class Request(object): def __init__(self, req, xx): self._request = req self.xx = xx # 对象中无的成员，会触发 def __getattr__(self, attr): # attr=\u0026#34;v1\u0026#34; try: return getattr(self._request, attr) except AttributeError: return self.__getattribute__(attr) req = HttpRequest() request = Request(req, 111) # request._request.v1() request.v1() # request.v1=request._request.v1 request的简单实现原理（属性代理） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class HttpRequest(object): def __init__(self): pass def method(self): print(\u0026#34;v1\u0026#34;) def path_info(self): print(\u0026#34;v2\u0026#34;) class DrfRequest(object): def __init__(self, req, xx): self._request = req self.xx = xx def __getattr__(self, attr): try: return getattr(self._request, attr) except AttributeError: return self.__getattribute__(attr) request = HttpRequest() request = DrfRequest(request, 123123) # 普通写法 request._request.method # 利用__getattr__和__getattribute__ request.method request.path_info # 报错 request.uuuu 参数 普通匹配：\u0026lt;数据类型:参数名\u0026gt;，视图直接用参数接收，或者self.kwargs中获取\n不指定参数名正则匹配（导入re_path）：(正则表达式)，视图直接用参数接收，或者self.args中获取\n指定参数名正则匹配：(?P\u0026lt;参数名\u0026gt;正则表达式)，视图直接用参数接收，或者self.kwargs中获取\n命名捕获组（Named Capture Group）：(?P\u0026lt;参数名\u0026gt;正则表达式)\n测试代码 1 2 3 4 5 6 7 8 9 10 from django.contrib import admin from django.urls import path, re_path from api import views urlpatterns = [ # path(\u0026#39;admin/\u0026#39;, admin.site.urls), # path(\u0026#39;users/\u0026lt;str:version\u0026gt;/\u0026lt;int:pid\u0026gt;/\u0026#39;, views.UserView.as_view()), # re_path(\u0026#39;users/(\\w+)/(\\d+)/\u0026#39;, views.UserView.as_view()), re_path(\u0026#39;users/(?P\u0026lt;version\u0026gt;\\w+)/(?P\u0026lt;pid\u0026gt;\\d+)/\u0026#39;, views.UserView.as_view()), ] 1 2 3 4 5 6 7 8 9 10 from rest_framework.views import APIView from rest_framework.response import Response class UserView(APIView): def get(self, request, version, pid): print(version, pid) print(self.kwargs) print(self.args) return Response(\u0026#34;...\u0026#34;) 源码分析 流程梳理-文字版 1 2 3 4 5 6 7 8 9 10 注意：下列调用方法的找寻路线遵循先UserView类，后APIView类，最后是View类，就不再详细赘述找寻过程 首先入口是路由中调用UserView类的as_View()方法，找到APIView类的as_view()方法，又调用View类的as_view()方法 View类的as_view()方法调用APIView类的dispatch方法 dispatch()方法调用initialize_request()方法，将django的request传给drf的Request类，Request 的构造函数接收上述参数，并将它们存储在实例中，并且定义了__getattr__方法，用于在drf的request中无缝访问原生django的request 此时initialize_request()方法调用完毕，回到dispatch()方法 dispatch()通过getattr反射获取请求方法，并调用，将结果一步步返回 源代码分析-精简版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class APIView(View): def as_view(cls, **initkwargs): view = super().as_view(**initkwargs) return csrf_exempt(view) def initialize_request(self, request, *args, **kwargs): parser_context = self.get_parser_context(request) return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) def dispatch(self, request, *args, **kwargs): self.args = args self.kwargs = kwargs # request还是django中的request request = self.initialize_request(request, *args, **kwargs) # 此时的request时drf的request，request._request就是原生django的request # request._request.method # request.method # __getattr__ self.request = request self.headers = self.default_response_headers if request.method.lower() in self.http_method_names: # 获取get/post/put等方法 handler = getattr(self, request.method.lower(),self.http_method_not_allowed) # 调用get/post等方法(UserView中) response = handler(request, *args, **kwargs) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response class View: def as_view(cls, **initkwargs): def view(request, *args, **kwargs): return self.dispatch(request, *args, **kwargs) return view class Request: def __init__(self, request, parsers=None, authenticators=None, negotiator=None, parser_context=None): self._request = request def __getattr__(self, attr): try: return getattr(self._request, attr) except AttributeError: return self.__getattribute__(attr) class UserView(APIView): def get(self, request, version, pid): print(version, pid) print(self.kwargs) print(self.args) return Response(\u0026#34;...\u0026#34;) request对象 Django 原生 HttpRequest\ndjango.core.handlers.wsgi.WSGIRequest 包含了请求的所有数据 request.method：请求方法（GET、POST 等） request.GET 和 request.POST：查询参数和表单数据 request.body：请求体的原始数据 DRF 的 Request 对象\nrest_framework.request.Request 提供了更灵活的方式来处理请求数据 self._request：存储 Django 的原生 HttpRequest 对象 request.query_params：用于获取 URL 查询参数（GET 请求的参数） request.data：用于获取请求体中的数据，支持多种格式（如 JSON、表单数据等） request.method：获取请求方法（如 GET、POST、PUT 等），与 Django 的 request.method 功能相同 request.user 和 request.auth：当前请求的用户对象，经过认证后的用户信息和认证相关的额外信息，例如 Token request.parsers：当前请求使用的解析器列表，用于解析请求体数据 request.authenticators：当前请求使用的认证器列表 request.is_ajax()：判断请求是否为 AJAX 请求 request.accepted_renderer：获取当前请求的渲染器，用于决定响应数据的格式 request.accepted_media_type：获取客户端请求的 Accept 头部信息，用于内容协商 request.stream：获取请求体的原始流数据 drf中的request其实是对请求的再次封装，其目的就是在原来的request对象基础中再进行封装一些drf中需要用到的值\n测试代码 1 2 3 4 5 6 7 8 9 10 from django.contrib import admin from django.urls import path, re_path from api import views urlpatterns = [ # path(\u0026#39;admin/\u0026#39;, admin.site.urls), # path(\u0026#39;users/\u0026lt;str:version\u0026gt;/\u0026lt;int:pid\u0026gt;/\u0026#39;, views.UserView.as_view()), # re_path(\u0026#39;users/(\\w+)/(\\d+)/\u0026#39;, views.UserView.as_view()), re_path(\u0026#39;users/(?P\u0026lt;version\u0026gt;\\w+)/(?P\u0026lt;pid\u0026gt;\\d+)/\u0026#39;, views.UserView.as_view()), ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from rest_framework.views import APIView from rest_framework.response import Response from rest_framework.request import Request class UserView(APIView): def get(self, request, version, pid): # drf的request对象 print(request.query_params) print(request.data) print(request.auth) print(request.user) # django的request对象 print(request.GET) print(request.method) print(request.path_info) return Response(\u0026#34;...\u0026#34;) 认证 在开发API过程中，有些功能需要登录才能访问，有些无需登录。drf中的认证组件主要就是用来实现此功能\n快速使用 通过编写类的形式实现，一个类就是一个认证组件\n编写类 -\u0026gt; 认证组件 应用组件 案例1 项目要开发3个接口，其中1个无需登录接口、2个必须登录才能访问的接口。\n局部配置 authentication_classes = []\n无需登录的不配置认证类，默认是匿名用户，需要登陆的配置认证类，通过返回元组赋值request.user 和 request.auth，未通过抛出异常。若返回None则是匿名用户，不符合需求\n认证失败信息定制 匿名用户 认证组件中返回的两个值，分别赋值给：request.user 和 request.auth urls.py 1 2 3 4 5 6 7 8 9 from django.urls import path from api import views urlpatterns = [ path(\u0026#39;login/\u0026#39;, views.LoginView.as_view()), path(\u0026#39;user/\u0026#39;, views.UserView.as_view()), path(\u0026#39;order/\u0026#39;, views.OrderView.as_view()), ] views.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from rest_framework.views import APIView from rest_framework.response import Response from rest_framework.request import Request from rest_framework.authentication import BaseAuthentication from rest_framework.exceptions import AuthenticationFailed class MyAuthentication(BaseAuthentication): def authenticate(self, request): # /xxx/xxx/xxx?token=123123123 # token = request._request.GET.get(\u0026#39;token\u0026#39;) token = request.query_params.get(\u0026#39;token\u0026#39;) if token: return \u0026#34;user\u0026#34;, token # raise AuthenticationFailed(\u0026#34;认证失败\u0026#34;) raise AuthenticationFailed({\u0026#34;code\u0026#34;: 20000, \u0026#34;error\u0026#34;: \u0026#34;认证失败\u0026#34;}) class LoginView(APIView): authentication_classes = [] def get(self, request): print(request.user, request.auth) return Response(\u0026#34;LoginView\u0026#34;) class UserView(APIView): authentication_classes = [MyAuthentication, ] def get(self, request): print(request.user, request.auth) return Response(\u0026#34;UserView\u0026#34;) class OrderView(APIView): authentication_classes = [MyAuthentication, ] def get(self, request): print(request.user, request.auth) return Response(\u0026#34;OrderView\u0026#34;) 案例2 项目要开发100个接口，其中1个无需登录接口、99个必须登录才能访问的接口。\n此时，就需要用到drf的全局配置（认证组件的类不能放在视图view.py中，会因为导入APIView导致循环引用，该案例放置在ext/auth.py中）\ndrf会先加载全局配置，在加载局部配置，局部配置会覆盖全局配置\next\\auth.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from rest_framework.authentication import BaseAuthentication from rest_framework.exceptions import AuthenticationFailed class MyAuthentication(BaseAuthentication): def authenticate(self, request): # /xxx/xxx/xxx?token=123123123 # token = request._request.GET.get(\u0026#39;token\u0026#39;) token = request.query_params.get(\u0026#39;token\u0026#39;) if token: return \u0026#34;user\u0026#34;, token # raise AuthenticationFailed(\u0026#34;认证失败\u0026#34;) raise AuthenticationFailed({\u0026#34;code\u0026#34;: 20000, \u0026#34;error\u0026#34;: \u0026#34;认证失败\u0026#34;}) urls.py 1 2 3 4 5 6 7 8 9 from django.urls import path from api import views urlpatterns = [ path(\u0026#39;login/\u0026#39;, views.LoginView.as_view()), path(\u0026#39;user/\u0026#39;, views.UserView.as_view()), path(\u0026#39;order/\u0026#39;, views.OrderView.as_view()), ] views.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from rest_framework.views import APIView from rest_framework.response import Response from ext.auth import MyAuthentication class LoginView(APIView): authentication_classes = [] def get(self, request): print(request.user, request.auth) return Response(\u0026#34;LoginView\u0026#34;) class UserView(APIView): def get(self, request): print(request.user, request.auth) return Response(\u0026#34;UserView\u0026#34;) class OrderView(APIView): def get(self, request): print(request.user, request.auth) return Response(\u0026#34;OrderView\u0026#34;) 案例3 状态码一致性问题： 如果认证组件中未定义，则统一为 HTTP_403_FORBIDDEN\n如果自定义了，还会加上一个响应头\n定义get_authenticate_header方法\n参考源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def handle_exception(self, exc): if isinstance(exc, (exceptions.NotAuthenticated,exceptions.AuthenticationFailed)): auth_header = self.get_authenticate_header(self.request) if auth_header: exc.auth_header = auth_header else: exc.status_code = status.HTTP_403_FORBIDDEN return response def get_authenticate_header(self, request): authenticators = self.get_authenticators() if authenticators: return authenticators[0].authenticate_header(request) 案例4 项目要开发100个接口，其中1个无需登录接口、98个必须登录才能访问的接口、1个公共接口（未登录时显示公共/已登录时显示个人信息）。\n原来的认证信息只能放在URL中传递，如果程序中支持放在很多地方，例如：URL中、请求头中等。\n认证组件中，如果是使用了多个认证类，会按照顺序逐一执行其中的authenticate方法\n返回None或无返回值，表示继续执行后续的认证类 返回 (user, auth) 元组，则不再继续并将值赋值给request.user和request.auth 抛出异常 AuthenticationFailed(...)，认证失败，不再继续向后走。 多个认证组件每一个都返回None，都没有认证成功，视图函数也会被执行，只不过self.user，self.auth为None\next\\auth.py 设置一个检查参数的认证类，一个检查请求头的认证类，通过一个即为认证成功，然后设置一个认证类直接抛出异常\n对于无需登陆的，局部设置无认证类\n对于需要登陆的，则将所有认证类加上，若类1与类2未通过，走到类3会直接抛出异常即认证不通过\n对于公共接口，局部设置前两个认证类，若未通过则以匿名用户访问\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from rest_framework.authentication import BaseAuthentication from rest_framework.exceptions import AuthenticationFailed class ParamAuthentication(BaseAuthentication): def authenticate(self, request): token = request.query_params.get(\u0026#39;token\u0026#39;) if not token: return return \u0026#34;user\u0026#34;, token def authenticate_header(self, request): return \u0026#39;Token\u0026#39; class HeaderAuthentication(BaseAuthentication): def authenticate(self, request): token = request.META.get(\u0026#39;HTTP_AUTHORIZATION\u0026#39;) if not token: return return \u0026#34;user\u0026#34;, token def authenticate_header(self, request): return \u0026#39;Token\u0026#39; class NotAuthentication(BaseAuthentication): def authenticate(self, request): raise AuthenticationFailed({\u0026#34;code\u0026#34;: 20000, \u0026#34;error\u0026#34;: \u0026#34;认证失败\u0026#34;}) def authenticate_header(self, request): return \u0026#39;Token\u0026#39; views.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from rest_framework.views import APIView from rest_framework.response import Response from ext.auth import ParamAuthentication, HeaderAuthentication # 无需登录 class UserView(APIView): authentication_classes = [] def get(self, request): return Response(\u0026#34;用户信息\u0026#34;) # 公共接口 class OrderView(APIView): authentication_classes = [ParamAuthentication, HeaderAuthentication, ] def get(self, request): if request.user: message = f\u0026#34;{request.user}的订单信息\u0026#34; else: message = \u0026#34;公共订单信息\u0026#34; return Response(message) # 必须登录 class InfoView(APIView): def get(self, request): message = f\u0026#34;{request.user}的用户信息\u0026#34; return Response(message) settings.py 1 2 3 4 5 6 7 8 9 REST_FRAMEWORK = { \u0026#34;UNAUTHENTICATED_USER\u0026#34;: None, # 未登录时，request.user=None \u0026#34;UNAUTHENTICATED_TOKEN\u0026#34;: None, # 未登录时，request.auth=None \u0026#34;DEFAULT_AUTHENTICATION_CLASSES\u0026#34;: [ \u0026#34;ext.auth.ParamAuthentication\u0026#34;, \u0026#34;ext.auth.HeaderAuthentication\u0026#34;, \u0026#34;ext.auth.NotAuthentication\u0026#34;, ] } 面向对象-继承 局部配置与全局配置的优先关系\n1 2 3 4 5 6 7 8 9 10 11 12 13 class APIView(View): authentication_classes = 读取配置文件中的列表 def dispatch(self): self.authentication_classes class UserView(APIView): authentication_classes = [11,22,33,44] obj = UserView() obj.dispatch() # authentication_classes = [11,22,33,44] 组件源码 1 2 3 4 5 在request的初始化阶段加载认证组件，即调用initialize_request方法时，通过get_authenticators方法获取认证类实例对象列表authenticators get_authenticators方法循环authentication_classes，实例化生成认证类实例对象存储在列表中 authentication_classes读取的局部配置和全局配置 加载完成后，认证过程，即调用initial方法时，调用perform_authentication方法，获取request.user的值 user为空值即未认证，触发_authenticate方法，循环认证类实例对象列表authenticators，调用自己的认证方法，返回元组就赋值user和auth，退出循环；返回None继续循环；抛出异常就捕获异常，在dispatch中捕获；如果循环完没返回元组也没异常，执行_not_authenticated方法处理匿名用户 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 class Request: def __init__(self, request, authenticators=None): self._request = request self.authenticators = authenticators or () @property def user(self): if not hasattr(self, \u0026#39;_user\u0026#39;): with wrap_attributeerrors(): self._authenticate() return self._user @user.setter def user(self, value): self._user = value self._request.user = value def _authenticate(self): # authenticator是认证类实例化后的对象，循环逐一认证 # 如果认证过程抛出异常，认证不通过 # 若认证过程没有抛出异常，也没有返回self.user, self.auth，则匿名执行视图函数 for authenticator in self.authenticators: try: user_auth_tuple = authenticator.authenticate(self) # 调用认证类的authenticate方法，返回元组 except exceptions.APIException: self._not_authenticated() raise if user_auth_tuple is not None: self._authenticator = authenticator self.user, self.auth = user_auth_tuple return self._not_authenticated() def _not_authenticated(self): self._authenticator = None if api_settings.UNAUTHENTICATED_USER: self.user = api_settings.UNAUTHENTICATED_USER() else: self.user = None if api_settings.UNAUTHENTICATED_TOKEN: self.auth = api_settings.UNAUTHENTICATED_TOKEN() else: self.auth = None class APIView(View): authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES def as_view(cls, **initkwargs): view = super().as_view(**initkwargs) return csrf_exempt(view) def dispatch(self, request, *args, **kwargs): # 第一步：请求的封装(django的 request + drf的 authenticators认证组件) --\u0026gt; 加载认证组件过程 # request.authenticators [对象1，对象2，...] request = self.initialize_request(request, *args, **kwargs) self.request = request # 第二步：认证过程 try: self.initial(request, *args, **kwargs) handler = getattr(self, request.method.lower(), self.http_method_not_allowed) # 第三步：执行视图函数 response = handler(request, *args, **kwargs) except Exception as exc: # 认证时抛出错误在这里被捕获 response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response def initialize_request(self, request, *args, **kwargs): return Request( request, authenticators=self.get_authenticators(), # [对象1，对象2，...] ) def initial(self, request, *args, **kwargs): self.perform_authentication(request) self.check_permissions(request) self.check_throttles(request) def perform_authentication(self, request): request.user def get_authenticators(self): # 返回一个列表每一个元素都是认证类对象 [对象1，对象2，...] return [auth() for auth in self.authentication_classes] # 优先读取局部配置，后全局配置 def handle_exception(self, exc): if isinstance(exc, (exceptions.NotAuthenticated,exceptions.AuthenticationFailed)): auth_header = self.get_authenticate_header(self.request) if auth_header: exc.auth_header = auth_header else: exc.status_code = status.HTTP_403_FORBIDDEN return response def get_authenticate_header(self, request): authenticators = self.get_authenticators() if authenticators: return authenticators[0].authenticate_header(request) class View: def as_view(cls, **initkwargs): def view(request, *args, **kwargs): return self.dispatch(request, *args, **kwargs) return view class UserView(APIView): def get(self, request): print(request.user, request.auth) return Response(\u0026#34;UserView\u0026#34;) 拓展-子类约束 1 2 3 4 5 6 7 8 9 class Foo(object): # 对子类进行约束，约束子类中必须要定义该方法，不然就报错 def f1(self): raise NotImplementedError(\u0026#34;...\u0026#34;) class Bar(Foo): def f1(self): print(\u0026#34;123\u0026#34;) BaseAuthentication类定义 1 2 3 4 5 6 7 8 9 10 class BaseAuthentication: \u0026#34;\u0026#34;\u0026#34; All authentication classes should extend BaseAuthentication. \u0026#34;\u0026#34;\u0026#34; def authenticate(self, request): \u0026#34;\u0026#34;\u0026#34; Authenticate the request and return a two-tuple of (user, token). \u0026#34;\u0026#34;\u0026#34; raise NotImplementedError(\u0026#34;.authenticate() must be overridden.\u0026#34;) 案例-用户登录和认证 创建数据表 不配置其他数据库，采用默认的sqlite做简单测试\n注册app --\u0026gt; settings.py 1 2 3 4 5 6 7 8 9 10 INSTALLED_APPS = [ # \u0026#39;django.contrib.admin\u0026#39;, # \u0026#39;django.contrib.auth\u0026#39;, # \u0026#39;django.contrib.contenttypes\u0026#39;, # \u0026#39;django.contrib.sessions\u0026#39;, # \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;rest_framework\u0026#39;, \u0026#39;api.apps.ApiConfig\u0026#39;, ] api/models.py 1 2 3 4 5 6 7 8 9 10 from django.db import models # Create your models here. class UserInfo(models.Model): \u0026#34;\u0026#34;\u0026#34;用户表\u0026#34;\u0026#34;\u0026#34; username = models.CharField(verbose_name=\u0026#34;用户名\u0026#34;, max_length=32) password = models.CharField(verbose_name=\u0026#34;用户名\u0026#34;, max_length=64) # 临时形式、后续可以使用jwt等 token = models.CharField(verbose_name=\u0026#34;TOKEN\u0026#34;, max_length=64, null=True, blank=True) 创建数据库 手动添加数据做测试 路由系统 1 2 3 4 5 6 7 8 9 from django.urls import path from api import views urlpatterns = [ path(\u0026#39;login/\u0026#39;, views.LoginView.as_view()), path(\u0026#39;user/\u0026#39;, views.UserView.as_view()), path(\u0026#39;order/\u0026#39;, views.OrderView.as_view()), ] 认证组件 实际开发过程中应定制响应状态码，该案例使用简单的True和False标识状态\nsettings.py全局配置 1 2 3 4 5 6 7 8 9 REST_FRAMEWORK = { \u0026#34;UNAUTHENTICATED_USER\u0026#34;: None, # 未登录时，request.user=None \u0026#34;UNAUTHENTICATED_TOKEN\u0026#34;: None, # 未登录时，request.auth=None \u0026#34;DEFAULT_AUTHENTICATION_CLASSES\u0026#34;: [ \u0026#34;ext.auth.QueryParamsAuthentication\u0026#34;, \u0026#34;ext.auth.HeaderAuthentication\u0026#34;, \u0026#34;ext.auth.NoAuthentication\u0026#34;, ] } ext/auth.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from rest_framework.authentication import BaseAuthentication from rest_framework.exceptions import AuthenticationFailed from api import models class QueryParamsAuthentication(BaseAuthentication): def authenticate(self, request): # 获取请求参数值 token = request.query_params.get(\u0026#39;token\u0026#39;) if not token: return user_object = models.UserInfo.objects.filter(token=token).first() if user_object: return user_object, token # request.user = 用户对象，request.auth = token return def authenticate_header(self, request): return \u0026#39;Token\u0026#39; class HeaderAuthentication(BaseAuthentication): def authenticate(self, request): # 获取请求头 token = request.META.get(\u0026#39;HTTP_AUTHORIZATION\u0026#39;) if not token: return user_object = models.UserInfo.objects.filter(token=token).first() if user_object: return user_object, token # request.user = 用户对象，request.auth = token return def authenticate_header(self, request): return \u0026#39;Token\u0026#39; class NoAuthentication(BaseAuthentication): def authenticate(self, request): raise AuthenticationFailed({\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;认证失败\u0026#34;}) def authenticate_header(self, request): return \u0026#39;Token\u0026#39; 视图函数 postman发送post请求测试接口示例 登录生成token接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import uuid from rest_framework.views import APIView from rest_framework.response import Response from rest_framework.request import Request from api import models class LoginView(APIView): authentication_classes = [] # 局部配置，该函数无需登录 def post(self, request): # 1.接收用户post提交的用户名密码 # request.data直接是一个字典类型 user = request.data.get(\u0026#39;username\u0026#39;) pwd = request.data.get(\u0026#39;password\u0026#39;) # 2.数据库校验 user_object = models.UserInfo.objects.filter(username=user, password=pwd).first() if not user_object: return Response({\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;用户名或密码错误\u0026#34;}) # 3.登陆成功 token = str(uuid.uuid4()) user_object.token = token user_object.save() return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: token}) 需要认证的视图函数 1 2 3 class UserView(APIView): def get(self, request): return Response(\u0026#34;UserView\u0026#34;) 访问效果 在请求头中携带和在请求参数中携带均可，有对应的认证组件校验\n总结 编写组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # ext/auth.py from rest_framework.authentication import BaseAuthentication from rest_framework.exceptions import AuthenticationFailed class MyAuthentication(BaseAuthentication): def authenticate(self, request): # 去做用户认证 # 1.读取请求传递的token token = request.query_params.get(\u0026#39;token\u0026#39;) # 2.校验合法性 # 3.返回值 # 3.1 返回元组 (111,222) 认证成功 request.user request.auth # 3.2 抛出异常 认证失败 -\u0026gt; 返回错误信息 # 3.1 返回None 多个认证类 [类1，类2，类3，类4，，，] -\u0026gt; 匿名用户 if not token: return return \u0026#34;user\u0026#34;, token def authenticate_header(self, request): return \u0026#39;Token\u0026#39; class NotAuthentication(BaseAuthentication): def authenticate(self, request): raise AuthenticationFailed({\u0026#34;code\u0026#34;: 20000, \u0026#34;error\u0026#34;: \u0026#34;认证失败\u0026#34;}) def authenticate_header(self, request): return \u0026#39;Token\u0026#39; 全局配置匿名用户和认证类\n1 2 3 4 5 6 7 8 9 10 # settings.py REST_FRAMEWORK = { \u0026#34;UNAUTHENTICATED_USER\u0026#34;: None, # 未登录时，request.user=None \u0026#34;UNAUTHENTICATED_TOKEN\u0026#34;: None, # 未登录时，request.auth=None \u0026#34;DEFAULT_AUTHENTICATION_CLASSES\u0026#34;: [ \u0026#34;ext.auth.ParamAuthentication\u0026#34;, \u0026#34;ext.auth.HeaderAuthentication\u0026#34;, \u0026#34;ext.auth.NotAuthentication\u0026#34;, ] } 局部配置认证类\n1 2 3 4 5 # views.py class OrderView(APIView): authentication_classes = [... ] def get(self, request): 解决多认证参数传递（请求参数和请求头等等）和 必须认证，公共接口（可认证可匿名），无需认证三种类型接口 \u0026ndash;\u0026gt; 见案例4\n权限 认证组件 = [认证类，认证类，认证类，]\t-\u0026gt;\t执行每一个认证类的authenticate方法\n认证成功或失败，不会再执行后续的认证类\n返回None，执行后续认证类\n权限组件 = [权限类，权限类，权限类，] -\u0026gt; 执行所有权限类的has_permission方法，返回True通过，返回False不通过\n执行所有的权限类 默认情况下，要保证所有的权限类中的has_permission方法都返回True，即与的关系\n掌握源码流程后，可以扩展+自定义，实现其他逻辑\n快速使用 编写类 1 2 3 4 5 6 7 8 9 10 class BasePermission(metaclass=BasePermissionMetaclass): \u0026#34;\u0026#34;\u0026#34; A base class from which all permission classes should inherit. \u0026#34;\u0026#34;\u0026#34; def has_permission(self, request, view): \u0026#34;\u0026#34;\u0026#34; Return `True` if permission is granted, `False` otherwise. \u0026#34;\u0026#34;\u0026#34; return True 阅读源码可知，自定义的权限类的has_permission应返回True或False来表示是否有权限\n1 2 3 4 5 6 7 8 9 10 11 12 # ext/per.py from rest_framework.permissions import BasePermission import random class MyPermission(BasePermission): def has_permission(self, request, view): # 获取请求中的数据，然后进行校验... v1 = random.randint(1, 3) if v1 == 2: return True return False 应用类 全局应用\t在settings.py中配置\n局部应用\t在视图函数中定义permission_classes = []参数\n根据业务需求灵活配置\n1 2 3 4 5 6 7 8 9 10 11 12 REST_FRAMEWORK = { \u0026#34;UNAUTHENTICATED_USER\u0026#34;: None, # 未登录时，request.user=None \u0026#34;UNAUTHENTICATED_TOKEN\u0026#34;: None, # 未登录时，request.auth=None \u0026#34;DEFAULT_AUTHENTICATION_CLASSES\u0026#34;: [ \u0026#34;ext.auth.ParamAuthentication\u0026#34;, \u0026#34;ext.auth.HeaderAuthentication\u0026#34;, \u0026#34;ext.auth.NotAuthentication\u0026#34;, ], \u0026#34;DEFAULT_PERMISSION_CLASSES\u0026#34;:[ \u0026#34;ext.per.Mypermission\u0026#34; ] } 错误信息和多个权限类 在权限类中自定义错误信息message 1 2 3 4 5 6 7 8 9 class MyPermission(BasePermission): message = {\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;无权访问\u0026#34;} def has_permission(self, request, view): # 获取请求中的数据，然后进行校验... v1 = random.randint(1, 3) if v1 == 2: return True return False 左图为默认错误信息，右图为自定义错误信息\n多个权限类 api/per.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from rest_framework.permissions import BasePermission class MyPermission1(BasePermission): message = {\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;无权访问\u0026#34;} def has_permission(self, request, view): print(\u0026#34;MyPermission1\u0026#34;) return False class MyPermission2(BasePermission): message = {\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;无权访问\u0026#34;} def has_permission(self, request, view): print(\u0026#34;MyPermission2\u0026#34;) return False class MyPermission3(BasePermission): message = {\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;无权访问\u0026#34;} def has_permission(self, request, view): print(\u0026#34;MyPermission3\u0026#34;) return False api/views.py\n1 2 3 4 5 6 7 8 9 10 11 12 from rest_framework.views import APIView from rest_framework.response import Response from ext.per import MyPermission1, MyPermission2, MyPermission3 class OrderView(APIView): authentication_classes = [] permission_classes = [MyPermission1, MyPermission2, MyPermission3] def get(self, request): print(request.user, request.auth) return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: [11, 22, 33, 44]}) 终端只打印了MyPermission1\n说明程序会按顺序校验每个权限类，一旦有一个返回False即校验不通过，则不再校验后续权限类，只有通过每一个权限类的校验才算有权限访问\n源码流程 as_view()等方法的调用在认证组件中已详细阐明，此处直接从dispatch()方法开始\n初始化的initialize_request无涉及，直接来到initial方法，调用check_permissions方法\ncheck_permissions方法循环权限类实例对象列表permission_classes，调用has_permission方法，一旦返回False，就调用permission_denied方法，并传入错误信息message和code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class APIView(View): permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES # 权限组件的全局配置 def permission_denied(self, request, message=None, code=None): if request.authenticators and not request.successful_authenticator: raise exceptions.NotAuthenticated() raise exceptions.PermissionDenied(detail=message, code=code) def get_permissions(self): # 获取权限类对象的列表 return [permission() for permission in self.permission_classes] def check_permissions(self, request): # 循环每一个权限类对象，判断权限校验是否通过 for permission in self.get_permissions(): # 如果未通过，则抛出异常在dispatch中捕获 if not permission.has_permission(request, self): self.permission_denied( request, message=getattr(permission, \u0026#39;message\u0026#39;, None), code=getattr(permission, \u0026#39;code\u0026#39;, None) ) def initial(self, request, *args, **kwargs): self.perform_authentication(request) # 认证组件的过程，循环执行每个authenticate方法；失败则抛出异常不向下执行 self.check_permissions(request) # 权限的校验 self.check_throttles(request) def dispatch(self, request, *args, **kwargs): # 封装drf的request request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: self.initial(request, *args, **kwargs) # 反射获取get/post等方法 handler = getattr(self, request.method.lower(), self.http_method_not_allowed) # 执行相应方法 response = handler(request, *args, **kwargs) # 异常处理 except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response class OrderView(APIView): permission_classes = [MyPermission1, MyPermission2, MyPermission3] # 权限组件的局部配置 def get(self, request): print(request.user, request.auth) return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: [11, 22, 33, 44]}) 组件的拓展 通过源码可以知道，在check_permissions中，只要有一个权限类校验不通过就是无权访问，那么如何才能实现拓展，使其满足只要有一个权限类通过就是有权限呢？显而易见需要重写check_permissions方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class OrderView(APIView): authentication_classes = [] permission_classes = [MyPermission1, MyPermission2, MyPermission3] def get(self, request): print(request.user, request.auth) return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: [11, 22, 33, 44]}) def check_permissions(self, request): no_permission_objects_list = [] for permission in self.get_permissions(): if permission.has_permission(request, self): return else: no_permission_objects_list.append(permission) else: self.permission_denied( request, message=getattr(no_permission_objects_list[0], \u0026#39;message\u0026#39;, None), code=getattr(no_permission_objects_list[0], \u0026#39;code\u0026#39;, None) ) 在OrderView视图中重写check_permissions方法，则在权限校验的生命周期中，自定义的check_permissions便覆盖了APIView中的默认check_permissions实现逻辑，达到自定义拓展的效果\n自定义的check_permissions实现了一旦某一权限类校验通过，就不再进行后续校验。若所有类均未通过，则返回第一个未通过的类的错误信息\n由此可见学习源码的重要性，不仅可以学习源码中优秀的代码编写方式，还可以在原有逻辑的基础上进行拓展\n上述是修改一个视图函数的权限校验逻辑，如何应用到其他视图呢？\n可以自定义一个NbApiView的类，继承APIView并且重写check_permissions，之后要实现或逻辑的权限认证的视图只需继承NbApiView即可\next/view.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from rest_framework.views import APIView class NbApiView(APIView): def check_permissions(self, request): no_permission_objects_list = [] for permission in self.get_permissions(): if permission.has_permission(request, self): return else: no_permission_objects_list.append(permission) else: self.permission_denied( request, message=getattr(no_permission_objects_list[0], \u0026#39;message\u0026#39;, None), code=getattr(no_permission_objects_list[0], \u0026#39;code\u0026#39;, None) ) api/views.py 1 2 3 4 5 6 7 8 9 10 11 12 13 from rest_framework.views import APIView from rest_framework.response import Response from ext.per import MyPermission1, MyPermission2, MyPermission3 from ext.view import NbApiView class OrderView(NbApiView): authentication_classes = [] permission_classes = [MyPermission1, MyPermission2, MyPermission3] def get(self, request): print(request.user, request.auth) return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: [11, 22, 33, 44]}) 案例-权限处理 创建数据表 1 2 3 4 5 6 7 class UserInfo(models.Model): \u0026#34;\u0026#34;\u0026#34;用户表\u0026#34;\u0026#34;\u0026#34; role = models.IntegerField(verbose_name=\u0026#34;角色\u0026#34;, choices=((1, \u0026#34;总监\u0026#34;), (2, \u0026#34;经理\u0026#34;), (3, \u0026#34;员工\u0026#34;)), default=3) username = models.CharField(verbose_name=\u0026#34;用户名\u0026#34;, max_length=32) password = models.CharField(verbose_name=\u0026#34;用户名\u0026#34;, max_length=64) # 临时形式、后续可以使用jwt等 token = models.CharField(verbose_name=\u0026#34;TOKEN\u0026#34;, max_length=64, null=True, blank=True) 1 2 makemigrations migrate 手动添加数据\n路由系统 1 2 3 4 5 6 7 8 9 from django.urls import path from api import views urlpatterns = [ path(\u0026#39;login/\u0026#39;, views.LoginView.as_view()), path(\u0026#39;user/\u0026#39;, views.UserView.as_view()), path(\u0026#39;order/\u0026#39;, views.OrderView.as_view()), path(\u0026#39;avatar/\u0026#39;, views.AvatarView.as_view()) ] 认证组件 根据传入token返回用户对象\next/auth.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from rest_framework.authentication import BaseAuthentication from rest_framework.exceptions import AuthenticationFailed from api import models class QueryParamsAuthentication(BaseAuthentication): def authenticate(self, request): token = request.query_params.get(\u0026#39;token\u0026#39;) if not token: return user_object = models.UserInfo.objects.filter(token=token).first() if user_object: return user_object, token # request.user = 用户对象，request.auth = token return def authenticate_header(self, request): return \u0026#39;Token\u0026#39; class HeaderAuthentication(BaseAuthentication): def authenticate(self, request): token = request.META.get(\u0026#39;HTTP_AUTHORIZATION\u0026#39;) if not token: return user_object = models.UserInfo.objects.filter(token=token).first() if user_object: return user_object, token # request.user = 用户对象，request.auth = token return def authenticate_header(self, request): return \u0026#39;Token\u0026#39; class NoAuthentication(BaseAuthentication): def authenticate(self, request): raise AuthenticationFailed({\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;认证失败\u0026#34;}) def authenticate_header(self, request): return \u0026#39;Token\u0026#39; 权限组件 ext/per.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from rest_framework.permissions import BasePermission class UserPermission(BasePermission): message = {\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;无权访问1\u0026#34;} def has_permission(self, request, view): if request.user.role == 3: return True return False class ManagerPermission(BasePermission): message = {\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;无权访问1\u0026#34;} def has_permission(self, request, view): if request.user.role == 2: return True return False class BossPermission(BasePermission): message = {\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;无权访问1\u0026#34;} def has_permission(self, request, view): if request.user.role == 1: return True return False ext/view.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from rest_framework.views import APIView class NbApiView(APIView): def check_permissions(self, request): no_permission_objects_list = [] for permission in self.get_permissions(): if permission.has_permission(request, self): return else: no_permission_objects_list.append(permission) else: self.permission_denied( request, message=getattr(no_permission_objects_list[0], \u0026#39;message\u0026#39;, None), code=getattr(no_permission_objects_list[0], \u0026#39;code\u0026#39;, None) ) 视图函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import uuid from rest_framework.views import APIView from rest_framework.response import Response from api import models from ext.per import UserPermission, ManagerPermission, BossPermission from ext.view import NbApiView class LoginView(APIView): authentication_classes = [] def post(self, request): # 1.接收用户post提交的用户名密码 # print(request.query_params) # 获取get请求提交的参数 # request.data直接是一个字典类型 user = request.data.get(\u0026#39;username\u0026#39;) pwd = request.data.get(\u0026#39;password\u0026#39;) # 2.数据库校验 user_object = models.UserInfo.objects.filter(username=user, password=pwd).first() if not user_object: return Response({\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;用户名或密码错误\u0026#34;}) # 3.登陆成功 token = str(uuid.uuid4()) user_object.token = token user_object.save() return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: token}) class UserView(NbApiView): # 经理、总检、普通用户都可以访问 permission_classes = [BossPermission, ManagerPermission, UserPermission] def get(self, request): print(request.user, request.auth) return Response(\u0026#34;UserView\u0026#34;) class OrderView(NbApiView): # 经理、总监可以访问 permission_classes = [BossPermission, ManagerPermission, ] def get(self, request): print(request.user, request.auth) return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: [11, 22, 33, 44]}) class AvatarView(NbApiView): # 总监、员工可以访问 permission_classes = [BossPermission, UserPermission, ] def get(self, request): print(request.user, request.auth) return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: [11, 22, 33, 44]}) 访问效果 token2对应经理\ntoken3对应员工\n员工可以访问/avatar,访问不了/order\n经理可以访问/order,访问不了/avatar\n思考 在开发过程中,发现drf中的request对象不好用,应该如何换成另一个request类对象?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class AvatarView(NbApiView): # 总监、员工可以访问 permission_classes = [BossPermission, UserPermission, ] def get(self, request): print(request.user, request.auth) return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: [11, 22, 33, 44]}) def initialize_request(self, request, *args, **kwargs): # super().initialize_request() parser_context = self.get_parser_context(request) return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) # 再自己定义一个Request类即可完成接管,齐活! drf中的认证/权限组件与django中的中间件有什么关系?\n认证/权限组件在中间件之后\n总结 默认按权限类列表定义的顺序判断每一个权限，返回True继续判断，知道所有权限类均通过；返回False直接退出，无权限\n通过修改check_permissions的逻辑可以实现，返回True直接退出，有权限；返回False继续判断，知道有True，若全为False，无权限\n全局配置\n1 2 3 4 5 6 7 8 9 10 11 12 REST_FRAMEWORK = { \u0026#34;UNAUTHENTICATED_USER\u0026#34;: None, # 未登录时，request.user=None \u0026#34;UNAUTHENTICATED_TOKEN\u0026#34;: None, # 未登录时，request.auth=None \u0026#34;DEFAULT_AUTHENTICATION_CLASSES\u0026#34;: [ \u0026#34;ext.auth.ParamAuthentication\u0026#34;, \u0026#34;ext.auth.HeaderAuthentication\u0026#34;, \u0026#34;ext.auth.NotAuthentication\u0026#34;, ], \u0026#34;DEFAULT_PERMISSION_CLASSES\u0026#34;:[ \u0026#34;ext.per.Mypermission\u0026#34; ] } ext/per.py\n1 2 3 4 5 6 7 8 9 10 11 from rest_framework.permissions import BasePermission class UserPermission(BasePermission): # 子定义错误信息 message = {\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;无权访问1\u0026#34;} # 权限判断，True或False def has_permission(self, request, view): if request.user.role == 3: return True return False ext/view.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from rest_framework.views import APIView class NbApiView(APIView): def check_permissions(self, request): no_permission_objects_list = [] for permission in self.get_permissions(): if permission.has_permission(request, self): return else: no_permission_objects_list.append(permission) else: self.permission_denied( request, message=getattr(no_permission_objects_list[0], \u0026#39;message\u0026#39;, None), code=getattr(no_permission_objects_list[0], \u0026#39;code\u0026#39;, None) ) 视图函数\n1 2 3 4 5 6 7 8 9 10 from ext.per import UserPermission, ManagerPermission, BossPermission from ext.view import NbApiView # 继承自定义试图类，改变权限逻辑 class UserView(NbApiView): # 局部配置 permission_classes = [BossPermission, ManagerPermission, UserPermission] def get(self, request): 限流 基本逻辑 开发过程中，某个接口不想让用户访问过于频繁，需要限流机制\n例如：平台发送验证码，除了云厂商提供的限制，可能还需要做其他限制，如IP限制、验证码等等\n限制访问频率需要找到唯一标识:\n- 已登录用户，可以使用用户信息主键，ID，用户名 - 未登录用户，可以采用IP作为唯一标识 如何限制？\n维护一个唯一标识：访问记录列表\n\u0026quot;121\u0026quot;：[ 20:35 20:32 20:22 20:12 ] 限制10分钟3次\n获取当前时间 20:36\n当前时间-10分钟=计数开始时间 20：26\n删除小于20：26的记录\n计算长度\n4.1 超过，报错\n4.2 未超过，访问\n快速使用 编写类 重写了获取唯一标识的get_cache_key方法，优先使用用户id，若没有再采用默认的获取请求ip做唯一标识\n后续可以连接redis将标识做键，访问记录存储为对应的值进行联动\next/throttle.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from rest_framework.throttling import SimpleRateThrottle from django.core.cache import cache as default_cache class MyThrottle(SimpleRateThrottle): scope = \u0026#34;XXX\u0026#34; THROTTLE_RATES = {\u0026#34;XXX\u0026#34;: \u0026#34;5/m\u0026#34;} # 限制频率 cache = default_cache # redis配置 # 获取唯一标识，后续可以连接redis做操作 def get_cache_key(self, request, view): if request.user: ident = request.user.pk # 用户ID else: ident = self.get_ident(request) # 获取请求用户IP（去request中找请求头） # cache_format = \u0026#39;throttle_%(scope)s_%(ident)s\u0026#39; return self.cache_format % {\u0026#39;scope\u0026#39;: self.scope, \u0026#39;ident\u0026#39;: ident} redis配置 1.django-redis配置 -\u0026gt;\tsettings.py 2.安装django-redis\tpip install django-redis 3.启动redis服务\n1 2 3 4 5 6 7 8 9 10 11 # settings.py CACHES = { \u0026#34;default\u0026#34;: { \u0026#34;BACKEND\u0026#34;: \u0026#34;django_redis.cache.RedisCache\u0026#34;, \u0026#34;LOCATION\u0026#34;: \u0026#34;redis://127.0.0.1:6379\u0026#34;, \u0026#34;OPTIONS\u0026#34;: { \u0026#34;CLIENT_CLASS\u0026#34;: \u0026#34;django_redis.client.DefaultClient\u0026#34;, \u0026#34;PASSWORD\u0026#34;: \u0026#34;\u0026#34;, } } } 应用类 1 2 3 4 5 6 from ext.throttle import MyThrottle class LoginView(APIView): authentication_classes = [] throttle_classes = [MyThrottle,] ... 源码流程 对象加载\n获取每个限流类对象，初始化（读取限流配置，获取时间间隔和访问次数）\nallow_request判断是否限流\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 从dispatch方法的initial方法开始，调用了check_throttles方法 check_throttles方法中： self.get_throttles()，从局部配置或全局配置读取限流类列表throttle_classes，然后逐一实例化，返回一个限流类对象列表 循环上述列表，调用每一个类的allow_request方法，如果返回False即被限流，将等待时间添加到列表throttle_durations中，并获取最大等待时间duration，然后抛出异常 对于每一个限流类，循环throttle_classes实例化时，重写了scope，THROTTLE_RATES，cache，get_cache_key等等属性方法，并调用__init__初始化 调用get_rate方法，获取THROTTLE_RATES[self.scope]作为rate，如5/m 调用parse_rate方法，将rate作为参数，返回次数与间隔给num_requests和duration 每一个类执行allow_request时，调用get_cache_key获取唯一标识key，从cache中根据key获取对应维护的记录列表给history，获取当前时间now，循环history，将时间小于now-duration即计数起点的记录pop掉，比较列表剩余长度与num_requests 如果超过限制，调用throttle_failure 正常访问，调用throttle_success 正常访问，throttle_success将本次记录加入history，并更新缓存，返回True 超过限制，调用throttle_failure返回False 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 class BaseThrottle: def allow_request(self, request, view): raise NotImplementedError(\u0026#39;.allow_request() must be overridden\u0026#39;) def get_ident(self, request): pass def wait(self): return None class SimpleRateThrottle(BaseThrottle): cache = default_cache timer = time.time cache_format = \u0026#39;throttle_%(scope)s_%(ident)s\u0026#39; scope = None # 全局配置的scope与THROTTLE_RATES对应关系，可以在settings.py中配置DEFAULT_THROTTLE_RATES，在自定义限流类中只需指定scope即可 THROTTLE_RATES = api_settings.DEFAULT_THROTTLE_RATES # 初始化访问限制的次数与时间 def __init__(self): if not getattr(self, \u0026#39;rate\u0026#39;, None): self.rate = self.get_rate() # \u0026#34;5/m\u0026#34; self.num_requests, self.duration = self.parse_rate(self.rate) def get_cache_key(self, request, view): raise NotImplementedError(\u0026#39;.get_cache_key() must be overridden\u0026#39;) def get_rate(self): if not getattr(self, \u0026#39;scope\u0026#39;, None): msg = (\u0026#34;You must set either `.scope` or `.rate` for \u0026#39;%s\u0026#39; throttle\u0026#34; % self.__class__.__name__) raise ImproperlyConfigured(msg) try: # THROTTLE_RATES = {\u0026#34;XXX\u0026#34;: \u0026#34;5/m\u0026#34;} # 限制频率 # scope = \u0026#34;XXX\u0026#34; return self.THROTTLE_RATES[self.scope] except KeyError: msg = \u0026#34;No default throttle rate set for \u0026#39;%s\u0026#39; scope\u0026#34; % self.scope raise ImproperlyConfigured(msg) # 将THROTTLE_RATES切割为次数和对应时间范围 def parse_rate(self, rate): # \u0026#34;5/m\u0026#34; if rate is None: return (None, None) num, period = rate.split(\u0026#39;/\u0026#39;) num_requests = int(num) # period[0]取出s、m或h，因此自定义THROTTLE_RATES时也可以将h写成hour，因为它只读取索引为零的字符 duration = {\u0026#39;s\u0026#39;: 1, \u0026#39;m\u0026#39;: 60, \u0026#39;h\u0026#39;: 3600, \u0026#39;d\u0026#39;: 86400}[period[0]] return (num_requests, duration) # 返回 5 60 def allow_request(self, request, view): if self.rate is None: return True # 获取唯一标识 self.key = self.get_cache_key(request, view) if self.key is None: return True # 获取历史访问记录[20:35 20:32 20:22 20:12] self.history = self.cache.get(self.key, []) # 获取当前时间 self.now = self.timer() # 循环 将小于计数开始时间剔除 while self.history and self.history[-1] \u0026lt;= self.now - self.duration: self.history.pop() # 计算长度 if len(self.history) \u0026gt;= self.num_requests: return self.throttle_failure() # 超过限制，返回False return self.throttle_success() # 正常访问，返回True def throttle_success(self): # 将本次请求事件加入历史访问记录中 self.history.insert(0, self.now) self.cache.set(self.key, self.history, self.duration) return True def throttle_failure(self): return False def wait(self): if self.history: remaining_duration = self.duration - (self.now - self.history[-1]) # 还需要等待的时间 else: remaining_duration = self.duration available_requests = self.num_requests - len(self.history) + 1 if available_requests \u0026lt;= 0: return None return remaining_duration / float(available_requests) class MyThrottle(SimpleRateThrottle): scope = \u0026#34;XXX\u0026#34; THROTTLE_RATES = {\u0026#34;XXX\u0026#34;: \u0026#34;5/m\u0026#34;} # 限制频率 cache = default_cache # redis配置 # 获取唯一标识，后续可以连接redis做操作 def get_cache_key(self, request, view): if request.user: ident = request.user.pk # 用户ID else: ident = self.get_ident(request) # 获取请求用户IP（去request中找请求头） # cache_format = \u0026#39;throttle_%(scope)s_%(ident)s\u0026#39; return self.cache_format % {\u0026#39;scope\u0026#39;: self.scope, \u0026#39;ident\u0026#39;: ident} class APIView(View): throttle_classes = api_settings.DEFAULT_THROTTLE_CLASSES def get_throttles(self): # 创建限流类实例对象，返回限流类对象列表，局部配置优先于全局 return [throttle() for throttle in self.throttle_classes] def check_throttles(self, request): throttle_durations = [] # 循环每个对象 -\u0026gt; allow_request到底如何实现的 for throttle in self.get_throttles(): # 超过频率限制，不允许访问 if not throttle.allow_request(request, self): # 将等待时间添加进列表 throttle_durations.append(throttle.wait()) if throttle_durations: durations = [ duration for duration in throttle_durations if duration is not None ] # 获取最大等待时间 duration = max(durations, default=None) # 抛出异常 self.throttled(request, duration) def throttled(self, request, wait): raise exceptions.Throttled(wait) def initial(self, request, *args, **kwargs): self.perform_authentication(request) # 认证组件的过程，循环执行每个authenticate方法；失败则抛出异常不向下执行 self.check_permissions(request) # 权限的校验 self.check_throttles(request) def dispatch(self, request, *args, **kwargs): # 封装drf的request request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: self.initial(request, *args, **kwargs) # 反射获取get/post等方法 handler = getattr(self, request.method.lower(), self.http_method_not_allowed) # 执行相应方法 response = handler(request, *args, **kwargs) # 异常处理 except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response class MyThrottle(SimpleRateThrottle): scope = \u0026#34;XXX\u0026#34; THROTTLE_RATES = {\u0026#34;XXX\u0026#34;: \u0026#34;5/m\u0026#34;} # 限制频率 cache = default_cache # redis配置 # 获取唯一标识，后续可以连接redis做操作 def get_cache_key(self, request, view): if request.user: ident = request.user.pk # 用户ID else: ident = self.get_ident(request) # 获取请求用户IP（去request中找请求头） # cache_format = \u0026#39;throttle_%(scope)s_%(ident)s\u0026#39; return self.cache_format % {\u0026#39;scope\u0026#39;: self.scope, \u0026#39;ident\u0026#39;: ident} class OrderView(APIView): permission_classes = [MyPermission1, MyPermission2, MyPermission3] # 权限组件的局部配置 throttle_classes = [] def get(self, request): print(request.user, request.auth) return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: [11, 22, 33, 44]}) 案例-限流的应用 在前几个组件案例的基础上实现，下列非完整代码，主要是限流功能的实现\n无需登录，限流 10/m 登录，限流 5/m settings.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 REST_FRAMEWORK = { \u0026#34;UNAUTHENTICATED_USER\u0026#34;: None, # 未登录时，request.user=None \u0026#34;UNAUTHENTICATED_TOKEN\u0026#34;: None, # 未登录时，request.auth=None \u0026#34;DEFAULT_AUTHENTICATION_CLASSES\u0026#34;: [ \u0026#34;ext.auth.QueryParamsAuthentication\u0026#34;, \u0026#34;ext.auth.HeaderAuthentication\u0026#34;, \u0026#34;ext.auth.NoAuthentication\u0026#34;, ], \u0026#34;DEFAULT_PERMISSION_CLASSES\u0026#34;: [ ], \u0026#34;DEFAULT_THROTTLE_RATES\u0026#34;: { \u0026#34;Ip\u0026#34;: \u0026#34;10/m\u0026#34;, \u0026#34;user\u0026#34;: \u0026#34;5/m\u0026#34;, } } ext/throttle.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from rest_framework.throttling import SimpleRateThrottle from django.core.cache import cache as default_cache class IpThrottle(SimpleRateThrottle): scope = \u0026#34;Ip\u0026#34; cache = default_cache # redis配置 # 确定是匿名的，因此直接获取ip做标识即可 def get_cache_key(self, request, view): ident = self.get_ident(request) # 获取请求用户IP（去request中找请求头） # cache_format = \u0026#39;throttle_%(scope)s_%(ident)s\u0026#39; return self.cache_format % {\u0026#39;scope\u0026#39;: self.scope, \u0026#39;ident\u0026#39;: ident} class UserThrottle(SimpleRateThrottle): scope = \u0026#34;user\u0026#34; cache = default_cache # redis配置 def get_cache_key(self, request, view): ident = request.user.pk # 用户ID return self.cache_format % {\u0026#39;scope\u0026#39;: self.scope, \u0026#39;ident\u0026#39;: ident} api/views.py 1 2 3 4 5 6 7 8 9 10 class LoginView(APIView): authentication_classes = [] throttle_classes = [IpThrottle, ] ... class AvatarView(NbApiView): # 总监、员工可以访问 permission_classes = [BossPermission, UserPermission, ] throttle_classes = [UserThrottle, ] ... 总结 全局配置限流频率settings.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 REST_FRAMEWORK = { \u0026#34;UNAUTHENTICATED_USER\u0026#34;: None, # 未登录时，request.user=None \u0026#34;UNAUTHENTICATED_TOKEN\u0026#34;: None, # 未登录时，request.auth=None \u0026#34;DEFAULT_AUTHENTICATION_CLASSES\u0026#34;: [ \u0026#34;ext.auth.QueryParamsAuthentication\u0026#34;, \u0026#34;ext.auth.HeaderAuthentication\u0026#34;, \u0026#34;ext.auth.NoAuthentication\u0026#34;, ], \u0026#34;DEFAULT_PERMISSION_CLASSES\u0026#34;: [ \u0026#34;ext.per.Mypermission\u0026#34;, ], \u0026#34;DEFAULT_THROTTLE_RATES\u0026#34;: { \u0026#34;Ip\u0026#34;: \u0026#34;10/m\u0026#34;, \u0026#34;user\u0026#34;: \u0026#34;5/m\u0026#34;, } } 限流组件的定义ext/throttle.py，局部配置可覆盖全局定义的频率\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from rest_framework.throttling import SimpleRateThrottle from django.core.cache import cache as default_cache class IpThrottle(SimpleRateThrottle): # 局部配置 scope = \u0026#34;Ip\u0026#34; THROTTLE_RATES = {\u0026#34;Ip\u0026#34;: \u0026#34;5/m\u0026#34;} cache = default_cache # redis配置 # 确定是匿名的，因此直接获取ip做标识即可 def get_cache_key(self, request, view): ident = self.get_ident(request) # 获取请求用户IP（去request中找请求头） # cache_format = \u0026#39;throttle_%(scope)s_%(ident)s\u0026#39; return self.cache_format % {\u0026#39;scope\u0026#39;: self.scope, \u0026#39;ident\u0026#39;: ident} class UserThrottle(SimpleRateThrottle): # 采用全局 scope = \u0026#34;user\u0026#34; cache = default_cache # redis配置 def get_cache_key(self, request, view): ident = request.user.pk # 用户ID return self.cache_format % {\u0026#39;scope\u0026#39;: self.scope, \u0026#39;ident\u0026#39;: ident} 视图函数应用限流类\n1 2 3 4 from ext.throttle import MyThrottle class LoginView(APIView): throttle_classes = [MyThrottle, ] ... 版本 API版本控制是一个关键的实践，它有助于确保API的稳定性、可靠性和兼容性，同时为API的长期维护和演进提供支持。通过在请求中携带版本号，开发者可以更好地管理API的不同版本，并确保对客户端的影响最小化\nGET参数传递 配置文件中的VERSION_PARAM决定哪个参数表示版本信息\n参数携带的版本信息会被封装到request.version\nsettings.py 1 2 3 4 5 6 7 8 9 10 REST_FRAMEWORK = { # 携带版本信息的请求参数名 \u0026#39;VERSION_PARAM\u0026#39;: \u0026#39;version\u0026#39;, # 未传入版本参数时的默认版本 \u0026#39;DEFAULT_VERSION\u0026#39;: \u0026#34;v1\u0026#34;, # 版本范围列表 \u0026#39;ALLOWED_VERSIONS\u0026#39;: [\u0026#34;v1\u0026#34;, \u0026#34;v2\u0026#34;], # 默认版本类 \u0026#39;DEFAULT_VERSIONING_CLASS\u0026#39;: \u0026#39;rest_framework.versioning.QueryParameterVersioning\u0026#39;, } 反向生成URL 与django中的反向生成URL不同，drf反向生成的URL可以携带相关版本信息\nGET请求携带的其他参数不会自动生成\n源码解读 1 2 3 4 5 6 7 8 9 10 1 入口在APIView类的initial()方法，调用determine_version方法，将版本信息和版本类封装到request中version，versioning_scheme 2 determine_version方法，如果没有定义版本类，返回(None, None)，定义了版本类，将其实例化赋值给versioning_scheme，调用scheme的determine_version，返回结果赋值version。 2.1 版本类实例化时，继承父类，读取全局配置default_version，allowed_versions，version_param，实例化后赋值给versioning_scheme 2.2 调用scheme的determine_version，从请求参数中读取版本信息version，并且调用is_allowed_version方法，判断version值是否合法：allowed_versions为空或version是默认值或在allowed_versions范围内，合法：返回给version 当视图函数中要反向生成url时，request.versioning_scheme.reverse(\u0026#34;hm\u0026#34;,request=request) 1 调用版本类的reverse方法，并传入路由的别名 1.1 调用父类的reverse，传入路由别名，反向生成url（就是django中的） 1.2 调用replace_query_param，通过query_dict和urlencode将版本信息插入到url中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class BaseVersioning: default_version = api_settings.DEFAULT_VERSION allowed_versions = api_settings.ALLOWED_VERSIONS version_param = api_settings.VERSION_PARAM def determine_version(self, request, *args, **kwargs): msg = \u0026#39;{cls}.determine_version() must be implemented.\u0026#39; raise NotImplementedError(msg.format( cls=self.__class__.__name__ )) def reverse(self, viewname, args=None, kwargs=None, request=None, format=None, **extra): return _reverse(viewname, args, kwargs, request, format, **extra) def is_allowed_version(self, version): # 列表为空 -\u0026gt; 所有版本均可 if not self.allowed_versions: return True # version是默认值或者在allowed_versions列表范围内 return ((version is not None and version == self.default_version) or (version in self.allowed_versions)) class QueryParameterVersioning(BaseVersioning): \u0026#34;\u0026#34;\u0026#34; GET /something/?version=0.1 HTTP/1.1 Host: example.com Accept: application/json \u0026#34;\u0026#34;\u0026#34; invalid_version_message = _(\u0026#39;Invalid version in query parameter.\u0026#39;) def determine_version(self, request, *args, **kwargs): # 去请求参数中获取键为version_param的值即为版本，若不存在则读取settings.py中的默认值 version = request.query_params.get(self.version_param, self.default_version) if not self.is_allowed_version(version): raise exceptions.NotFound(self.invalid_version_message) return version # 传入视图名称和request def reverse(self, viewname, args=None, kwargs=None, request=None, format=None, **extra): # 本质上就是调用django的reverse反向生成URL url = super().reverse( viewname, args, kwargs, request, format, **extra ) # 将版本信息添加或替换进去 if request.version is not None: return replace_query_param(url, self.version_param, request.version) return url def replace_query_param(url, key, val): (scheme, netloc, path, query, fragment) = parse.urlsplit(force_str(url)) query_dict = parse.parse_qs(query, keep_blank_values=True) query_dict[force_str(key)] = [force_str(val)] query = parse.urlencode(sorted(query_dict.items()), doseq=True) return parse.urlunsplit((scheme, netloc, path, query, fragment)) class APIView(View): versioning_class = api_settings.DEFAULT_VERSIONING_CLASS def determine_version(self, request, *args, **kwargs): if self.versioning_class is None: return (None, None) # 实例化类对象，即QueryParameterVersioning(),，欸有__init__方法 scheme = self.versioning_class() # 返回版本信息与版本类对象 return (scheme.determine_version(request, *args, **kwargs), scheme) def initial(self, request, *args, **kwargs): # 将版本信息与版本类封装到request中 version, scheme = self.determine_version(request, *args, **kwargs) request.version, request.versioning_scheme = version, scheme # Ensure that the incoming request is permitted self.perform_authentication(request) self.check_permissions(request) self.check_throttles(request) def dispatch(self, request, *args, **kwargs): self.args = args self.kwargs = kwargs request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: self.initial(request, *args, **kwargs) handler = getattr(self, request.method.lower(), self.http_method_not_allowed) response = handler(request, *args, **kwargs) except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response class HomeView(APIView): # 配置文件 VERSION_PARAM # http://127.0.0.1:8000/home/?xx=123\u0026amp;page=44\u0026amp;vertion=v1 -\u0026gt; request.version versioning_class = QueryParameterVersioning def get(self, request): print(request.version) return Response(\u0026#34;...\u0026#34;) URL路径传递 urls.py中path和re_path两种方式均可\n1 2 3 4 5 6 7 8 9 10 # 源码 class URLPathVersioning(BaseVersioning): def determine_version(self, request, *args, **kwargs): version = kwargs.get(self.version_param, self.default_version) if version is None: version = self.default_version if not self.is_allowed_version(version): raise exceptions.NotFound(self.invalid_version_message) return version 从kwargs中读取版本，因此视图函数要用*args和**kwargs接收，其他源码逻辑与GET参数传递基本相同\nURL参数传递不需要*args和**kwargs接收是因为传参可以从request中可以取出\nAccept请求头传递 反向生成的URL不含版本，因为他本来就不出现在url中\n参考代码\n1 2 3 4 5 6 7 8 9 10 # urls.py from django.urls import path, re_path from api import views urlpatterns = [ # path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;home/\u0026#39;, views.HomeView.as_view(), name=\u0026#39;hm\u0026#39;), # path(\u0026#39;api/\u0026lt;str:version\u0026gt;/home/\u0026#39;, views.HomeView.as_view(), name=\u0026#39;hm\u0026#39;), # re_path(r\u0026#39;^api/(?P\u0026lt;version\u0026gt;\\w+)/home/$\u0026#39;, views.HomeView.as_view(), name=\u0026#39;hm\u0026#39;), ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # views.py from rest_framework.views import APIView from rest_framework.response import Response from rest_framework.versioning import QueryParameterVersioning, URLPathVersioning, AcceptHeaderVersioning # Create your views here. class HomeView(APIView): # 配置文件 VERSION_PARAM # http://127.0.0.1:8000/home/?xx=123\u0026amp;page=44\u0026amp;vertion=v1 -\u0026gt; request.version versioning_class = AcceptHeaderVersioning def get(self, request, *args, **kwargs): print(request.version) print(request.versioning_scheme) url = request.versioning_scheme.reverse(\u0026#39;hm\u0026#39;, request=request) print(\u0026#34;反向生成的url:\u0026#34;, url) return Response(\u0026#34;...\u0026#34;) 总结 后续开发时，一般都采用URL路径传递的形式，下列给出开发示例\nsettings.py进行全局配置 1 2 3 4 5 6 7 8 REST_FRAMEWORK = { \u0026#39;UNAUTHENTICATED_USER\u0026#39;: None, \u0026#39;VERSION_PARAM\u0026#39;: \u0026#39;version\u0026#39;, \u0026#39;DEFAULT_VERSION\u0026#39;: \u0026#34;v1\u0026#34;, \u0026#39;ALLOWED_VERSIONS\u0026#39;: [\u0026#34;v1\u0026#34;, \u0026#34;v2\u0026#34;], # 全局配置 \u0026#39;DEFAULT_VERSIONING_CLASS\u0026#39;: \u0026#39;rest_framework.versioning.URLPathVersioning\u0026#39;, } views.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from rest_framework.views import APIView from rest_framework.response import Response from rest_framework.versioning import QueryParameterVersioning, URLPathVersioning, AcceptHeaderVersioning class HomeView(APIView): # 局部配置 versioning_class = URLPathVersioning def get(self, request, *args, **kwargs): print(request.version) print(request.versioning_scheme) # 反向生成url url = request.versioning_scheme.reverse(\u0026#39;hm\u0026#39;, request=request) print(\u0026#34;反向生成的url:\u0026#34;, url) return Response(\u0026#34;...\u0026#34;) urls.py 1 2 3 4 5 6 from django.urls import path, re_path from api import views urlpatterns = [ path(\u0026#39;api/\u0026lt;str:version\u0026gt;/home/\u0026#39;, views.HomeView.as_view(), name=\u0026#39;hm\u0026#39;), ] 解析器 在 Django REST Framework（DRF）中，解析器（Parser）是用于处理传入请求数据的组件。解析器负责将原始请求数据request.body（如 JSON、表单数据、XML 等）解析成 Python 数据结构，使得视图函数可以方便地访问和操作请求数据，让序列化器可以进一步处理这些数据\n流程概述 解析器一般用于解析POST请求请求体中的数据，与内容协商机制（Content Negotiation）配合，content-type不同，客户端传递来的数据格式也不同，根据客户端的 Content-Type 头部选择合适的解析器来解析请求体\n大体的流程为：\n读取请求头 根据请求头解析数据 根据请求头获取解析器 -\u0026gt; 如JSON解析器 request.data = JSON解析器.parse request.data获取处理后的数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Form 解析器 content-type:\u0026#34;urlencode\u0026#34; class JSON 解析器 content-type:\u0026#34;application/json\u0026#34; def parse(): ... 请求者： GET http://127.0.0.1:8000/api/home/?xxx=123\u0026amp;abc=xxx --\u0026gt; request.query_params 请求头 POST http://127.0.0.1:8000/api/home/ 请求头 content-type:\u0026#34;urlencode...\u0026#34; content-type:\u0026#34;application/json\u0026#34; 请求体 name=zhangs\u0026amp;age=18 {\u0026#34;name\u0026#34;:\u0026#34;zhangs\u0026#34;,\u0026#34;age\u0026#34;:19} 常见应用 JSONParser 解析JSON格式的请求数据（application/json），返回python中的字典类型\nFormParser 解析表单（application/x-www-form-urlencoded）数据为QueryDict（字典）类型数据\nMultiPartParser 解析多部分表单数据（multipart/form-data），支持同时解析文件和表单字段，通常用于文件上传\nFileUploadParser 只能处理文件上传请求application/octet-stream\n源码流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 dispatch()的流程走完仅仅实现parsers，negotiator，parser_context等值的封装，真正的解析发生在调用request.data时 加载时触发dispatch()方法，调用initialize_request 调用get_parser_context方法，将视图对象，URL路由参数封装成对象赋值给parser_context 调用get_parsers，循环解析器类对象列表parser_classes创建实例列表parsers 调用get_content_negotiator，将协商器content_negotiation_class实例化后的对象赋值给negotiator 将parser_context，parsers，negotiator一并封装进Request中 在Request的init方法中：往parser_context中进一步添加了request和encoding数据 initialize_request执行完，调用initial方法 调用perform_content_negotiation方法，将被选择的渲染器实例赋值给accepted_renderer，将对应的媒体类型字符串赋值给accepted_media_type 循环实例化获取渲染器实例化对象列表renderers，conneg为协商器对象，调用conneg的select_renderer方法，根据客户端的 Accept 请求头和渲染器的优先级选择一个合适的渲染器 当调用request.data时，才真正地解析数据 如果_full_data有值，直接返回，无值，调用_load_data_and_files加载值 调用_parse， 循环解析器列表parsers，调用协商器的select_parser方法，将请求中的content_type与解析器内部的media_type匹配，找到匹配的解析器parser 调用解析器的parse方法，将数据解析成目标格式，赋值给parsed，返回(parsed.data, parsed.files) 用_data和_files接收解析后的数据，处理成完整的数据赋值给_full_data，下次调用request.data可以直接返回 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 class DefaultContentNegotiation(BaseContentNegotiation): # 根据请求头类型与解析器内定义的media_type匹配出对应的解析器 def select_parser(self, request, parsers): for parser in parsers: if media_type_matches(parser.media_type, request.content_type): return parser return None class FormParser(BaseParser): media_type = \u0026#39;application/x-www-form-urlencoded\u0026#39; def parse(self, stream, media_type=None, parser_context=None): parser_context = parser_context or {} encoding = parser_context.get(\u0026#39;encoding\u0026#39;, settings.DEFAULT_CHARSET) return QueryDict(stream.read(), encoding=encoding) class JSONParser(BaseParser): media_type = \u0026#39;application/json\u0026#39; renderer_class = renderers.JSONRenderer strict = api_settings.STRICT_JSON def parse(self, stream, media_type=None, parser_context=None): parser_context = parser_context or {} encoding = parser_context.get(\u0026#39;encoding\u0026#39;, settings.DEFAULT_CHARSET) try: decoded_stream = codecs.getreader(encoding)(stream) parse_constant = json.strict_constant if self.strict else None return json.load(decoded_stream, parse_constant=parse_constant) except ValueError as exc: raise ParseError(\u0026#39;JSON parse error - %s\u0026#39; % str(exc)) class Request: def __init__(self, request, parsers=None, authenticators=None, negotiator=None, parser_context=None): self._request = request self.parsers = parsers or () self.authenticators = authenticators or () self.negotiator = negotiator or self._default_negotiator() self.parser_context = parser_context self._data = Empty self._files = Empty self._full_data = Empty self._content_type = Empty self._stream = Empty if self.parser_context is None: self.parser_context = {} self.parser_context[\u0026#39;request\u0026#39;] = self self.parser_context[\u0026#39;encoding\u0026#39;] = request.encoding or settings.DEFAULT_CHARSET @property def data(self): if not _hasattr(self, \u0026#39;_full_data\u0026#39;): # 加载值 self._load_data_and_files() return self._full_data def _load_data_and_files(self): if not _hasattr(self, \u0026#39;_data\u0026#39;): self._data, self._files = self._parse() if self._files: self._full_data = self._data.copy() self._full_data.update(self._files) else: self._full_data = self._data if is_form_media_type(self.content_type): self._request._post = self.POST self._request._files = self.FILES @property def content_type(self): meta = self._request.META return meta.get(\u0026#39;CONTENT_TYPE\u0026#39;, meta.get(\u0026#39;HTTP_CONTENT_TYPE\u0026#39;, \u0026#39;\u0026#39;)) def _parse(self): # 获取请求头中的content_type media_type = self.content_type # 请求发送过来的原始数据 stream = self.stream # DefaultContentNegotiation.select_parser() # 循环解析器列表，找到content-type符合的解析器并返回 parser = self.negotiator.select_parser(self, self.parsers) # request [JSONParserm,FormParser] # 执行解析器的parse方法 parsed = parser.parse(stream, media_type, self.parser_context) try: return (parsed.data, parsed.files) except AttributeError: empty_files = MultiValueDict() return (parsed, empty_files) class APIView(View): renderer_classes = api_settings.DEFAULT_RENDERER_CLASSES parser_classes = api_settings.DEFAULT_PARSER_CLASSES content_negotiation_class = api_settings.DEFAULT_CONTENT_NEGOTIATION_CLASS def get_parser_context(self, http_request): return { \u0026#39;view\u0026#39;: self, \u0026#39;args\u0026#39;: getattr(self, \u0026#39;args\u0026#39;, ()), \u0026#39;kwargs\u0026#39;: getattr(self, \u0026#39;kwargs\u0026#39;, {}) } def get_parsers(self): return [parser() for parser in self.parser_classes] def get_content_negotiator(self): if not getattr(self, \u0026#39;_negotiator\u0026#39;, None): self._negotiator = self.content_negotiation_class() return self._negotiator def initialize_request(self, request, *args, **kwargs): # {视图对象，URL路由参数} parser_context = self.get_parser_context(request) return Request( request, # django的request parsers=self.get_parsers(), # 解析器 [JSONParser(),FormParser(),] authenticators=self.get_authenticators(), # 认证组件 [认证对象1，认证对象2] negotiator=self.get_content_negotiator(), # DefaultContentNegotiation() parser_context=parser_context # {视图对象，URL路由参数 + drf的request,encoding} ) def dispatch(self, request, *args, **kwargs): self.args = args self.kwargs = kwargs request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: self.initial(request, *args, **kwargs) handler = getattr(self, request.method.lower(), self.http_method_not_allowed) response = handler(request, *args, **kwargs) except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response def initial(self, request, *args, **kwargs): neg = self.perform_content_negotiation(request) # 第一个元素是被选择的渲染器实例，第二个元素是对应的媒体类型字符串 request.accepted_renderer, request.accepted_media_type = neg version, scheme = self.determine_version(request, *args, **kwargs) request.version, request.versioning_scheme = version, scheme # Ensure that the incoming request is permitted self.perform_authentication(request) self.check_permissions(request) self.check_throttles(request) # 该方法负责根据客户端的 Accept 请求头来确定响应的内容类型。这个方法会检查客户端接受哪些媒体类型，并根据服务器能够提供的媒体类型来选择一个合适的渲染器（Renderer） def perform_content_negotiation(self, request, force=False): renderers = self.get_renderers() conneg = self.get_content_negotiator() try: return conneg.select_renderer(request, renderers, self.format_kwarg) except Exception: if force: return (renderers[0], renderers[0].media_type) raise def get_renderers(self): return [renderer() for renderer in self.renderer_classes] def get_content_negotiator(self): if not getattr(self, \u0026#39;_negotiator\u0026#39;, None): self._negotiator = self.content_negotiation_class() return self._negotiator class HomeView(APIView): # 所有的解析器 parser_classes = [JSONParser, FormParser] # 根据请求，匹配对应的解析器 content_negotiation = DefaultContentNegotiation def post(self, request, *args, **kwargs): print(request.data, type(request.data)) return Response(\u0026#34;请求来了\u0026#34;) 解析器全局配置 如图，默认解析器有JSONParser,FormParser,MutiPartParser三种\n但为了防止不能上传图片等功能点因为默认解析器可以上传图片，导致request.data的类型的不确定性，建议局部配置\n修改全局配置\n1 2 3 4 5 6 7 8 9 10 11 REST_FRAMEWORK = { \u0026#39;UNAUTHENTICATED_USER\u0026#39;: None, \u0026#39;VERSION_PARAM\u0026#39;: \u0026#39;version\u0026#39;, \u0026#39;DEFAULT_VERSION\u0026#39;: \u0026#34;v1\u0026#34;, \u0026#39;ALLOWED_VERSIONS\u0026#39;: [\u0026#34;v1\u0026#34;, \u0026#34;v2\u0026#34;], \u0026#39;DEFAULT_VERSIONING_CLASS\u0026#39;: \u0026#39;rest_framework.versioning.QueryParameterVersioning\u0026#39;, \u0026#39;DEFAULT_PARSER_CLASSES\u0026#39;: [\u0026#39;rest_framework.parsers.JSONParser\u0026#39;, ] # 设置默认解析器只有JSONParser \u0026#39;DEFAULT_RENDERER_CLASSES\u0026#39;: \u0026#39;DEFAULT_CONTENT_NEGOTIATION_CLASS\u0026#39;: } 后续如果有上传图片的功能点，再局部配置其解析器即可\n1 parser_classes = [MutiPartParser,] 总结 解析器负责将客户端发送的请求体解析为 Python 可操作的数据结构。DRF 提供了多种默认解析器，例如 JSONParser，FormParser 和 MultiPartParser 渲染器负责将响应数据转换为客户端可读的格式。DRF 提供了多种默认渲染器，例如 JSONRenderer 和 BrowsableAPIRenderer 内容协商器负责根据客户端的 Accept 请求头和服务器支持的渲染器选择合适的渲染器。DRF 默认使用 DefaultContentNegotiation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 REST_FRAMEWORK = { \u0026#39;DEFAULT_PARSER_CLASSES\u0026#39;: [ \u0026#39;rest_framework.parsers.JSONParser\u0026#39;, \u0026#39;rest_framework.parsers.FormParser\u0026#39;, \u0026#39;rest_framework.parsers.MultiPartParser\u0026#39;, ], \u0026#39;DEFAULT_RENDERER_CLASSES\u0026#39;: [ \u0026#39;rest_framework.renderers.JSONRenderer\u0026#39;, \u0026#39;rest_framework.renderers.BrowsableAPIRenderer\u0026#39;, ] \u0026#39;DEFAULT_CONTENT_NEGOTIATION_CLASS\u0026#39;: [ \u0026#39;rest_framework.negotiation.DefaultContentNegotiation\u0026#39;, ] } 1 2 3 4 5 6 7 8 9 from rest_framework.parsers import JSONParser, FormParser, MultiPartParser from rest_framework.renderers import JSONRenderer from rest_framework.negotiation import DefaultContentNegotiation class MyUploadView(APIView): parser_classes = [JSONParser, FormParser, MultiPartParser] renderer_classes = [JSONRenderer] content_negotiation_class = DefaultContentNegotiation 元类 在Python中，一切皆对象。类本身也是对象，而元类就是用来创建类的类。元类（metaclass）可以干预类的创建，控制类的实例化\n普通的类用来定义一般对象的属性和行为，元类用来定义普通的类及其实例对象的属性和行为\n类和对象的基础知识 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 类和对象，基于类实例化对象 # 类 class Foo: # 类变量 v1 = 123 def __init__(self, name): # 实例变量 self.name = name # 类方法 def func(self): pass # 对象 obj1 = Foo(\u0026#39;test\u0026#39;) obj2 = Foo(\u0026#39;test2\u0026#39;) 创建类的两种方式 方式一就是我们平常书写的形式，而方式二就显示地展示了元类创建类的过程，本质上方式一经过处理后就是通过方式二创建类的，只是方式一更加直观且易于书写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 创建类：方式1 class Foo: v1 = 123 def func(self): return 999 # 创建类：方式2 # 类名 = type(\u0026#34;类名\u0026#34;,(父类,),{成员}) # Foo = type(\u0026#34;Foo\u0026#34;, (object,), {\u0026#34;v1\u0026#34;: 123, \u0026#34;func\u0026#34;: lambda self: 999}) obj1 = Foo() print(obj1.v1) print(obj1.func()) MyType创建类与拓展 使用元类，最常见方式是自定义一个元类，继承type，然后使用自定义的元类创建类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MyType(type): def __new__(cls, *args, **kwargs): xx = super().__new__(cls, *args, **kwargs) print(\u0026#34;创建类\u0026#34;, xx) return xx Foo = MyType(\u0026#34;Foo\u0026#34;, (object,), {\u0026#34;v1\u0026#34;: 123, \u0026#34;func\u0026#34;: lambda self: 999}) obj1 = Foo() print(obj1.v1) print(obj1.func()) # 创建类 \u0026lt;class \u0026#39;__main__.Foo\u0026#39;\u0026gt; # 123 # 999 应用在我们常用的类的创建方式时，就是要将元类指定为类的metaclass关键字参数，告诉Python在创建类时使用指定的元类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 基于type创建 # class Foo: # v1 = 123 # # def func(self): # pass # 基于MyType创建 class MyType(type): def __new__(cls, *args, **kwargs): xx = super().__new__(cls, *args, **kwargs) print(\u0026#34;创建类\u0026#34;, xx) return xx class Foo(object, metaclass=MyType): v1 = 123 def func(self): pass print(Foo) 元类中可以重写__new__和__init__方法来控制类的创建和初始化过程。__new__方法在类创建之前调用，__init__方法在类创建之后调用。\n__new__传入的name, bases, attrs其实就是我们使用方式二创建时传入的类名，父类及及属性，因此就可以在调用type的__new__创建类之前，对传入的name, bases, attrs进行修改，从而干预类的创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class MyType(type): def __new__(cls, name, bases, attrs): # Foo (\u0026lt;class \u0026#39;object\u0026#39;\u0026gt;,) {\u0026#39;__module__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;__qualname__\u0026#39;: \u0026#39;Foo\u0026#39;, \u0026#39;v1\u0026#39;: 123, \u0026#39;func\u0026#39;: \u0026lt;function Foo.func at 0x000002209BA9C310\u0026gt;} print(name, bases, attrs) # 可以在创建空间前对类进行更改，如添加/删除属性等等 del attrs[\u0026#39;v1\u0026#39;] attrs[\u0026#39;add\u0026#39;] = \u0026#39;xxx\u0026#39; xx = super().__new__(cls, name, bases, attrs) return xx class Foo(object, metaclass=MyType): v1 = 123 def func(self): pass print(Foo.add) print(Foo.v1) 继承关系 指定metaclass的类以及他所有的子类都将由指定的metaclass创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class MyType(type): def __new__(cls, name, bases, attrs): print(name, bases, attrs) xx = super().__new__(cls, name, bases, attrs) return xx class Info(object): pass class Foo(object, metaclass=MyType): pass class Bar(Foo): pass Info() Foo() Bar() drf序列化源码案例 因为UserSerializer是Serializer的子类，而Serializer指定了metaclass=SerializerMetaclass，因此由上一小节的继承关系的介绍可知，UserSerializer也将由元类SerializerMetaclass创建，因此他的实例空间中有_declared_fields属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class SerializerMetaclass(type): def __new__(cls, name, bases, attrs): data_dict = {} for k, v in list(attrs.items()): # {\u0026#34;v1\u0026#34;:123,\u0026#34;v2\u0026#34;:123,\u0026#34;v3\u0026#34;:123} if isinstance(v, int): data_dict[k] = attrs.pop(k) attrs[\u0026#39;_declared_fields\u0026#39;] = data_dict return super().__new__(cls, name, bases, attrs) class BaseSerializer(object): pass class Serializer(BaseSerializer, metaclass=SerializerMetaclass): pass class ModelSerializer(Serializer): pass class UserSerializer(ModelSerializer): v1 = 123 v2 = 456 v3 = \u0026#34;哈哈哈\u0026#34; print(UserSerializer.v3) print(UserSerializer._declared_fields) 运行结果：\n1 2 哈哈哈 {\u0026#39;v1\u0026#39;: 123, \u0026#39;v2\u0026#39;: 456} 扩展 类是由MyType创建出来，所以类其实是MyType类实例化的对象。\nBase是类，也是MyType类的对象即Mytype()； Base()是Base类实例化的对象，相当于MyType()()\n因此Base类实例化的对象就会执行MyType类的__call__ 而obj()便会执行Base类的__call__ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class MyType(type): def __new__(cls, name, bases, attrs): print(name, bases, attrs) xx = super().__new__(cls, name, bases, attrs) return xx def __call__(cls, *args, **kwargs): print(\u0026#34;执行type的call\u0026#34;) obj = cls.__new__(cls, *args, **kwargs) print(\u0026#34;----\u0026#34;) cls.__init__(obj, *args, **kwargs) return obj class Base(object, metaclass=MyType): def __init__(self): print(\u0026#34;初始化\u0026#34;) def __new__(cls, *args, **kwargs): print(\u0026#34;实例化类的对象\u0026#34;) return object.__new__(cls) def __call__(self, *args, **kwargs): print(\u0026#34;Base.call\u0026#34;) obj = Base() # 执行MyType的__call__ obj() # 执行Base的__call__ 序列化器 序列化器是Django框架中的一个重要概念，用于在Python对象和JSON等格式之间进行相互转换。通过序列化器，我们可以方便地将模型实例转换为JSON格式的数据，并且还可以对数据进行验证、创建和更新等操作。\n解析器： 将客户端发送的请求体（如JSON）解析为 Python 数据结构（如字典或列表） 解析后的数据存储在 request.data 中，供视图和序列化器使用 序列化器： 在视图中，request.data 被传递给序列化器，验证解析后的数据是否符合模型字段的要求 将验证后的数据转换为模型实例，保存到数据库 响应阶段，序列化器将模型实例序列化为Python 数据结构（通常是字典，列表，有序字典） 渲染器： 将Python 数据结构（通常是字典，列表，有序字典）进一步转换为JSON、XML 或其他格式 将序列化后的数据转换为字节流，最终返回给客户端 序列化 序列化过程 是将从ORM中获取的复杂的数据类型（如 Django 模型实例或查询集）转换为 Python 数据结构（通常是字典，列表，有序字典），然后进一步转换为 JSON、XML 或其他格式的过程（渲染器作用）\nSerializer Serializer是基础序列化器，需要手动定义每个字段\n先创建数据库，以便后续测试获取数据\n手动添加两组数据\n模型实例对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class DepartSerializer(serializers.Serializer): title = serializers.CharField() count = serializers.IntegerField() class DepartView(APIView): def get(self, request, *args, **kwargs): # 1.数据库中获取数据 obj.title obj.order obj.count depart_object = models.Depart.objects.all().first() # 模型实例 # 2.序列化器转换JSON格式 ser = DepartSerializer(instance=depart_object) # {\u0026#39;title\u0026#39;: \u0026#39;技术部\u0026#39;, \u0026#39;count\u0026#39;: 10} print(ser.data) # 字典 # 返回给用户 context = {\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: ser.data} # 字典 return Response(context) # Response对象通过渲染器将字典对象zhuan转换为JSON对象 Queryset数据集对象\nModelSerializer ModelSerializer是Serializer的子类，专门为模型数据设计，提供了基于模型类自动生成字段的功能\n如下图，指定model为Depart类并指定fields即可基于模型类Depart的字段自动生成字段\n1 2 3 4 class DepartSerializer(serializers.ModelSerializer): class Meta: model = models.Depart fields = \u0026#39;__all__\u0026#39; 字段和参数 上面我们已经学习了Serializer和ModelSerializer两种序列化器，但是仅仅如此远远达不到我们开发时需要的灵活的，因此，这一部分将介绍对字段及参数的自定义，来实现灵活开发\n前置数据准备\n返回所有字段 返回模型类中定义的所有字段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class UserSerializer(serializers.ModelSerializer): class Meta: model = models.UserInfo fields = \u0026#39;__all__\u0026#39; class UserView(APIView): def get(self, request, *args, **kwargs): models.UserInfo.objects.all().update(ctime=datetime.datetime.now()) # 1.获取数据 queryset = models.UserInfo.objects.all() # 2.序列化 ser = UserSerializer(queryset, many=True) # 3.返回给用户 context = {\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: ser.data} return Response(context) 指定字段返回 有时我们不需要将类中定义的全部字段返回，于是就需要自定义字段返回\n我们发现gender返回的是数据库中真实存储的1和2，那应该如何让他返回男和女呢？\n1 2 3 # 我们可以自定义字段 gender = serializers.CharField(source=\u0026#39;gender\u0026#39;) # 等同于直接在fields中添加 \u0026#39;gender\u0026#39;，拿到的还是1和2 # 它拿到每一个对象都会.source ，上述语句即obj.gender即可拿到数据库中的值，那么知道了这个，我们就可以自定义字段指定其source来拿到我们想要的数据 子定义字段返回 choices展示\nobj.get_gender_display即可获取choices中的男或女 foreignkey跨表查询\n通过FK进行跨表查询 时间数据格式设置\n1 2 3 4 5 6 7 8 9 class UserSerializer(serializers.ModelSerializer): gender_text = serializers.CharField(source=\u0026#39;get_gender_display\u0026#39;) depart = serializers.CharField(source=\u0026#39;depart.title\u0026#39;) ctime = serializers.DateTimeField(format=\u0026#39;%Y-%m-%d\u0026#39;) class Meta: model = models.UserInfo # fields = \u0026#39;__all__\u0026#39; fields = [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gender\u0026#39;, \u0026#39;gender_text\u0026#39;, \u0026#39;depart\u0026#39;, \u0026#39;ctime\u0026#39;] 我们已经能做到获取数据库中任何我们想要的数据，那我们可以添加非数据库字段吗？\n自定义方法 1 2 3 4 5 xxx = serializers.SerializerMethodField() # 当定义了一个名为xxx的SerializerMethodField字段时，会寻找get_xxx方法，将其返回值作为该字段的值 def get_xxx(self, obj): return \u0026#34;123\u0026#34; + obj.name # 传入的obj为每次循环的数据库对象，obj.name即可获取对应的数据库内的数据 嵌套与继承 老样子，先拓展一下我们的数据表，添加一个标签，让它与用户构建多对多的关系\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from django.db import models # Create your models here. class Depart(models.Model): title = models.CharField(verbose_name=\u0026#34;部门\u0026#34;, max_length=32) order = models.IntegerField(verbose_name=\u0026#34;顺序\u0026#34;) count = models.IntegerField(verbose_name=\u0026#34;人数\u0026#34;) class Tag(models.Model): caption = models.CharField(verbose_name=\u0026#34;标签\u0026#34;, max_length=32) class UserInfo(models.Model): name = models.CharField(verbose_name=\u0026#34;姓名\u0026#34;, max_length=32) age = models.IntegerField(verbose_name=\u0026#34;年龄\u0026#34;) gender = models.SmallIntegerField(verbose_name=\u0026#34;性别\u0026#34;, choices=((1, \u0026#34;男\u0026#34;), (2, \u0026#34;女\u0026#34;))) depart = models.ForeignKey(verbose_name=\u0026#34;部门\u0026#34;, to=\u0026#34;Depart\u0026#34;, on_delete=models.CASCADE) ctime = models.DateTimeField(verbose_name=\u0026#34;时间\u0026#34;, auto_now_add=True) tags = models.ManyToManyField(verbose_name=\u0026#34;标签\u0026#34;, to=\u0026#34;Tag\u0026#34;) 然后创建并应用迁移对象实现对数据库的操作\n添加如下数据以便后续测试\n嵌套 那么需求来了，我们如何返回一个用户对应的所有标签呢？\n最大的Queryset对象存放的是一个一个的用户对象obj，obj.tags.all()即可获得所有的标签对象[Tag1,Tag2,\u0026hellip;.]\n那么思路有了我们就可以用上面学会的自定义方法实现\n1 2 3 4 def get_xxx(self, obj): queryset = obj.tags.all() result = [{\u0026#34;id\u0026#34;: tag.id, \u0026#34;caption\u0026#34;: tag.caption} for tag in queryset] return result 我们通过自定义方法可以实现该需求，但仍需要自己书写逻辑，其实DRF的序列化支持嵌套，下面就来看看如何利用嵌套实现\n如上图，一个序列化器可以嵌套子序列化器，子序列化器中的操作与上一节介绍的无异，支持自定义字段，自定义方法等等，这样就快捷地实现了我们的需求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class D1(serializers.ModelSerializer): class Meta: model = models.Depart fields = [\u0026#34;id\u0026#34;, \u0026#34;title\u0026#34;] class D2(serializers.ModelSerializer): ex = serializers.SerializerMethodField() class Meta: model = models.Tag fields = [\u0026#34;caption\u0026#34;, \u0026#34;ex\u0026#34;] def get_ex(self, obj): return \u0026#34;xxx\u0026#34; class UserSerializer(serializers.ModelSerializer): depart = D1() tags = D2(many=True) class Meta: model = models.UserInfo fields = [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#34;depart\u0026#34;, \u0026#34;tags\u0026#34;] 总结：一般在有foreignkey或者manytomany时使用\n继承 如上图，Base序列化器定义了一个xx字段，而UserSerializer序列化器继承了Base，就可以直接使用xx字段\n1 2 3 4 5 6 7 8 class Base(serializers.Serializer): xx = serializers.CharField(source=\u0026#34;name\u0026#34;) class UserSerializer(serializers.ModelSerializer, Base): class Meta: model = models.UserInfo fields = [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#34;xx\u0026#34;] 至此，序列化数据的实现就已经全部介绍了，经过上面的学习，我们应该能够具备，无论是数据库中任何表结构关系，获取到模型对象或者是QuerySet时，可以将其进行序列化转为JSON数据返回\n源码流程 流程概述 第一步：加载字段，创建类\n1 2 class BaseSerializer(serializers.Serializer): xx = serializers.CharField(source=\u0026#34;name\u0026#34;) 在类成员中提取出xx字段并删除 汇总到 BaseSerializer._declared_fields = {\u0026quot;xx\u0026quot;:对象} 1 2 3 4 5 6 class UserSerializer(serializers.ModelSerializer, BaseSerializer): yy = serializers.CharField(source=\u0026#34;name\u0026#34;) class Meta: model = models.UserInfo fields = [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#34;yy\u0026#34; ,\u0026#34;xx\u0026#34;] 在类成员中提取出yy字段并删除 将自己即继承类中的字段都汇总到UserSerializer._declared_fields = {\u0026quot;yy\u0026quot;:对象,\u0026quot;xx\u0026quot;:对象,\u0026quot;name\u0026quot;:对象...} 第二步：序列化\n1 2 queryset = models.UserInfo.objects.all() ser = UserSerializer(queryset, many=True) # ListSerizlizer对象。循环queryset中的每一个对象，对其调用UserSerializer进行实例化 db-\u0026gt;queryset = [{id:xxx,name:xxx,age:xxx},{id:xxx,name:xxx,age:xxx},]\n1 2 instance = models.UserInfo.objects.all().first() ser = UserSerializer(instance, many=False) # UserSerializer对象 db-\u0026gt;instance = {id:xxx,name:xxx,age:xxx}\n序列化过程\ninstance = models.UserInfo.objects.all().first() ser = UserSerializer(instance, many=False) 当执行ser.data时触发 内部寻找对应关系 将UserSerializer._declared_fields中的字段与从数据库中的查到的数据的模型类字段一一对应 逐一进行序列化 创建字段对象 首先来思考一个问题\n1 2 3 4 5 class Foo(object,metaclass=type): v1 = 123 def func(self): return 999 上述代码的类，在创建时，是先加载字段v1和func还是先创建Foo这个类\n如果看不出来，我们不妨换个形式\n1 Foo = type(\u0026#34;Foo\u0026#34;, (object,), {\u0026#34;v1\u0026#34;: 123, \u0026#34;func\u0026#34;: lambda self: 999}) 现在想必很清晰了，一定是先加载完v1,func这两个字段，才能把他们当成参数传递给type去创建Foo类\n因此对于下列代码\n1 2 3 4 class InfoSerializer(serializers.Serializer): id = serializers.IntegerField() title = serializers.CharField() order = serializers.IntegerField 一定也是先加载id，title，order三个字段再实例化IntegerField()对象\u0026hellip;\n所以我们先来看DRF创建字段对象的源码实现(精简版，用于理解实现逻辑)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Field: _creation_counter = 0 def __init__(self, ...): self._creation_counter = Field._creation_counter Field._creation_counter += 1 class IntegerField(Field): def __init__(self, **kwargs): self.max_value = 111 super().__init__(**kwargs) class CharField(Field): def __init__(self, **kwargs): self.allow_blank = Flase super().__init__(**kwargs) class InfoSerializer(serializers.Serializer): id = serializers.IntegerField() # {max_value:111, _creation_counter:0} title = serializers.CharField() # {allow_blank:False, _creation_counter:1} order = serializers.IntegerField # {max_value:111, _creation_counter:2} id = serializers.IntegerField()在执行时，会实例化一个IntegerField对象，先调用自己的__init__方法给自己的实例空间写入值，如max_value，再调用父类Field的__init__方法，实现_creation_counter=0，同时将Field的类变量+1，即Field._creation_counter = 1\ntitle = serializers.CharField()在执行时，会实例化一个CharField对象，逻辑同上，但是他的_creation_counter=1，Field._creation_counter = 2\norder = serializers.IntegerField同理，_creation_counter=2，Field._creation_counter = 3\n如果还有其他XXSerializer类，他的字段也会接着给自己的_creation_counter赋值并且使类变量自增\n到这里想必大家都意识到了，Field类相当于维护了一个计数器，给每一个字段赋予了创建的顺序，意义何在？\n就是让后续开发时，根据字段创建的顺序，来决定源码处理的顺序(python3.6之前字典是无序的，因此需要这样一个逻辑)\n所以想让那个字段先处理，就把他的位置写的上面一些，例如密码password与确认密码confirm_password就需要这样一个先后关系\n创建类 上一小节中我们已经了解了字段对象的创建逻辑，那么在字段加载完成后，字段将会被作为参数传递进去创建InfoSerializer类\nInfoSerializer类的父类是Serializer类，该类在创建时指定了metaclass=SerializerMetaclass，由元类的知识我们知道，一旦Serializer指定了metaclass=SerializerMetaclass，那么其所有的子类在创建时都将指定元类为SerializerMetaclass，因此不管是继承的Serializer还是ModelSerializer，最终都由元类SerializerMetaclass创建\n下面我们就来看看SerializerMetaclass是怎么创建类的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class SerializerMetaclass(type): @classmethod def _get_declared_fields(cls, bases, attrs): # 1.1 列表推导式构建自己类的字段对象列表fields fields = [(field_name, attrs.pop(field_name)) for field_name, obj in list(attrs.items()) if isinstance(obj, Field)] # 1.2 排序 fields.sort(key=lambda x: x[1]._creation_counter) known = set(attrs) def visit(name): known.add(name) return name # 1.3 列表推导式构建父类的字段列表base_fields base_fields = [ # 将未重复的字段和实例添加到base_fields中，同时将字段标记为已添加 (visit(name), f) # 遍历父类，拿到子u但名称f和字段实例f for base in bases if hasattr(base, \u0026#39;_declared_fields\u0026#39;) for name, f in base._declared_fields.items() if name not in known ] # 1.4 将父类字段与自己的字段合并列表返回 return OrderedDict(base_fields + fields) def __new__(cls, name, bases, attrs): # 1.在attrs中新增_declared_fields字段用于存储自己的字段对象和父类的字段对象 attrs[\u0026#39;_declared_fields\u0026#39;] = cls._get_declared_fields(bases, attrs) # 2.再调用type的__new__创建类 return super().__new__(cls, name, bases, attrs) # 该类在创建时attr一共是五个值，一个整型三个字段对象和一个类 class InfoSerializer(serializers.Serializer): v1 = 123 id = serializers.IntegerField() title = serializers.CharField() order = serializers.IntegerField class Meta: 1.1 列表推导式构建自己类的字段列表fields 1 attrs --\u0026gt; {\u0026#34;v1\u0026#34;:123,\u0026#34;id\u0026#34;:IntegerField对象,\u0026#34;title\u0026#34;:CharField对象,...} 循环获取字段名field_name和字段值obj，如果obj是Field的子类，则构建元组加入fields列表，同时在attrs中剔除，\n因此循环结束后\n1 2 attrs --\u0026gt; {\u0026#34;v1\u0026#34;:123,\u0026#34;Meta\u0026#34;:对象} fields = [(\u0026#34;id\u0026#34;,对象),(\u0026#34;title\u0026#34;,对象),(\u0026#34;order\u0026#34;,对象)] 1.2 排序 还记得上一节创建字段对象时的那个计数器吗？这一步的排序便是依据各个字段对象内的_creation_counter大小进行排序\n1.3 列表推导式构建父类的字段列表base_fields 循环父类的_declared_fields，将当前类没有的字段添加到列表base_fields中\n1.4 将父类字段与自己的字段合并列表返回 简单的将两个列表相加返回，再调用type的__new__实现类的创建\n实例化类 创建对象以及前置的加载字段都是在django项目运行时就执行的，而当请求到来时，视图函数从数据库获取数据并序列化，此时就来到了实例化类的过程\n1 2 3 4 5 queryset = models.UserInfo.objects.all() ser = UserSerializer(queryset, many=True) instance = models.UserInfo.objects.all().first() ser = UserSerializer(instance, many=False) 先讲解第二个，即单个对象的情况\n实例化类依次执行BaseSerializer类的__new__，根据many属性的值分为两路，当前情况时调用父类即Field的__new__方法，Field又调用object基类的__new__创建实例\n创建实例后，会调用 BaseSerializer 的 __init__ 方法来初始化实例\n根据序列化器类继承的不同，调用ModelSerializer或Serializer的get_fields方法，该处讲解前一个情况，根据模型字段生成序列化字段\n调用get_fields() 获取序列化器中定义的所有字段fields\n显示声明的字段declared_fields 根据模型字段转化成序列化字段添加到fields中 调用_init_fields 初始化字段，将字段绑定到序列化器实例上（调用Field类的bind方法）\nfield_name parent source字段 source_attrs字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class BaseSerializer(Field): def __new__(cls, *args, **kwargs): if kwargs.pop(\u0026#39;many\u0026#39;, False): return cls.many_init(*args, **kwargs) # many=Flase则走这条逻辑，即只处理单对象，则调用object基类的__new__创建对象，紧接着寻找__init__方法 return super().__new__(cls, *args, **kwargs) def __init__(self, instance=None, data=empty, **kwargs): # 存储传入的模型实例或查询集 self.instance = instance # 获取序列化器中定义的所有字段 self.fields = self.get_fields() # 初始化字段，将字段绑定到序列化器实例上（调用Field类的bind方法） self._init_fields() def _init_fields(self): for field_name, field in self.fields.items(): field.bind(field_name, self) class ModelSerializer(Serializer): def get_fields(self): # 获取在类定义中显式声明的字段，即前面提到的id,title,order declared_fields = copy.deepcopy(self._declared_fields) # 获取模型的字段信息，去 UserSerializer 中的 Meta 中找 model 字段，即 model = models.UserInfo model = getattr(self.Meta, \u0026#39;model\u0026#39;) # 返回一个包含模型字段和关系的详细信息的字典,包含了每个字段的详细信息，例如字段类型、是否是关系字段（如外键、多对多字段等）以及其他元数据 info = model_meta.get_field_info(model) # 根据 declared_fields 和 info 来确定最终的字段名称列表。这个方法可能会根据序列化器的配置和模型的字段信息来排除或包含某些字段 field_names = self.get_field_names(declared_fields, info) fields = OrderedDict() # 根据模型字段生成序列化字段 for field_name in field_names: # 根据字段的类型和属性来决定使用哪个序列化器字段类，以及如何配置这个字段 # 简单来说就是把数据库字段转成序列化器字段类如models.CharField类转成CharField类，然后放入fields中 field_class, field_kwargs = self.build_field( source, info, model, depth ) # Create the serializer field. fields[field_name] = field_class(**field_kwargs) # Add in any hidden fields. fields.update(hidden_fields) return fields class Field: def bind(self, field_name, parent): # 字段的名称，用于在序列化器中标识字段 self.field_name = field_name # 字段所属的序列化器实例 self.parent = parent # 字段的源名称，用于从模型实例中获取数据，默认情况下，source 与字段名称相同 if self.source is None: self.source = field_name if self.source == \u0026#39;*\u0026#39;: self.source_attrs = [] else: # 如果是外键跨表的形式如depart.title，就会被分割成一个列表 self.source_attrs = self.source.split(\u0026#39;.\u0026#39;) 返回的ser是UserSerializer序列化器实例，是一个复杂的对象，包含以下内容\ninstance：传入的模型实例（UserInfo 对象） data：序列化后的数据（通过访问 ser.data 获得） fields：序列化器中定义的所有字段 每个字段实例都有自己的属性和方法，例如： field_name：字段的名称。 parent：字段所属的序列化器实例。 source：字段的源名称，用于从模型实例中获取数据。 to_representation：将字段值转换为可序列化的格式。 to_internal_value：将输入数据转换为 Python 数据类型。 errors：如果序列化过程中发生错误，存储错误信息 ser.data 是序列化后的数据\n当你访问 ser.data 时，序列化器会将模型实例转换为一个 Python 字典 这个字典可以被进一步渲染为 JSON 格式，以便返回给客户端 如果是第一个，即多个对象的queryset的情况\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class BaseSerializer(Field): def __new__(cls, *args, **kwargs): # many=True，处理多对象，进入if内部，执行many_init方法 if kwargs.pop(\u0026#39;many\u0026#39;, False): return cls.many_init(*args, **kwargs) return super().__new__(cls, *args, **kwargs) def __init__(self, instance=None, data=empty, **kwargs): self.instance = instance @classmethod def many_init(cls, *args, **kwargs): child_serializer = cls(*args, **kwargs) # 实例化当前类（如 UserSerializer）的单个对象序列化器 # 创建一个字典，将 child_serializer 作为子序列化器传递给 ListSerializer list_kwargs = { \u0026#39;child\u0026#39;: child_serializer, } meta = getattr(cls, \u0026#39;Meta\u0026#39;, None) list_serializer_class = getattr(meta, \u0026#39;list_serializer_class\u0026#39;, ListSerializer) # Meta中可以定义，默认为ListSerializer return list_serializer_class(*args, **list_kwargs) # 实例化ListSerializer()，并将每一个UserSerializer对象传入 class ListSerializer(BaseSerializer): def __init__(self, *args, **kwargs): # 子序列化器实例，用于序列化每个对象 self.child = kwargs.pop(\u0026#39;child\u0026#39;) super().__init__(*args, **kwargs) 此时返回的就是不是UserSerializer对象了，而是ListSerializer对象，其实就是一个列表，列表内元素都是UserSerializer对象\n序列化过程 上一节我们介绍的实例化类对应的是ser = UserSerializer(queryset, many=True)这一行代码，此时只是将数据封装到对象中，真正触发序列化动作的是当ser.data\nUserSerializer类 我们先说当前类，即UserSerializer类触发序列化的情况\nser.data \u0026ndash;\u0026gt; Serializer中的data \u0026ndash;\u0026gt; BaseSerializer中的data \u0026ndash;\u0026gt; self._data = self.to_representation(self.instance)\n于是关键就是Serializer的to_representation方法，我们下面来分析：\n获取所有的字段fields = Serializer._readable_fields __\n__self._readable_fields读取Serializer.fields的值 循环所有的字段对象for field in fields:\n去数据库对象中依据字段的信息获取数据attribute = field.get_attribute(instance)\nbind方法处理过的source，如果是外键跨表的形式如depart.title，就会被分割成一个列表存入self.source_attrs\nField.get_attribute调用 get_attribute(instance, self.source_attrs)\nget_attribute循环source_attrs取出instance对应该source的值\n将获取到的数据通过序列化器类的to_representation方法转变一下格式加入ret中，如IntegerField会对数据进行int()转换等等ret[field.field_name] = field.to_representation(attribute)\n将ref返回\n精简版的源码，结合上述文字流程食用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 from django.contrib.gis.gdal.raster import source class BaseSerializer(Field): @property def data(self): if not hasattr(self, \u0026#39;_data\u0026#39;): if self.instance is not None and not getattr(self, \u0026#39;_errors\u0026#39;, None): # 真正实现序列化的步骤 self._data = self.to_representation(self.instance) elif hasattr(self, \u0026#39;_validated_data\u0026#39;) and not getattr(self, \u0026#39;_errors\u0026#39;, None): self._data = self.to_representation(self.validated_data) else: self._data = self.get_initial() return self._data class Serializer(BaseSerializer, metaclass=SerializerMetaclass): @property def data(self): ret = super().data return ReturnDict(ret, serializer=self) def to_representation(self, instance): ret = OrderedDict() # 1.获取所有的字段：先前加载的 InfoSerializer._declared_fields + Meta中指定的fields字段一一创建对象 fields = self._readable_fields # 2. 循环所有的字段对象(都是序列化器字段对象) for field in fields: # 去字段对象中依据字段的信息获取数据 attribute = field.get_attribute(instance) # 将获取到的数据通过序列化器类的to_representation方法转换为适合 JSON 序列化的格式加入ret中，如IntegerField会对数据进行int()转换等等 ret[field.field_name] = field.to_representation(attribute) return ret @property def _readable_fields(self): for field in self.fields.values(): yield field class Field: def __init__(self, ...source): self.source = source def get_attribute(self, instance): # 此处的source_attrs是source经过bind处理后的 # get_attribute就去instance中取出对应的值，如列表[\u0026#34;depart\u0026#34;,\u0026#34;title\u0026#34;]，会循环去取值，返回instance.depart.title return get_attribute(instance, self.source_attrs) # 根据sourse和instance取得对应的值 def get_attribute(instance, attrs): for attr in attrs: try: if isinstance(instance, Mapping): instance = instance[attr] else: instance = getattr(instance, attr) except ObjectDoesNotExist: return None if is_simple_callable(instance): try: instance = instance() except (AttributeError, KeyError) as exc: # If we raised an Attribute or KeyError here it\u0026#39;d get treated # as an omitted field in `Field.get_attribute()`. Instead we # raise a ValueError to ensure the exception is not masked. raise ValueError( \u0026#39;Exception raised in callable attribute \u0026#34;{}\u0026#34;; original exception was: {}\u0026#39;.format(attr, exc)) return instance class IntegerField(Field): def __init__(self, **kwargs): self.max_value = 111 super().__init__(**kwargs) def to_representation(self, value): return int(value) class InfoSerializer(serializers.ModelSerializer): id = serializers.IntegerField() # {max_value:111, _creation_counter:0,source=\u0026#34;id\u0026#34;}source未定义默认为字段名 title = serializers.CharField() # {allow_blank:False, _creation_counter:1} order = serializers.IntegerField # {max_value:111, _creation_counter:2} class Meta: model = models.Depart fields = \u0026#34;__all__\u0026#34; ListSerializer类 如果已经了解了UserSerializer类的序列化过程，那么ListSerializer类的序列化只是在他的基础上多了一个循环\nser.data \u0026ndash;\u0026gt; ListSerializer中的data \u0026ndash;\u0026gt; BaseSerializer中的data \u0026ndash;\u0026gt; self._data = self.to_representation(self.instance)\n但是此时的to_representation优先找的是ListSerializer类中自己定义的的\n我们先看一下ListSerializer类是如何实例化的\n1 2 3 4 5 6 7 8 9 @classmethod def many_init(cls, *args, **kwargs): child_serializer = cls(*args, **kwargs) # 实例化UserSerializer对象 list_kwargs = { \u0026#39;child\u0026#39;: child_serializer, } meta = getattr(cls, \u0026#39;Meta\u0026#39;, None) list_serializer_class = getattr(meta, \u0026#39;list_serializer_class\u0026#39;, ListSerializer) # Meta中可以定义，默认为ListSerializer return list_serializer_class(*args, **list_kwargs) # 实例化ListSerializer()，并将每一个UserSerializer对象传入 可以看到，ListSerializer类中是一个个UserSerializer对象\n因此ListSerializer类在to_representation方法时循环每一个UserSerializer对象并调用它的to_representation方法，显然，就是一遍又一遍的重复我们上一小节分析的UserSerializer类序列化的过程，此处便不再叙述\n1 2 3 4 5 6 7 8 class ListSerializer(BaseSerializer): def to_representation(self, data): iterable = data.all() if isinstance(data, models.Manager) else data return [ self.child.to_representation(item) for item in iterable ] 数据校验 路由 -\u0026gt; 视图 -\u0026gt; request.data -\u0026gt; 校验(序列化器的类) -\u0026gt; 操作数据\n接口设计的小规范：\n1 2 3 4 5 6 获取数据： api/v1/user/\t-\u0026gt;GET请求\t-\u0026gt;获取数据列表\tmodels.UserInfo.objects.all() api/v1/user/2/\t-\u0026gt;GET请求\t-\u0026gt;获取单个数据\tmodels.UserInfo.objects.filter(id=2).first() api/v1/user\t-\u0026gt;POST请求 -\u0026gt;新增数据 api/v1/user/3/\t-\u0026gt;PUT请求\t-\u0026gt;更新数据 下面我们就先看看序列化器的数据校验功能\n基本校验 序列化器中定义好字段，当请求到达时，视图函数获取到请求数据，将数据传递到序列化器中进行校验，利用if语句，如果校验通过，返回数据，不通过，返回错误信息\n还有第二种写法，在校验时传入raise_exception=True参数，校验通过则程序自动向下执行，不通过则抛出异常，由APIView类的dispatch方法接收异常处理\n建议采用第一种方式，因为可以自己控制异常的处理，如更改错误信息等，而方式二会由DRF处理，不可控\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class DepartSerializer(serializers.Serializer): username = serializers.CharField(required=True) password = serializers.CharField(required=True) class DepartView(APIView): def post(self, request, *args, **kwargs): # 1.获取原始数据 # print(request.data) # 2.校验(写法一) ser = DepartSerializer(data=request.data) if ser.is_valid(): print(ser.validated_data) else: print(ser.errors) # 校验(写法二) # ser = DepartSerializer(data=request.data) # ser.is_valid(raise_exception=True) # print(ser.validated_data) return Response(\u0026#34;...\u0026#34;) 内置和正则校验 上一小节我们学习了数据校验的基本格式，但对传递来的数据的限制仅仅是非空，当需求增加时，我们需要对字段有更严格的控制，就需要用到更多序列化器内置的要求以及使用正则自定义格式校验\n如下，title字段定义了最大长度和最小长度，order定义了最大值和最小值，level字段则是给出了choices，只可选择1或2(输入整形还是字符串并不影响)。这几个校验是序列化器内置的\n除此之外我们还可以子定义正则校验，代码中email1和email2使用的正则表达式相同，是DRF给我们封装好的，而email3就是我们通过自己写正则表达式创建的规则，并且可以定制错误信息\n1 2 3 4 5 6 7 8 9 10 11 12 from django.core.validators import RegexValidator, EmailValidator class DepartSerializer(serializers.Serializer): title = serializers.CharField(required=True, max_length=20, min_length=6) order = serializers.IntegerField(required=False, max_value=100, min_value=10) level = serializers.ChoiceField(choices=[(\u0026#34;1\u0026#34;, \u0026#34;高级\u0026#34;), (2, \u0026#34;中级\u0026#34;)]) # email1 = serializers.EmailField() # email2 = serializers.CharField(validators=[EmailValidator(message=\u0026#34;邮箱格式错误\u0026#34;)]) email3 = serializers.CharField(validators=[RegexValidator(r\u0026#34;\\d+\u0026#34;, message=\u0026#34;格式错误\u0026#34;)]) 钩子校验 和Django中的Form和ModelForm类似，DRF的序列化器的数据校验也提供了每个字段的钩子方法和一个全局的钩子方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from rest_framework import exceptions email = serializers.CharField(validators=[RegexValidator(r\u0026#34;\\d+\u0026#34;, message=\u0026#34;格式错误\u0026#34;)]) def validate_email(self, value): print(value) if len(value) \u0026gt; 6: raise exceptions.ValidationError(\u0026#34;字段钩子校验失败\u0026#34;) return value def validate(self, attrs): print(\u0026#34;validate=\u0026#34;, attrs) # api_settings.NON_FIELD_ERRORS_KEY # raise exceptions.ValidationError(\u0026#34;全局钩子校验失败\u0026#34;) return attrs 每个字段的钩子方法以validate_字段名命令，而全局的钩子方法直接是validate方法，他会在各个字段的钩子方法校验完成后再对整体进行校验，因此传入的attr是所有字段和值组成的有序字典，而单个字段钩子方法的value是单个字段的值\n总的钩子方法的错误信息也与字段的钩子不同\n它的错误信息的键默认是non_field_errors，可以通过api_settings.NON_FIELD_ERRORS_KEY进行配置，如：\n即可实现自定义错误信息的键\nModel校验 上面我们实现数据校验一直是使用Serializer类，所有的字段都需要我们自己编写，如果用到的字段大多都是将数据库中的字段，那么就可以采用ModelSerializer来自动生成字段\n1 2 3 4 5 6 7 8 9 10 11 class DepartModelSerializer(serializers.ModelSerializer): email3 = serializers.CharField(validators=[RegexValidator(r\u0026#34;\\d+\u0026#34;, message=\u0026#34;格式错误\u0026#34;)]) class Meta: model = models.Depart fields = [\u0026#39;title\u0026#39;, \u0026#39;order\u0026#39;, \u0026#39;count\u0026#39;, \u0026#39;email3\u0026#39;] extra_kwargs = { \u0026#39;title\u0026#39;: {\u0026#34;max_length\u0026#34;: 5, \u0026#34;min_length\u0026#34;: 1}, \u0026#39;order\u0026#39;: {\u0026#34;min_value\u0026#34;: 5}, \u0026#39;count\u0026#39;: {\u0026#34;validators\u0026#34;: [RegexValidator(r\u0026#34;\\d+\u0026#34;, message=\u0026#34;格式错误\u0026#34;)]} } 只需要在class Meta的fiedls填入需要生成的字段即可，若还需要自定义字段就像Serializer类一样自定义，然后加入到fields列表中即可\n采用这种方式不需要我们自己编写字段，那么校验规则怎么添加呢？\n只需要在class Meta中extra_kwargs字典中编写即可，示例如上\n保存数据之普通字段 如果采用的是Serializer类的序列化器，那么在保存数据时需要手动的进行ORM操作保存数据，但如果使用了\nModelSerializer类的序列化器，就可以使用.save实现便捷操作，他会一键保存到数据库对应的表中\n但是问题来了?如果用户传入的字段数大于或小于数据表对应的字段数，我们能不能手动调整？答案是肯定的\n字段过多，如下述例子，email3是多余字段，不需要存入数据库，我们可以在进行.save之前将其pop掉，用一个变量接收，可用于后续判断。该操作可用于注册时的重复输入密码步骤\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class DepartModelSerializer(serializers.ModelSerializer): email3 = serializers.CharField(validators=[RegexValidator(r\u0026#34;\\d+\u0026#34;, message=\u0026#34;格式错误\u0026#34;)]) class Meta: model = models.Depart fields = [\u0026#39;title\u0026#39;, \u0026#39;order\u0026#39;, \u0026#39;count\u0026#39;, \u0026#39;email3\u0026#39;] extra_kwargs = { \u0026#39;title\u0026#39;: {\u0026#34;max_length\u0026#34;: 5, \u0026#34;min_length\u0026#34;: 1}, \u0026#39;order\u0026#39;: {\u0026#34;min_value\u0026#34;: 5}, \u0026#39;count\u0026#39;: {\u0026#34;validators\u0026#34;: [RegexValidator(r\u0026#34;\\d+\u0026#34;, message=\u0026#34;格式错误\u0026#34;)]} } class DepartView(APIView): def post(self, request, *args, **kwargs): ser = DepartModelSerializer(data=request.data) if ser.is_valid(): print(\u0026#34;视图\u0026#34;, ser.validated_data) email3 = ser.validated_data.pop(\u0026#39;email3\u0026#39;) ser.save() else: print(ser.errors) return Response(\u0026#34;...\u0026#34;) 字段过少，比如创建用户时数据库中要添加操作人id，这显然不是用户输入的，所以我们就需要手动添加数据\n下列代码中数据库有count字段，但前端用户并未输入，因此便可以在.save时将count字段作为参数传入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class DepartModelSerializer(serializers.ModelSerializer): class Meta: model = models.Depart fields = [\u0026#39;title\u0026#39;, \u0026#39;order\u0026#39;] extra_kwargs = { \u0026#39;title\u0026#39;: {\u0026#34;max_length\u0026#34;: 5, \u0026#34;min_length\u0026#34;: 1}, \u0026#39;order\u0026#39;: {\u0026#34;min_value\u0026#34;: 5}, } class DepartView(APIView): def post(self, request, *args, **kwargs): ser = DepartModelSerializer(data=request.data) if ser.is_valid(): print(\u0026#34;视图\u0026#34;, ser.validated_data) ser.save(count=11) else: print(ser.errors) return Response(\u0026#34;...\u0026#34;) 保存数据之FK和M2M字段 上一小节我们介绍了普通字段的保存，但是还有两种比较特殊的字段，如果是ForeignKey字段和ManytoMany字段，该怎么进行保存\n我们先看FK\n如图，depart是一个FK，关联到职位表，用户在输入时实际上输入的是职位的id，如果id不存在就会报错。如果需求升级，就算该职位存在，还要做进一步校验，就需要我们的钩子方法，在钩子中，value值其实已经是用户传入的id对应的depart对象了，我们就可以对对象进行操作、校验\n然后我们来看M2M的情况\ntags是一个M2M，关联userinfo和tags表，用户传入一个列表，1和2对应tags表的id，表示当前创建用户与id=1和id=2的标签都有关联，于是在userinfo_tags表中生成两条记录\n此时，钩子方法中的value是一个列表，每一个元素都是传入的id对应的tags对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class UsModelSerializer(serializers.ModelSerializer): class Meta: model = models.UserInfo fields = [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gender\u0026#39;, \u0026#39;depart\u0026#39;, \u0026#39;tags\u0026#39;] class USView(APIView): def post(self, request, *args, **kwargs): ser = UsModelSerializer(data=request.data) if ser.is_valid(): print(\u0026#34;视图\u0026#34;, ser.validated_data) ser.save() else: print(ser.errors) return Response(\u0026#34;...\u0026#34;) 在FK的那个示例中，字段名为depart，但我们传入的实际上是depart_id，那么如果直接在fields中写depart_id而不是depart会发生什么呢?\nModelSerializer在处理数据库字段时其实并没有depart_id这个字段，他只有一个FK字段叫depart，所以他会报错，但是我们可以通过自定义的方式就可以实现\n1 2 3 4 5 6 class UsModelSerializer(serializers.ModelSerializer): depart_id = serializers.IntegerField() class Meta: model = models.UserInfo fields = [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gender\u0026#39;, \u0026#39;depart_id\u0026#39;, \u0026#39;tags\u0026#39;] 在M2M字段中，用户输入的是存放tags对象的id列表，而到达钩子方法是存放tags对象的列表，那么我们能不能自定义，让他传入钩子时就是用户输入的存放tags对象的id列表，然后可以进一步做操作，最后返回的还是存放tags对象的列表，使保存数据的功能不受影响\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class UsModelSerializer(serializers.ModelSerializer): tags = serializers.ListField() class Meta: model = models.UserInfo fields = [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gender\u0026#39;, \u0026#39;depart\u0026#39;, \u0026#39;tags\u0026#39;] def validated_tags(self, value): print(value) queryset = models.Tag.objects.filter(id__in=value) return queryset class USView(APIView): def post(self, request, *args, **kwargs): ser = UsModelSerializer(data=request.data) if ser.is_valid(): print(\u0026#34;视图\u0026#34;, ser.validated_data) ser.save() else: print(ser.errors) return Response(\u0026#34;...\u0026#34;) 数据校验总结 自定义 Serializer + 字段 自定义 Serializer + 字段（内置加正则） 自定义 Serializer + 字段（内置加正则）+ 字段钩子 + 全局钩子 自定义 ModelSerializer + 自定义字段 + extra_kwargs + save保存数据（字段多：pop；字段少：参数传入） 自定义 ModelSerializer + FK -\u0026gt; 自动获取关联数据 depart -\u0026gt; 自定义depart_id字段 自定义 ModelSerializer + M2M -\u0026gt; 获取关联数据 -\u0026gt; ListField或DictField + 钩子 校验和序列化二合一 序列化与数据校验结合\n创建用户 : {\u0026ldquo;user\u0026rdquo;:\u0026ldquo;xxx\u0026rdquo;,\u0026ldquo;password\u0026rdquo;:\u0026ldquo;xxx\u0026rdquo;}\n数据校验 连接数据库，保存数据，并返回数据库对象 为什么不直接返回创建用户时传递的 {\u0026ldquo;user\u0026rdquo;:\u0026ldquo;xxx\u0026rdquo;,\u0026ldquo;password\u0026rdquo;:\u0026ldquo;xxx\u0026rdquo;} 因为数据库有些字段时自动生成的，只有返回数据库对象才能保证数据的完整 将数据库对象序列化再返回 两个序列化器分别实现 我们在数据校验开头部分就提出过这种需求，当数据校验通过存入数据库，还需将创建的数据库对象经过序列化返回回去，现在我们就来看看这个实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class DpModelSerializer(serializers.ModelSerializer): class Meta: model = models.Depart fields = \u0026#34;__all__\u0026#34; class Dp2ModelSerializer(serializers.ModelSerializer): class Meta: model = models.Depart fields = [\u0026#34;id\u0026#34;, \u0026#34;title\u0026#34;, \u0026#34;count\u0026#34;] class DpView(APIView): def post(self, request, *args, **kwargs): ser = DpModelSerializer(data=request.data) if ser.is_valid(): instance = ser.save() print(instance) xx = Dp2ModelSerializer(instance=instance) return Response(xx.data) else: return Response(ser.errors) 上述代码在数据校验时使用DpModelSerializer，校验通过保存到数据库，ser.save()会返回存入数据库的对象，用instance接收，再\n传递给完成序列化功能的Dp2ModelSerializer，实现需求\n一个序列化器实现 这样分开写两个序列化器感觉有点繁杂，可以使用一个吗？答案是可以的，但是返回序列化时返回给用户的也是数据库中的所有字段，因为fields = \u0026quot;__all__\u0026quot;\n可以只使用一个序列化器，实现数据校验保存数据时校验保存所有字段，但是序列化返回时只返回三个字段吗？这时候就要用到字段的两个特殊参数read_only和write_only\n1 2 3 4 5 6 7 8 class DpModelSerializer(serializers.ModelSerializer): class Meta: model = models.Depart fields = [\u0026#34;id\u0026#34;, \u0026#34;title\u0026#34;, \u0026#34;order\u0026#34;, \u0026#34;count\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, \u0026#34;count\u0026#34;: {\u0026#34;write_only\u0026#34;: True}, } 上述代码实现在输入时只需要输入title、order、count三个字段，在返回给用户时只返回id、title、order三个字段。完成共用一个序列化器实现数据校验保存和数据序列化字段的灵活自定义。可以应用在用户注册时，在注册时需要用户输入密码，但是返回数据展示时不会将密码返回\n上面我们已经实现了控制哪些字段返回，但是返回的格式还需要进一步操作。例如对于一个choices的gender字段，返回时是返回数据中真实存储的1或2吗，显然不是，而应该是对应的男和女。同样的还有FK字段depart，我们应该单单返回一个depart_id吗？显然也不是，而是应该将其depart_title或其他信息返回，这应该怎么实现呢？\nchoices字段 方式一：自定义一个gender_info字段获取男或女的文字信息，然后将gender_info和gender字段分别设置read_only和write_only\n1 2 3 4 5 6 7 8 9 10 class UusModelSerializer(serializers.ModelSerializer): gender_info = serializers.CharField(source=\u0026#34;get_gender_display\u0026#34;, read_only=True) class Meta: model = models.UserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;gender\u0026#34;, \u0026#34;depart\u0026#34;, \u0026#34;gender_info\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, \u0026#34;gender\u0026#34;: {\u0026#34;write_only\u0026#34;: True} } 方式二：自定义一个方法字段（自带read_only），返回一个字典，包含多个信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 class UusModelSerializer(serializers.ModelSerializer): v1 = serializers.SerializerMethodField() class Meta: model = models.UserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;gender\u0026#34;, \u0026#34;depart\u0026#34;, \u0026#34;v1\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, \u0026#34;gender\u0026#34;: {\u0026#34;write_only\u0026#34;: True} } def get_v1(self, obj): return {\u0026#34;id\u0026#34;: obj.gender, \u0026#34;text\u0026#34;: obj.get_gender_display()} FK字段 方式一：自定义字段加read_only，指定source关联外键数据\n1 2 3 4 5 6 7 8 9 10 class UusModelSerializer(serializers.ModelSerializer): v1 = serializers.CharField(source=\u0026#34;depart.title\u0026#34;, read_only=True) class Meta: model = models.UserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;gender\u0026#34;, \u0026#34;depart\u0026#34;, \u0026#34;v1\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, \u0026#34;depart\u0026#34;: {\u0026#34;write_only\u0026#34;: True} } 方式二：利用序列化器的嵌套\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class P1ModelSerializer(serializers.ModelSerializer): class Meta: model = models.Depart fields = \u0026#34;__all__\u0026#34; class UusModelSerializer(serializers.ModelSerializer): v1 = P1ModelSerializer(read_only=True, source=\u0026#34;depart\u0026#34;) class Meta: model = models.UserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;gender\u0026#34;, \u0026#34;depart\u0026#34;, \u0026#34;v1\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, \u0026#34;depart\u0026#34;: {\u0026#34;write_only\u0026#34;: True} } 如果是二合一的形式，视图函数中可以进一步缩写\n1 2 3 4 5 6 7 8 9 class UusView(APIView): def post(self, request, *args, **kwargs): ser = UusModelSerializer(data=request.data) if ser.is_valid(): ser.save() return Response(ser.data) else: return Response(ser.errors) 不需要重复指定数据校验和序列化数据的序列化器，只需如上编写即可实现同样的功能\n拓展 现在有一个需求，要求编写一个序列化类，实现创建用户\n提供：{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;xsss\u0026rdquo;,\u0026ldquo;age\u0026rdquo;:\u0026ldquo;11\u0026rdquo;,\u0026ldquo;gender\u0026rdquo;:1}\n返回：{\u0026ldquo;id\u0026rdquo;=1,\u0026ldquo;name\u0026rdquo;:\u0026ldquo;xsss\u0026rdquo;,\u0026ldquo;gender\u0026rdquo;:\u0026ldquo;男\u0026rdquo;}\nmodel类如下\n1 2 3 4 class NbUserInfo(models.Model): name = models.CharField(verbose_name=\u0026#34;姓名\u0026#34;, max_length=32) age = models.IntegerField(verbose_name=\u0026#34;年龄\u0026#34;) gender = models.SmallIntegerField(verbose_name=\u0026#34;性别\u0026#34;, choices=((1, \u0026#34;男\u0026#34;), (2, \u0026#34;女\u0026#34;))) 我们上面学习的对choices的处理，都是要新定义一个字段来展示男/女，但需求中不管是提供的字段还是返回的字段都叫gender，显然不是我们原先学习的方法可以实现的\n重点就是要将返回的gender设置为男/女\n如果我们自定义一个名为gender的SerializerMethodField字段，然后在里面去调用get_gender_display，输出是符合要求了，但是SerializerMethodField字段默认是read_only，会导致传过来的gender失效，即用户无法输入了\n如果定义成其他类型的字段，没有read_only，用户可以输入了，但是get_gender的钩子又不执行了，导致输出还是1/2\n可以发现，上面两种实现都只实现了一半功能，那没有可能将他们组合起来呢？\n这就需要我们了解SerializerMethodField字段到底是如何实现钩子的？\n1 2 3 4 5 6 7 8 9 10 11 # 序列化 ser = NbModelSerializer(instance=对象) ser.data # 数据校验+序列化 ser = NbModelSerializer(data=request.data) if ser.is_valid(): ser.save() ser.data # 关键就是ser.data 真正的序列化动作发生在ser.data触发时\nSerializerMethodField字段与其他字段的不同在于：\n类变量维护了一个method_name默认等于None 在实例化前执行bind方法method_name赋值为\u0026rsquo;get_{field_name}' 最后调用to_representation方法处理值时会找到父类的get_{field_name}，返回钩子方法的返回值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class BaseSerializer(Field): @property def data(self): self._data = self.to_representation(self.instance) return self._data class Serializer(BaseSerializer, metaclass=SerializerMetaclass): @property def data(self): ret = super().data return ReturnDict(ret, serializer=self) @property def _readable_fields(self): for field in self.fields.values(): if not field.write_only: yield field def to_representation(self, instance): ret = OrderedDict() # [CharField字段对象，SerializerMethodField字段对象(比其他普通字段多维护了一个method_name)...] 有bind方法会先执行过 fields = self._readable_fields # 找到所有字段，筛选出可读的（可序列化的） ==\u0026gt; 没有写write_only for field in fields: attribute = field.get_attribute(instance) # CharField.get_attribute(instance) ==\u0026gt; instance.字段.字段 (通过循环source列表) # SerializerMethodField.get_attribute(instance) ==\u0026gt; instance.xx ==\u0026gt; None (SerializerMethodField的source默认为*) ret[field.field_name] = field.to_representation(attribute) # CharField.to_representation 就是用str()包裹一下 # SerializerMethodField.to_representation 根据method_name去父类拿钩子方法 return ret class SerializerMethodField(Field): def __init__(self, method_name=None, **kwargs): self.method_name = method_name kwargs[\u0026#39;source\u0026#39;] = \u0026#39;*\u0026#39; kwargs[\u0026#39;read_only\u0026#39;] = True super().__init__(**kwargs) def bind(self, field_name, parent): # The method name defaults to `get_{field_name}`. if self.method_name is None: self.method_name = \u0026#39;get_{field_name}\u0026#39;.format( field_name=field_name) # method_name默认为None，到此处处理为\u0026#34;get_gender\u0026#34; super().bind(field_name, parent) def to_representation(self, value): method = getattr(self.parent, self.method_name) return method(value) class NbModelSerializer(serializers.ModelSerializer): gender = seriallizer.SerializerMethodField() class Meta: model = models.NbUserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;gender\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, } def get_gender(self, obj): return obj.get_gender_display() 明白了它是如何实现钩子方法之后，我们就可以将原先的两种方式进行结合，关键就在于对下面两条语句的拓展，因为他们决定了字段的实际值\nattribute = field.get_attribute(instance) ret[field.field_name] = field.to_representation(attribute) 方法一 我们通过自定义一个NbCharField字段，模仿SerializerMethodField维护一个method_name，并且找时机让他根据反射找到钩子并执行即可\n下列实现在__init__和__bind__中维护一个钩子方法，名为xget_字段名，然后在执行get_attribute时让他执行钩子，将1/2变为男/女，因为我们继承的是IntegerField，它的to_representation方法应该是用int()包裹attribute，而我们的attribute不是数字字符串，因此to_representation也需要重写，否则强加int()会报错，至此就完成了功能实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class NbCharField(serializers.IntegerField): def __init__(self, method_name=None, **kwargs): self.method_name = method_name super().__init__(**kwargs) def bind(self, field_name, parent): if self.method_name is None: self.method_name = \u0026#39;xget_{field_name}\u0026#39;.format(field_name=field_name) super().bind(field_name, parent) def get_attribute(self, instance): method = getattr(self.parent, self.method_name) return method(instance) def to_representation(self, value): return str(value) class NbModelSerializer(serializers.ModelSerializer): gender = NbCharField() class Meta: model = models.NbUserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;gender\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, } def xget_gender(self, obj): return obj.get_gender_display() class NbView(APIView): def post(self, request, *args, **kwargs): ser = NbModelSerializer(data=request.data) if ser.is_valid(): ser.save() return Response(ser.data) else: return Response(ser.errors) 可以看到，通过自定义一个字段的方式还是比较繁琐的\n方法二 方法一的本质是改变字段的get_attribute和to_representation方法来改变获取字段的值，而这两个方法都定义Serializer类的to_representation方法中，那么我们何不直接重写一个to_representation方法，使得当字段存在名为nb_字段名的钩子方法时，走我们自己的获取数据流程，而没有名为nb_字段名的钩子方法时，就按原本的逻辑走\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class NbModelSerializer(serializers.ModelSerializer): class Meta: model = models.NbUserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;gender\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, } def to_representation(self, instance): ret = OrderedDict() fields = self._readable_fields for field in fields: if hasattr(self, \u0026#39;nb_%s\u0026#39; % field.field_name): value = getattr(self, \u0026#34;nb_%s\u0026#34; % field.field_name)(instance) ret[field.field_name] = value else: try: attribute = field.get_attribute(instance) except SkipField: continue check_for_none = attribute.pk if isinstance(attribute, PKOnlyObject) else attribute if check_for_none is None: ret[field.field_name] = None else: ret[field.field_name] = field.to_representation(attribute) return ret def nb_gender(self, obj): return obj.get_gender_display() class NbView(APIView): def post(self, request, *args, **kwargs): ser = NbModelSerializer(data=request.data) if ser.is_valid(): ser.save() return Response(ser.data) else: return Response(ser.errors) 如果我们还有其他需要序列化器需要实现这个功能，是否需要在每一个序列化器中自定义一遍to_representation？\n我们可以将自定义的方法打包到一个类中，在需要实现该功能的序列化器类中继承即可\next/hook.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from collections import OrderedDict from rest_framework.fields import SkipField from rest_framework.relations import PKOnlyObject class NbHookSerializer(object): def to_representation(self, instance): ret = OrderedDict() fields = self._readable_fields for field in fields: if hasattr(self, \u0026#39;nb_%s\u0026#39; % field.field_name): value = getattr(self, \u0026#34;nb_%s\u0026#34; % field.field_name)(instance) ret[field.field_name] = value else: try: attribute = field.get_attribute(instance) except SkipField: continue check_for_none = attribute.pk if isinstance(attribute, PKOnlyObject) else attribute if check_for_none is None: ret[field.field_name] = None else: ret[field.field_name] = field.to_representation(attribute) return ret views.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from ext.hook import NbHookSerializer class NbModelSerializer(NbHookSerializer, serializers.ModelSerializer): class Meta: model = models.NbUserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;gender\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, } def nb_gender(self, obj): return obj.get_gender_display() class NbView(APIView): def post(self, request, *args, **kwargs): ser = NbModelSerializer(data=request.data) if ser.is_valid(): ser.save() return Response(ser.data) else: return Response(ser.errors) 博客系统案例 开发一个博客系统，包含：博客列表、详细、登录、注册、评论、点赞、发布博客\n表结构 项目的创建在此不赘述，翻看先前文章即可\n先创建表结构，models.py内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from django.db import models class UserInfo(models.Model): username = models.CharField(verbose_name=\u0026#34;用户名\u0026#34;, max_length=32, db_index=True) password = models.CharField(verbose_name=\u0026#34;密码\u0026#34;, max_length=64) token = models.CharField(verbose_name=\u0026#34;TOKEN\u0026#34;, max_length=64, null=True, blank=True,db_index=True) class Blog(models.Model): category_choices = ((1, \u0026#34;云计算\u0026#34;), (2, \u0026#34;Python全栈\u0026#34;), (3, \u0026#34;Go开发\u0026#34;)) category = models.IntegerField(verbose_name=\u0026#34;分类\u0026#34;, choices=category_choices) image = models.CharField(verbose_name=\u0026#34;封面\u0026#34;, max_length=255) title = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32) summary = models.CharField(verbose_name=\u0026#34;简介\u0026#34;, max_length=256) text = models.TextField(verbose_name=\u0026#34;博文\u0026#34;) ctime = models.DateTimeField(verbose_name=\u0026#34;创建时间\u0026#34;, auto_now_add=True) creator = models.ForeignKey(verbose_name=\u0026#34;创建者\u0026#34;, to=\u0026#34;UserInfo\u0026#34;, on_delete=models.CASCADE) comment_count = models.PositiveIntegerField(verbose_name=\u0026#34;评论数\u0026#34;, default=0) favor_count = models.PositiveIntegerField(verbose_name=\u0026#34;赞数\u0026#34;, default=0) class Favor(models.Model): \u0026#34;\u0026#34;\u0026#34; 赞 \u0026#34;\u0026#34;\u0026#34; blog = models.ForeignKey(verbose_name=\u0026#34;博客\u0026#34;, to=\u0026#34;Blog\u0026#34;, on_delete=models.CASCADE) user = models.ForeignKey(verbose_name=\u0026#34;用户\u0026#34;, to=\u0026#34;UserInfo\u0026#34;, on_delete=models.CASCADE) create_datetime = models.DateTimeField(verbose_name=\u0026#34;创建时间\u0026#34;, auto_now_add=True) class Meta: constraints = [ models.UniqueConstraint(fields=[\u0026#39;blog\u0026#39;, \u0026#39;user\u0026#39;], name=\u0026#39;uni_favor_blog_user\u0026#39;) ] class Comment(models.Model): \u0026#34;\u0026#34;\u0026#34; 评论表 \u0026#34;\u0026#34;\u0026#34; blog = models.ForeignKey(verbose_name=\u0026#34;博客\u0026#34;, to=\u0026#34;Blog\u0026#34;, on_delete=models.CASCADE) user = models.ForeignKey(verbose_name=\u0026#34;用户\u0026#34;, to=\u0026#34;UserInfo\u0026#34;, on_delete=models.CASCADE) content = models.CharField(verbose_name=\u0026#34;内容\u0026#34;, max_length=150) create_datetime = models.DateTimeField(verbose_name=\u0026#34;创建时间\u0026#34;, auto_now_add=True) 做一个数据库迁移\n1 2 makemigrations migrate 添加测试数据(可以采用离线脚本的形式，或者创建一个内容如下的接口，通过访问来创建)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from django.shortcuts import render, HttpResponse from api import models # Create your views here. def db(request): v1 = models.UserInfo.objects.create(username=\u0026#39;qwj\u0026#39;, password=\u0026#39;123\u0026#39;) v2 = models.UserInfo.objects.create(username=\u0026#39;xzq\u0026#39;, password=\u0026#39;123\u0026#39;) models.Blog.objects.create( category=1, image=\u0026#34;xxx/xxxx.pbg\u0026#34;, title=\u0026#39;郑经理\u0026#39;, summary=\u0026#39;...\u0026#39;, text=\u0026#39;说大话电话卡文化的哇\u0026#39;, creator=v1, ) models.Blog.objects.create( category=2, image=\u0026#34;xxx/xxxx.pbg\u0026#34;, title=\u0026#39;证据\u0026#39;, summary=\u0026#39;...\u0026#39;, text=\u0026#39;大家啊我到家啊五角大楼\u0026#39;, creator=v2, ) return HttpResponse(\u0026#34;成功\u0026#34;) 数据如下\n功能实现 博客列表 路由\n1 path(\u0026#39;api/blog/\u0026#39;, views.BlogView.as_view()), 视图类\n1 2 3 4 5 6 7 8 9 10 11 12 13 class BlogView(APIView): def get(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;获取博客列表\u0026#34;\u0026#34;\u0026#34; # 1.读取数据库中的博客信息 queryset = models.Blog.objects.all().order_by(\u0026#39;-id\u0026#39;) # 2.序列化 ser = BlogSerializer(queryset, many=True) # 3.返回 context = {\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data} return Response(context) 序列化器\n写法一：自定义字段 1 2 3 4 5 6 7 8 class BlogSerializer(serializers.ModelSerializer): category = serializers.CharField(source=\u0026#34;get_category_display\u0026#34;) ctime = serializers.DateTimeField(format=\u0026#34;%Y-%m-%d\u0026#34;) creator_name = serializers.CharField(source=\u0026#34;creator.username\u0026#34;) class Meta: model = models.Blog fields = [\u0026#34;category\u0026#34;, \u0026#34;image\u0026#34;, \u0026#34;title\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;ctime\u0026#34;, \u0026#34;comment_count\u0026#34;, \u0026#34;favor_count\u0026#34;, \u0026#34;creator\u0026#34;, \u0026#34;creator_name\u0026#34;] 写法二：自定义方法 1 2 3 4 5 6 7 8 9 10 11 class BlogSerializer(serializers.ModelSerializer): category = serializers.CharField(source=\u0026#34;get_category_display\u0026#34;) ctime = serializers.DateTimeField(format=\u0026#34;%Y-%m-%d\u0026#34;) creator = serializers.SerializerMethodField() class Meta: model = models.Blog fields = [\u0026#34;category\u0026#34;, \u0026#34;image\u0026#34;, \u0026#34;title\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;ctime\u0026#34;, \u0026#34;comment_count\u0026#34;, \u0026#34;favor_count\u0026#34;, \u0026#34;creator\u0026#34;] def get_creator(self, obj): return {\u0026#34;id\u0026#34;: obj.creator_id, \u0026#34;name\u0026#34;: obj.creator.username} 写法三：嵌套 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class BlogUserSerializers(serializers.ModelSerializer): class Meta: model = models.UserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;username\u0026#34;] class BlogSerializer(serializers.ModelSerializer): category = serializers.CharField(source=\u0026#34;get_category_display\u0026#34;) ctime = serializers.DateTimeField(format=\u0026#34;%Y-%m-%d\u0026#34;) creator = BlogUserSerializers() class Meta: model = models.Blog fields = [\u0026#34;category\u0026#34;, \u0026#34;image\u0026#34;, \u0026#34;title\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;ctime\u0026#34;, \u0026#34;comment_count\u0026#34;, \u0026#34;favor_count\u0026#34;, \u0026#34;creator\u0026#34;] 博客详细与评论 路由\n1 2 3 path(\u0026#39;api/blog/\u0026lt;int:pk\u0026gt;/\u0026#39;, views.BlogDetailView.as_view()), path(\u0026#39;api/comment/\u0026lt;int:blog_id\u0026gt;/\u0026#39;, views.CommentView.as_view()), # path(\u0026#39;api/comment/\u0026#39;, views.CommentView.as_view()), 获取博客评论的接口可以写成api/comment?blog_id=1，但是不太美观，建议使用api/comment/1然后在视图中接收\n博客详细\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class BlogDetailSerializers(serializers.ModelSerializer): category = serializers.CharField(source=\u0026#34;get_category_display\u0026#34;) ctime = serializers.DateTimeField(format=\u0026#34;%Y-%m-%d\u0026#34;) creator = BlogUserSerializers() class Meta: model = models.Blog fields = \u0026#34;__all__\u0026#34; class BlogDetailView(APIView): def get(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;获取博客详细\u0026#34;\u0026#34;\u0026#34; # 1.获取ID pk = kwargs.get(\u0026#39;pk\u0026#39;) # 2.根据ID获取对象 instance = models.Blog.objects.filter(id=pk).first() if not instance: return Response({\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: \u0026#34;不存在\u0026#34;}) # 3.序列化 ser = BlogDetailSerializers(instance, many=False) # 4.返回 context = {\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data} return Response(context) 评论\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class CommentSerializers(serializers.ModelSerializer): user = serializers.CharField(source=\u0026#34;user.username\u0026#34;) class Meta: model = models.Comment fields = [\u0026#34;id\u0026#34;, \u0026#34;content\u0026#34;, \u0026#34;user\u0026#34;] class CommentView(APIView): def get(self, request, blog_id): \u0026#34;\u0026#34;\u0026#34;评论列表\u0026#34;\u0026#34;\u0026#34; # 1.根据ID获取评论对象 queryset = models.Comment.objects.filter(blog_id=blog_id) # 2.序列化 ser = CommentSerializers(queryset, many=True) # 3.返回 context = {\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data} return Response(context) 测试数据还是通过访问/db/来添加:\n1 2 3 # 在def db(request)中添加如下操作 models.Comment.objects.create(content=\u0026#34;yi\u0026#34;, blog_id=1, user_id=1) models.Comment.objects.create(content=\u0026#34;er\u0026#34;, blog_id=1, user_id=2) 结果如下\n基本功能已经实现了，但是现在只是评论的展示，后续如果用户要添加评论时，user字段是需要用户传入id值的，而展示则是展示用户名，所以此处需要我们进行一个拓展，让该字段在校验时传入的是id，在序列化时是返回用户名\n用到先前提到的自定义NbHookSerializer类实现\n在etc/hook.py中定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from collections import OrderedDict from rest_framework.fields import SkipField from rest_framework.relations import PKOnlyObject class NbHookSerializer(object): def to_representation(self, instance): ret = OrderedDict() fields = self._readable_fields for field in fields: if hasattr(self, \u0026#39;nb_%s\u0026#39; % field.field_name): value = getattr(self, \u0026#34;nb_%s\u0026#34; % field.field_name)(instance) ret[field.field_name] = value else: try: attribute = field.get_attribute(instance) except SkipField: continue check_for_none = attribute.pk if isinstance(attribute, PKOnlyObject) else attribute if check_for_none is None: ret[field.field_name] = None else: ret[field.field_name] = field.to_representation(attribute) return ret 对CommentSerializers类做如下修改即可\n1 2 3 4 5 6 7 8 9 10 from ext.hook import NbHookSerializer class CommentSerializers(NbHookSerializer, serializers.ModelSerializer): class Meta: model = models.Comment fields = [\u0026#34;id\u0026#34;, \u0026#34;content\u0026#34;, \u0026#34;user\u0026#34;] def nb_user(self, obj): return obj.user.username 注册 路由\n1 path(\u0026#39;api/register/\u0026#39;, views.RegisterView.as_view()), 视图+序列化\n字段的钩子方法执行顺序按fields中定义的顺序来\n通过定义read_only和write_only区别数据校验和序列化字段的异同\nself.initial_data可以拿到传入的所有数据\n数据保存时字段过多的处理方法：pop\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class RegisterSerializers(serializers.ModelSerializer): confirm_password = serializers.CharField(write_only=True) class Meta: model = models.UserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;, \u0026#34;confirm_password\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, \u0026#34;password\u0026#34;: {\u0026#34;write_only\u0026#34;: True}, } def validate_password(self, value): print(\u0026#34;密码：\u0026#34;, value) return value def validate_confirm_password(self, value): print(\u0026#34;重复密码：\u0026#34;, value) password = self.initial_data.get(\u0026#39;password\u0026#39;) if password != value: raise ValidationError(\u0026#34;密码不一致\u0026#34;) return value class RegisterView(APIView): def post(self, request): \u0026#34;\u0026#34;\u0026#34;注册\u0026#34;\u0026#34;\u0026#34; # 1.提交数据 # {\u0026#34;username\u0026#34;:\u0026#34;qiuwj\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;123\u0026#34;,\u0026#34;confirm_password\u0026#34;:\u0026#34;123\u0026#34;} # 2.数据校验+保存 ser = RegisterSerializers(data=request.data) if ser.is_valid(): confirm_password = ser.validated_data.pop(\u0026#39;confirm_password\u0026#39;) ser.save() return Response({\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data}) else: return Response({\u0026#39;code\u0026#39;: 1001, \u0026#39;error\u0026#39;: \u0026#34;注册失败\u0026#34;, \u0026#39;detail\u0026#39;: ser.errors}) 登录 路由\n1 path(\u0026#39;api/login/\u0026#39;, views.LoginView.as_view()), 视图加序列化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class LoginSerializers(serializers.ModelSerializer): class Meta: model = models.UserInfo fields = [\u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;] class LoginView(APIView): def post(self, request): \u0026#34;\u0026#34;\u0026#34;登录\u0026#34;\u0026#34;\u0026#34; # 1.提交数据 # {\u0026#34;username\u0026#34;:\u0026#34;qiuwj\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;123\u0026#34;} # 2.数据校验+保存 ser = LoginSerializers(data=request.data) if not ser.is_valid(): return Response({\u0026#39;code\u0026#39;: 1001, \u0026#39;error\u0026#39;: \u0026#34;校验失败\u0026#34;, \u0026#39;detail\u0026#39;: ser.errors}) instance = models.UserInfo.objects.filter(**ser.validated_data).first() if not instance: return Response({\u0026#39;code\u0026#39;: 1002, \u0026#39;error\u0026#39;: \u0026#34;用户名或密码错误\u0026#34;}) token = str(uuid.uuid4()) instance.token = token instance.save() return Response({\u0026#39;code\u0026#39;: 1000, \u0026#39;token\u0026#39;: token}) 发布评论 发表评论可以采用单独写一个视图类的序列化类来实现，但更规范的写法是整合到上面的博客评论中，当GET请求时，是展示评论，当POST请求时，是发布评论\n因为发布评论必须先登录，因此要用到认证类，但是展示评论不需要登录，而这两个功能是写在一个视图类中的，所以我们可以采用匿名用户，当未登录时不让他抛出错误而是返回None，最后如果request.user不为None则说明登陆了，如果是None说明是未登录，不让发表。\n在请求参数中携带token作身份标识，在请求体中传递评论内容\n认证类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from rest_framework.authentication import BaseAuthentication from api import models class BlogAuthentication(BaseAuthentication): def authenticate(self, request): token = request.query_params.get(\u0026#39;token\u0026#39;) if not token: return instance = models.UserInfo.objects.filter(token=token).first() if not instance: return return instance, token def authenticate_header(self, request): return \u0026#39;API\u0026#39; 视图类+序列化类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class CommentSerializers(NbHookSerializer, serializers.ModelSerializer): class Meta: model = models.Comment fields = [\u0026#34;id\u0026#34;, \u0026#34;content\u0026#34;, \u0026#34;user\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, \u0026#34;user\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, } def nb_user(self, obj): return obj.user.username class CommentView(APIView): authentication_classes = [BlogAuthentication, ] def get(self, request, blog_id): \u0026#34;\u0026#34;\u0026#34;评论列表\u0026#34;\u0026#34;\u0026#34; # 1.根据ID获取评论对象 queryset = models.Comment.objects.filter(blog_id=blog_id) # 2.序列化 ser = CommentSerializers(queryset, many=True) # 3.返回 context = {\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data} return Response(context) def post(self, request, blog_id): \u0026#34;\u0026#34;\u0026#34;发布评论\u0026#34;\u0026#34;\u0026#34; if not request.user: return Response({\u0026#39;code\u0026#39;: 3000, \u0026#39;data\u0026#39;: \u0026#34;认证失败\u0026#34;}) blog_object = models.Blog.objects.filter(id=blog_id).first() if not blog_object: return Response({\u0026#39;code\u0026#39;: 2000, \u0026#39;data\u0026#39;: \u0026#34;博客不存在\u0026#34;}) ser = CommentSerializers(data=request.data) if not ser.is_valid(): return Response({\u0026#39;code\u0026#39;: 1002, \u0026#39;data\u0026#39;: \u0026#34;内容审核不通过\u0026#34;}) ser.save(blog=blog_object, user=request.user) return Response({\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data}) 点赞 路由\n1 path(\u0026#39;api/favor/\u0026#39;, views.FavorView.as_view()), 因为点赞功能必须登录，因此新增NoAuthentication认证类，当BlogAuthentication类为校验通过时，就抛出错误\n认证类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from rest_framework.authentication import BaseAuthentication from api import models from rest_framework import exceptions class BlogAuthentication(BaseAuthentication): def authenticate(self, request): token = request.query_params.get(\u0026#39;token\u0026#39;) if not token: return instance = models.UserInfo.objects.filter(token=token).first() if not instance: return return instance, token def authenticate_header(self, request): return \u0026#39;API\u0026#39; class NoAuthentication(BaseAuthentication): def authenticate(self, request): raise exceptions.AuthenticationFailed({\u0026#34;code\u0026#34;: 2000, \u0026#34;error\u0026#34;: \u0026#34;认证失败\u0026#34;}) def authenticate_header(self, request): return \u0026#39;API\u0026#39; 序列化+视图函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class FavorSerializer(serializers.ModelSerializer): class Meta: model = models.Favor fields = [\u0026#34;id\u0026#34;, \u0026#34;blog\u0026#34;] class FavorView(APIView): authentication_classes = [BlogAuthentication, NoAuthentication, ] def post(self, request): ser = FavorSerializer(data=request.data) if not ser.is_valid(): return Response({\u0026#39;code\u0026#39;: 1002, \u0026#39;error\u0026#39;: \u0026#34;校验失败\u0026#34;, \u0026#39;detail\u0026#39;: ser.errors}) # 1.已存在 不赞 exists = models.Favor.objects.filter(user=request.user, **ser.validated_data).exists() if exists: return Response({\u0026#39;code\u0026#39;: 1005, \u0026#39;error\u0026#39;: \u0026#34;已赞过，不允许重复点赞\u0026#34;}) # 2.不存在 ser.save(user=request.user) return Response({\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data}) 新建博客 和查看评论与发布评论相同，博客列表与新建博客也放到一个视图类中\n因为新建博客必须登录，可以采取匿名用户+对request.user判断的形式来做权限校验\n视图类\n关键在于对get和post请求时不同字段的隐藏和显示处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class BlogSerializer(NbHookSerializer, serializers.ModelSerializer): ctime = serializers.DateTimeField(format=\u0026#34;%Y-%m-%d\u0026#34;, read_only=True) creator = BlogUserSerializers(read_only=True) class Meta: model = models.Blog fields = [\u0026#34;id\u0026#34;, \u0026#34;category\u0026#34;, \u0026#34;image\u0026#34;, \u0026#34;title\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;text\u0026#34;, \u0026#34;ctime\u0026#34;, \u0026#34;comment_count\u0026#34;, \u0026#34;favor_count\u0026#34;, \u0026#34;creator\u0026#34;] extra_kwargs = { \u0026#34;comment_count\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, \u0026#34;favor_count\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, \u0026#34;text\u0026#34;: {\u0026#34;write_only\u0026#34;: True}, } def nb_category(self, obj): return obj.get_category_display() class BlogView(APIView): authentication_classes = (BlogAuthentication,) def get(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;获取博客列表\u0026#34;\u0026#34;\u0026#34; # 1.读取数据库中的博客信息 queryset = models.Blog.objects.all().order_by(\u0026#39;-id\u0026#39;) # 2.序列化 ser = BlogSerializer(queryset, many=True) # 3.返回 context = {\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data} return Response(context) def post(self, request, *args, **kwargs): if not request.user: return Response({\u0026#39;code\u0026#39;: 3000, \u0026#39;data\u0026#39;: \u0026#34;认证失败\u0026#34;}) ser = BlogSerializer(data=request.data) if not ser.is_valid(): return Response({\u0026#39;code\u0026#39;: 1002, \u0026#39;error\u0026#39;: \u0026#34;校验失败\u0026#34;, \u0026#39;detail\u0026#39;: ser.errors}) ser.save(creator=request.user) return Response({\u0026#39;code\u0026#39;: 1000, \u0026#34;data\u0026#34;: ser.data}) 实现效果\n总结 主要拓展了权限类的或关系以及关于序列化器传入与输出的字段名相同但内容不同的拓展\n但存在几个问题\n点赞评论后博客对应点赞数和评论数未变化 \u0026ndash;\u0026gt; f操作自加一 博客列表和评论列表的分页功能 案例完整项目命名为blog1.zip\n分页 在django中原生的分页组件不够好用，于是我们自定义了一个组件，而在drf中，他为我们提供了三个还不错的分页组件，下面我们来介绍一下比较常用的两个\nPageNumberPagination，适用于显示页面、上一下、下一页\n/accounts/?page=4 /accounts/?page=6 /accounts/?page=7 /accounts/?page=7\u0026amp;page_size=1000000000 /accounts/?page=7\u0026amp;page_size=2 /accounts/?page=7\u0026amp;page_size=4\n后端给前端返回的数据参考，由前端自己划分\nres = { \u0026quot;data\u0026quot;:[xxx,xxxx,xxxx,xxx,xxxx], \u0026quot;total\u0026quot;:1000, \u0026quot;persize\u0026quot;:20 } LimitOffsetPagination，滚动翻页\n从第二条开始,取十条\n/accounts/?offset=2\u0026amp;limit=10 /accounts/?offset=10\u0026amp;limit=10\n还可以添加条件,如id大于10的中从第0个开始,取十条\n/accounts/?lastid=10\u0026amp;offset=0\u0026amp;limit=10 /accounts/?lastid=20\u0026amp;offset=0\u0026amp;limit=10\nPageNumberPagination 初步使用 在url中传入不同的page,可以返回对应页的数据\n一共有三篇博客,page_size=2,因此第一页两条数据,第二页一条数据\n将该分页组件应用到前面的案例中,新的BlogView类实现如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class BlogView(APIView): authentication_classes = (BlogAuthentication,) def get(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;获取博客列表\u0026#34;\u0026#34;\u0026#34; # 1.读取数据库中的博客信息 queryset = models.Blog.objects.all().order_by(\u0026#39;-id\u0026#39;) # 分页 from rest_framework.pagination import PageNumberPagination pager = PageNumberPagination() result = pager.paginate_queryset(queryset, request, self) # 2.序列化 ser = BlogSerializer(result, many=True) # 3.返回 context = {\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data} return Response(context) 写了三行代码,改了一个值就实现了分页功能\n12.1.2 自定义PageNumberPagination类 通过继承PageNumberPagination类,自定义一些字段的值实现定制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class MyPageNumberPagination(PageNumberPagination): page_size_query_param = \u0026#39;size\u0026#39; page_query_param = \u0026#39;p\u0026#39; max_page_size = 2 page_size = 1 class BlogView(APIView): authentication_classes = (BlogAuthentication,) def get(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;获取博客列表\u0026#34;\u0026#34;\u0026#34; # 1.读取数据库中的博客信息 queryset = models.Blog.objects.all().order_by(\u0026#39;-id\u0026#39;) # 分页 pager = MyPageNumberPagination() result = pager.paginate_queryset(queryset, request, self) # 2.序列化 ser = BlogSerializer(result, many=True) # 3.返回 context = {\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data} return Response(context) 12.1.3 分页的返回值处理 将序列化后的数据丢入get_paginated_response函数,封装返回值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class BlogView(APIView): authentication_classes = (BlogAuthentication,) def get(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;获取博客列表\u0026#34;\u0026#34;\u0026#34; # 1.读取数据库中的博客信息 queryset = models.Blog.objects.all().order_by(\u0026#39;id\u0026#39;) # 2.处理得到分页后的queryset from rest_framework.pagination import PageNumberPagination pager = PageNumberPagination() result = pager.paginate_queryset(queryset, request, self) # 3.序列化 ser = BlogSerializer(result, many=True) # 4.获取分页返回结果 response = pager.get_paginated_response(ser.data) return response get_paginated_response函数实现逻辑\n1 2 3 4 5 6 7 8 class PageNumberPagination(BasePagination): def get_paginated_response(self, data): return Response(OrderedDict([ (\u0026#39;count\u0026#39;, self.page.paginator.count), (\u0026#39;next\u0026#39;, self.get_next_link()), (\u0026#39;previous\u0026#39;, self.get_previous_link()), (\u0026#39;results\u0026#39;, data) ])) 就是封装了一个有序字典并放到response中,如果不满意它的内容可以自定义PageNumberPagination类重写get_paginated_response方法,手动封装\n12.1.4 终极使用 例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class BlogView(APIView): authentication_classes = (BlogAuthentication,) def get(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;获取博客列表\u0026#34;\u0026#34;\u0026#34; # 1.读取数据库中的博客信息 queryset = models.Blog.objects.all().order_by(\u0026#39;id\u0026#39;) # 2.处理得到分页后的queryset from rest_framework.pagination import PageNumberPagination pager = PageNumberPagination() result = pager.paginate_queryset(queryset, request, self) # 3.序列化 ser = BlogSerializer(result, many=True) # 4.获取分页返回结果 response = pager.get_paginated_response(ser.data) return response LimitOffsetPagination 基本使用及拓展 LimitOffsetPagination与PageNumberPagination的使用相同，唯一的区别就是实例化的类不同，还有url中传入的参数不同\n也可以通过继承，自定义一个类，修改其中的参数，例如下列\n1 2 3 4 default_limit = api_settings.PAGE_SIZE limit_query_param = \u0026#39;limit\u0026#39; offset_query_param = \u0026#39;offset\u0026#39; max_limit = None 使用方法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class BlogView(APIView): authentication_classes = (BlogAuthentication,) def get(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;获取博客列表\u0026#34;\u0026#34;\u0026#34; # 1.读取数据库中的博客信息 queryset = models.Blog.objects.all().order_by(\u0026#39;id\u0026#39;) # 2.处理得到分页后的queryset from rest_framework.pagination import LimitOffsetPagination pager = LimitOffsetPagination() result = pager.paginate_queryset(queryset, request, self) # 3.序列化 ser = BlogSerializer(result, many=True) # 4.获取分页返回结果 response = pager.get_paginated_response(ser.data) return response 实际使用 在项目中，很少将LimitOffsetPagination用于普通的分页需求中，而是主要用来实现滚动翻页，比如页面默认显示10条，当滚到底部时才加载后10条，以此类推\n为什么不使用PageNumberPagination呢？我们举个例子来理解\n比如一组倒序排列的数10,9,8\u0026hellip;1\n第一次offset=0\u0026amp;limit=2取到10，9\n第二次offset=2\u0026amp;limit=2取到8，7\n正常来讲前端记录取出的个数然后作为offset不会出错，但如果插入了新的数据到最前端\n第三次offset=0\u0026amp;limit=2取到7，6就会出现重复\n解决办法就是前端记录取出的最后一个数据的id作为max_id，这样就只会从未取出的数据中查找，offset=0\u0026amp;limit=2无需更改\n要拿最新数据只需要限制条件为id大于最上面的一条数据的id即可，即可实现向上滚动翻页和向下滚动翻页\n/accounts/?offset=0\u0026amp;limit=2\u0026amp;lastid=0 13\t武沛齐 12\t武沛齐 max_id=12\n/accounts/?offset=0\u0026amp;limit=2\u0026amp;lastid=12 11\t武沛齐 10\t武沛齐 max_id=10\n/accounts/?offset=0\u0026amp;limit=2\u0026amp;lastid=10 9\t武沛齐 8\t武沛齐\n案例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class BlogView(APIView): authentication_classes = (BlogAuthentication,) def get(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;获取博客列表\u0026#34;\u0026#34;\u0026#34; # 1.读取数据库中的博客信息 queryset = models.Blog.objects.all().order_by(\u0026#39;-id\u0026#39;) # ?max_id=1 # ?min_id=13 max_id = request.query_params.get(\u0026#39;max_id\u0026#39;, None) if max_id: queryset = queryset.filter(id__lt=max_id) # 2.处理得到分页后的queryset from rest_framework.pagination import LimitOffsetPagination pager = LimitOffsetPagination() result = pager.paginate_queryset(queryset, request, self) # 3.序列化 ser = BlogSerializer(result, many=True) # 4.获取分页返回结果 response = pager.get_paginated_response(ser.data) return response 视图 View、APIView回顾 具体看之前介绍django中的request的文章以及认证组件，版本组件等的文章，详细的介绍了整个请求生命流程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 path(\u0026#39;api/blog/\u0026#39;, views.BlogView.as_view()), class View(object): def as_view(...): def view(): ...dispatch() return view def dispatch(...): func = getattr(self,请求的Method) return func() class APIView(View): def as_view(...): # 1.自定义功能 -\u0026gt; 免除csrf token # 2.父类as_view def dispatch(...): # 1.请求的封装 # 2.版本、认证、权限、限流 # 3.反射getattr(self,请求的Method) # 4.返回 class BlogView(APIView): def get(request,...): pass def post(request,...): pass def put(request,...): pass GenericAPIVIew 在drf中，不只有APIView，其实还有好多好用的View，这一节我们先来介绍一个中间类GenericAPIVIew，为什么叫他中间类呢？\n因为我们一般不直接使用它，而是使用它的各种子类，说白了这个中间类是给子类用的，我们先来学习一下这个类都提供了什么功能\n获取queryset并统一格式get_queryset() 1 2 3 4 5 6 7 8 9 10 11 12 13 queryset = None def get_queryset(self): # 断言语句，确保queryset非空，否则不向下执行 assert self.queryset is not None, ( \u0026#34;\u0026#39;%s\u0026#39; should either include a `queryset` attribute, \u0026#34; \u0026#34;or override the `get_queryset()` method.\u0026#34; % self.__class__.__name__ ) queryset = self.queryset # 确保格式 if isinstance(queryset, QuerySet): queryset = queryset.all() return queryset 分页paginate_queryset() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 去配置中读取默认的分页组件 pagination_class = api_settings.DEFAULT_PAGINATION_CLASS # 返回分页组件类的实例化对象 @property def paginator(self): \u0026#34;\u0026#34;\u0026#34; The paginator instance associated with the view, or `None`. \u0026#34;\u0026#34;\u0026#34; if not hasattr(self, \u0026#39;_paginator\u0026#39;): if self.pagination_class is None: self._paginator = None else: self._paginator = self.pagination_class() return self._paginator def paginate_queryset(self, queryset): \u0026#34;\u0026#34;\u0026#34; Return a single page of results, or `None` if pagination is disabled. \u0026#34;\u0026#34;\u0026#34; if self.paginator is None: return None # 调用分页组件类自己的paginate_queryset方法 return self.paginator.paginate_queryset(queryset, self.request, view=self) settings.py文件配置默认分页组件\n1 2 3 4 REST_FRAMEWORK = { \u0026#39;UNAUTHENTICATED_USER\u0026#39;: None, \u0026#39;DEFAULT_PAGINATION_CLASS\u0026#39;: \u0026#39;rest_framework.pagination.PageNumberPagination\u0026#39;, } 序列化get_serializer() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 serializer_class = None def get_serializer(self, *args, **kwargs): # 获取序列化器 serializer_class = self.get_serializer_class() # 封装内容 kwargs.setdefault(\u0026#39;context\u0026#39;, self.get_serializer_context()) # 实例化序列化器类并传入参数 return serializer_class(*args, **kwargs) def get_serializer_class(self): assert self.serializer_class is not None, ( \u0026#34;\u0026#39;%s\u0026#39; should either include a `serializer_class` attribute, \u0026#34; \u0026#34;or override the `get_serializer_class()` method.\u0026#34; % self.__class__.__name__ ) return self.serializer_class def get_serializer_context(self): return { \u0026#39;request\u0026#39;: self.request, \u0026#39;format\u0026#39;: self.format_kwarg, \u0026#39;view\u0026#39;: self } 返回get_paginated_response() 1 2 3 def get_paginated_response(self, data): assert self.paginator is not None return self.paginator.get_paginated_response(data) 使用效果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class DemoView(GenericAPIView): queryset = models.UserInfo.objects.all() serializer_class = DemoSerializer def get(self, request, *args, **kwargs): # 1.读取数据库中的博客信息 # queryset = models.Blog.objects.all() queryset = self.get_queryset() # 2.分页 # from rest_framework.pagination import PageNumberPagination # pager = PageNumberPagination() # result = pager.paginate_queryset(queryset, request, self) result = self.paginate_queryset(queryset) # 3.序列化 # ser = DemoSerializer(instance=result, many=True) # print(ser.data) ser = self.get_serializer(instance=result, many=True) # 4.返回 # return Response(\u0026#34;...\u0026#34;) response = self.get_paginated_response(ser.data) return response 获取单个对象get_object() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def get_object(self): # 对查询集进行筛选，例如应用过滤器、分页等 queryset = self.filter_queryset(self.get_queryset()) # lookup_url_kwarg：URL 中用于查找对象的参数名称 # lookup_field：默认的查找字段名称 lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field assert lookup_url_kwarg in self.kwargs, ( \u0026#39;Expected view %s to be called with a URL keyword argument \u0026#39; \u0026#39;named \u0026#34;%s\u0026#34;. Fix your URL conf, or set the `.lookup_field` \u0026#39; \u0026#39;attribute on the view correctly.\u0026#39; % (self.__class__.__name__, lookup_url_kwarg) ) # 封装筛选的条件 filter_kwargs = {self.lookup_field: self.kwargs[lookup_url_kwarg]} # 根据条件去queryset中筛选出来 obj = get_object_or_404(queryset, **filter_kwargs) # 判断权限 has_object_permission self.check_object_permissions(self.request, obj) return obj # 获取原始queryset def get_queryset(self): assert self.queryset is not None, ( \u0026#34;\u0026#39;%s\u0026#39; should either include a `queryset` attribute, \u0026#34; \u0026#34;or override the `get_queryset()` method.\u0026#34; % self.__class__.__name__ ) queryset = self.queryset if isinstance(queryset, QuerySet): # Ensure queryset is re-evaluated on each request. queryset = queryset.all() return queryset # 根据条件筛选出目标数据对象 def get_object_or_404(queryset, *filter_args, **filter_kwargs): try: return _get_object_or_404(queryset, *filter_args, **filter_kwargs) except (TypeError, ValueError, ValidationError): raise Http404 # 本质就是 queryset.get(*args, **kwargs) def _get_object_or_404(klass, *args, **kwargs): queryset = _get_queryset(klass) if not hasattr(queryset, \u0026#39;get\u0026#39;): klass__name = klass.__name__ if isinstance(klass, type) else klass.__class__.__name__ raise ValueError( \u0026#34;First argument to get_object_or_404() must be a Model, Manager, \u0026#34; \u0026#34;or QuerySet, not \u0026#39;%s\u0026#39;.\u0026#34; % klass__name ) try: return queryset.get(*args, **kwargs) except queryset.model.DoesNotExist: raise Http404(\u0026#39;No %s matches the given query.\u0026#39; % queryset.model._meta.object_name) # 逐一判断权限，可以在权限类中对操作者角色进行判定 def check_object_permissions(self, request, obj): for permission in self.get_permissions(): if not permission.has_object_permission(request, self, obj): self.permission_denied( request, message=getattr(permission, \u0026#39;message\u0026#39;, None), code=getattr(permission, \u0026#39;code\u0026#39;, None) ) lookup_url_kwarg和lookup_field使用示例\n1 2 3 4 5 6 7 8 9 10 class UserDetailView(RetrieveAPIView): queryset = User.objects.all() serializer_class = UserSerializer lookup_field = \u0026#39;username\u0026#39; # 指定模型字段 lookup_url_kwarg = \u0026#39;username\u0026#39; # 指定 URL 参数名称 urlpatterns = [ path(\u0026#39;users/\u0026lt;str:username\u0026gt;/\u0026#39;, UserDetailView.as_view(), name=\u0026#39;user-detail\u0026#39;), ] # url中传递username参数，用它的值作为模型字段username的值进行筛选 关于filter_queryset的作用？\n它是用来对queryset做筛选的\n1 2 3 4 5 6 7 比如要在下列语句的基础上添加条件 obj = models.UserInfo.objects.filter(pk=10).first() 可以直接再写一个filter obj = models.UserInfo.objects.filter(status=xx).filter(pk=10).first() 或者 queryset = models.UserInfo.objects.filter(status=xx) obj = self.get_object() 但是如果status要动态变化，就无法用这两种方式实现了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 filter_backends = api_settings.DEFAULT_FILTER_BACKENDS def filter_queryset(self, queryset): \u0026#34;\u0026#34;\u0026#34; Given a queryset, filter it with whichever filter backend is in use. You are unlikely to want to override this method, although you may need to call it either from a list view, or from a custom `get_object` method if you want to apply the configured filtering backend to the default queryset. \u0026#34;\u0026#34;\u0026#34; for backend in list(self.filter_backends): queryset = backend().filter_queryset(self.request, queryset, self) return queryset 阅读上面源码可知，它从一个类列表filter_backends中循环每一个类，然后调用他们的filter_queryset方法，下面我们进入实操环节\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from rest_framework.filters import BaseFilterBackend class MyFilterBackend(BaseFilterBackend): def filter_queryset(self, request, queryset, view): xx = request.query_params.get(\u0026#34;xx\u0026#34;) queryset = queryset.filter(status=xx) return queryset class MyFilterBackend2(BaseFilterBackend): def filter_queryset(self, request, queryset, view): return queryset class DemoDetailView(GenericAPIView): queryset = models.UserInfo.objects.all() filter_backends = [MyFilterBackend, MyFilterBackend2] def get(self, request, pk): print(pk) # 1.取数据 # obj = models.UserInfo.objects.filter(pk=10).first() # obj = models.UserInfo.objects.get(id=10) # id=10必须找到且只能有一条 # 取数据 + 数据校验 as_object_permission obj = self.get_object() # 2.序列化 # ser = DemoSerializer(instance=obj, many=False) # print(ser.data) ser = self.get_serializer(instance=obj, many=False) return Response(ser.data) 注意：最大的意义，将数据库查询、序列化类提取到类变量中，后期再提供公共的get/post/put/delete等方法，让开发者只定义类变量，自动实现增删改查\n我们已经大致学完了GenericView的所有功能，会发现他基本只是对原本我们的操作做了一个封装，并没有让我们的开发简便多少。正如我们前面所说，他是用来服务其他类的，下面我们就来看看其他的视图类通过GenericView是如何简化我们的操作的\n上述代码打包命名为drf3.zip\nGenericViewSet 1 2 class GenericViewSet(ViewSetMixin, generics.GenericAPIView): pass 可见GenericViewSet类只是简单继承了ViewSetMixin类和GenericAPIView类，下面我们来看看ViewSetMixin类提供了什么功能\n关键就是在于这个as_view()方法，以前我们使用的视图继承VIew或是APIView，因为都不会自定义as_view，所以都是走到VIew视图类的as_view()方法，但ViewSetMixin类提供了as_view方法，他为我们提供了什么功能呢？\n以前我们的视图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 继承 APIView、GenericAPIView 路由： path(\u0026#39;api/demo/\u0026#39;, demo.DemoView.as_view()), path(\u0026#39;api/demo/\u0026lt;int:pk\u0026gt;/\u0026#39;, demo.DemoDetailView.as_view()), 视图： class DemoView(GenericAPIView): def get(self, request): pass def post(self, request): pass class DemoDetailView(GenericAPIView): def get(self, request,pk): pass def put(self, request,pk): pass def delete(self, request,pk): pass DRF 的API设计思路： api/demo/ GET 数据列表 api/demo/ POST 新建数据 api/demo/10/ GET 获取指定一条数据详细 api/demo/10/ PUT 修改数据 api/demo/10/ DELETE 删除数据 将两个视图合二为一\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 视图继承 APIView、GenericAPIView 路由： path(\u0026#39;api/demo/\u0026#39;, demo.DemoView.as_view()), path(\u0026#39;api/demo/\u0026lt;int:pk\u0026gt;/\u0026#39;, demo.DemoView.as_view()), 视图： class DemoView(GenericAPIView): def get(self, request,pk=None): if pk: 获取单条数据 else: 获取数据列表数据 def post(self, request): pass def put(self, request,pk): pass def delete(self, request,pk): pass DRF 的API设计思路： api/demo/ GET 数据列表 api/demo/ POST 新建数据 api/demo/10/ GET 获取指定一条数据详细 api/demo/10/ PUT 修改数据 api/demo/10/ DELETE 删除数据 有了ViewSetMixin后\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ViewSetMixin 对请求进行分发 DRF 的API设计思路： api/demo/ GET 数据列表 api/demo/ POST 新建数据 api/demo/10/ GET 获取指定一条数据详细 api/demo/10/ PUT 修改数据 api/demo/10/ DELETE 删除数据 api/demo/?gender=1\u0026amp;age=19 路由 path(\u0026#39;api/demo/\u0026#39;, demo.GvsView.as_view({\u0026#34;get\u0026#34;:\u0026#34;list\u0026#34;,\u0026#34;post\u0026#34;:\u0026#34;create\u0026#34;})), path(\u0026#39;api/demo/\u0026lt;int:pk\u0026gt;/\u0026#39;, demo.GvsView.as_view({\u0026#34;get\u0026#34;:\u0026#34;retrieve\u0026#34;,\u0026#34;delete\u0026#34;:\u0026#34;destroy\u0026#34;,\u0026#34;put\u0026#34;:\u0026#34;update\u0026#34;})), 视图： class GvsView(ViewSetMixin): def list(self,request): pass # 获取数据列表 def create(self,request): pass def retrive(self,request,pk): pass # 获取数据详细 def destroy(self,request,pk): pass # 删除 def update(self,request,pk): pass # 修改 有了全新的一套路由匹配视图类的规则，而不是原来的靠反射来获取到对应的get或post方法\n实操环节\n路由 1 2 3 4 urlpatterns = [ path(\u0026#39;api/gvs/\u0026#39;, gvs.GvsView.as_view({\u0026#34;get\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;post\u0026#34;: \u0026#34;create\u0026#34;})), path(\u0026#39;api/gvs/\u0026lt;int:pk\u0026gt;/\u0026#39;, gvs.GvsView.as_view({\u0026#34;get\u0026#34;: \u0026#34;retrieve\u0026#34;})), ] 视图 1 2 3 4 5 6 7 8 9 class GvsView(ViewSetMixin, GenericAPIView): def list(self, request): return Response(\u0026#39;list\u0026#39;) def create(self, request): return Response(\u0026#39;create\u0026#39;) def retrieve(self, request, pk=None): return Response(\u0026#39;retrieve\u0026#39;) 五大类 ListModelMixin 先使用GenericViewSet实现一个查看用户信息列表的功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from rest_framework.viewsets import GenericViewSet from rest_framework.response import Response from api import models from rest_framework.serializers import ModelSerializer class BlogSerializer(ModelSerializer): class Meta: model = models.Blog fields = \u0026#39;__all__\u0026#39; class BlogView(GenericViewSet): queryset = models.Blog.objects.all() serializer_class = BlogSerializer def list(self, request, *args, **kwargs): # 1.获取数据 queryset = self.get_queryset() # 2.分页 result = self.paginate_queryset(queryset) # 3.序列化 ser = self.get_serializer(instance=result, many=True) print(ser.data) return Response(\u0026#34;....\u0026#34;) 如果我们要将这个接口改为查询博客列表，那么只需要将视图类中的queryset和serializer_class修改为博客相关的即可，而无需重写list方法，因此可以看到，这个list方法是公共的\n然而，drf也意识到了这一点，他给我们提供了一个叫做ListModelMixin的视图类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class ListModelMixin: \u0026#34;\u0026#34;\u0026#34; List a queryset. \u0026#34;\u0026#34;\u0026#34; def list(self, request, *args, **kwargs): queryset = self.filter_queryset(self.get_queryset()) page = self.paginate_queryset(queryset) if page is not None: serializer = self.get_serializer(page, many=True) return self.get_paginated_response(serializer.data) serializer = self.get_serializer(queryset, many=True) return Response(serializer.data) 可以看到，它为我们写好了list方法，因此下次我们要实现查找功能是，只需要自己定义queryset和serializer_class即可，而无需编写list方法\n1 2 3 4 5 6 7 8 9 10 11 12 from rest_framework.mixins import ListModelMixin class BlogSerializer(ModelSerializer): class Meta: model = models.Blog fields = \u0026#39;__all__\u0026#39; class BlogView(ListModelMixin, GenericViewSet): queryset = models.Blog.objects.all() serializer_class = BlogSerializer RetrieveModelMixin ListModelMixin视图类定义了list方法用于获取数据列表，那如果要获取单条数据呢？\ndrf给我们提供了RetrieveModelMixin方法\n1 2 3 4 5 6 7 8 class RetrieveModelMixin: \u0026#34;\u0026#34;\u0026#34; Retrieve a model instance. \u0026#34;\u0026#34;\u0026#34; def retrieve(self, request, *args, **kwargs): instance = self.get_object() serializer = self.get_serializer(instance) return Response(serializer.data) 使用方法同上，只需要继承RetrieveModelMixin，然后提供queryset和serializer_class即可\n1 2 3 4 urlpatterns = [ path(\u0026#39;api/blog/\u0026#39;, five.BlogView.as_view({\u0026#34;get\u0026#34;: \u0026#34;list\u0026#34;})), path(\u0026#39;api/blog/\u0026lt;int:pk\u0026gt;/\u0026#39;, five.BlogView.as_view({\u0026#34;get\u0026#34;: \u0026#34;retrieve\u0026#34;})), ] 1 2 3 4 5 6 7 8 9 10 11 12 from rest_framework.mixins import ListModelMixin, RetrieveModelMixin class BlogSerializer(ModelSerializer): class Meta: model = models.Blog fields = \u0026#39;__all__\u0026#39; class BlogView(ListModelMixin, RetrieveModelMixin, GenericViewSet): queryset = models.Blog.objects.all() serializer_class = BlogSerializer 序列化器的切换 这个需求的提出在于，我们上面学习了两个视图类，ListModelMixin和RetrieveModelMixin。一个对应获取数据列表，一个对应获取单条数据，但是使用的是同一个类，意味着类变量serializer_class是唯一的。如果获取数据列表与单条数据对应的序列化器不一样，该如何切换呢？ 从源码可以知道\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def get_serializer(self, *args, **kwargs): serializer_class = self.get_serializer_class() kwargs.setdefault(\u0026#39;context\u0026#39;, self.get_serializer_context()) return serializer_class(*args, **kwargs) def get_serializer_class(self): assert self.serializer_class is not None, ( \u0026#34;\u0026#39;%s\u0026#39; should either include a `serializer_class` attribute, \u0026#34; \u0026#34;or override the `get_serializer_class()` method.\u0026#34; % self.__class__.__name__ ) return self.serializer_class def get_serializer_context(self): return { \u0026#39;request\u0026#39;: self.request, \u0026#39;format\u0026#39;: self.format_kwarg, \u0026#39;view\u0026#39;: self } 源码是调用get_serializer_class方法来选择序列化器的，我们只需要在自己的类中重写即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class BlogSerializer(ModelSerializer): class Meta: model = models.Blog fields = \u0026#39;__all__\u0026#39; class BlogDetailSerializer(ModelSerializer): class Meta: model = models.BLog fields = \u0026#39;__all__\u0026#39; class BlogView(ListModelMixin, RetrieveModelMixin, GenericViewSet): queryset = models.Blog.objects serializer_class = BlogSerializer def get_serializer_class(self): # 根据两个请求的不同来做区分，分发不同的序列化器 pk = self.kwargs.get(\u0026#39;pk\u0026#39;) if pk: self.serializer_class = BlogDetailSerializer return self.serializer_class 这里两个请求都是GET请求，可以通过有无pk来判断\n后面学习了其他的几个视图类后，请求方式的不同可以通过从self.request.method中拿到请求方法进行判断，是put、patch、post还是get\nCreateModelMixin 新增数据drf也为我们提供了对应的视图类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class CreateModelMixin: \u0026#34;\u0026#34;\u0026#34; Create a model instance. \u0026#34;\u0026#34;\u0026#34; def create(self, request, *args, **kwargs): serializer = self.get_serializer(data=request.data) serializer.is_valid(raise_exception=True) self.perform_create(serializer) headers = self.get_success_headers(serializer.data) return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers) def perform_create(self, serializer): serializer.save() def get_success_headers(self, data): try: return {\u0026#39;Location\u0026#39;: str(data[api_settings.URL_FIELD_NAME])} except (TypeError, KeyError): return {} 如果要在serializer.save()时手动插入一些数据，只需重写perform_create方法即可\n1 path(\u0026#39;api/user/\u0026#39;, five.UserView.as_view({\u0026#34;post\u0026#34;: \u0026#34;create\u0026#34;})), 1 2 3 4 5 6 7 8 9 10 11 12 class UserSerializer(ModelSerializer): class Meta: model = models.UserInfo fields = \u0026#39;__all__\u0026#39; class UserView(ListModelMixin, RetrieveModelMixin, CreateModelMixin, GenericViewSet): queryset = models.UserInfo.objects.all() serializer_class = UserSerializer def perform_create(self, serializer): serializer.save() UpdateModelMixin 这是一个用于实现更新的视图类，提供了局部更新和全局更新两种形式，因为我们知道，在序列化器中\n1 ser = UserSerializer(instance=\u0026#34;对象\u0026#34;, data=request=data) 这一语句实现更新必须是全局更新，即要将无需变动的字段值也要带上，局部更新的话就只需要发送变动的字段即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class UpdateModelMixin: \u0026#34;\u0026#34;\u0026#34; Update a model instance. \u0026#34;\u0026#34;\u0026#34; def update(self, request, *args, **kwargs): partial = kwargs.pop(\u0026#39;partial\u0026#39;, False) instance = self.get_object() serializer = self.get_serializer(instance, data=request.data, partial=partial) serializer.is_valid(raise_exception=True) self.perform_update(serializer) if getattr(instance, \u0026#39;_prefetched_objects_cache\u0026#39;, None): # If \u0026#39;prefetch_related\u0026#39; has been applied to a queryset, we need to # forcibly invalidate the prefetch cache on the instance. instance._prefetched_objects_cache = {} return Response(serializer.data) def perform_update(self, serializer): serializer.save() def partial_update(self, request, *args, **kwargs): kwargs[\u0026#39;partial\u0026#39;] = True return self.update(request, *args, **kwargs) 同样的，保存操作perform_update支持拓展\n使用示例\n1 2 path(\u0026#39;api/user/\u0026#39;, five.UserView.as_view({\u0026#34;get\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;post\u0026#34;: \u0026#34;create\u0026#34;})), path(\u0026#39;api/user/\u0026lt;int:pk\u0026gt;/\u0026#39;, five.UserView.as_view({\u0026#34;get\u0026#34;: \u0026#34;retrieve\u0026#34;, \u0026#34;put\u0026#34;: \u0026#34;update\u0026#34;, \u0026#34;patch\u0026#34;: \u0026#34;partial_update\u0026#34;})), 1 2 3 4 5 6 7 8 9 10 11 12 from rest_framework.mixins import ListModelMixin, RetrieveModelMixin, CreateModelMixin, UpdateModelMixin class UserSerializer(ModelSerializer): class Meta: model = models.UserInfo fields = \u0026#39;__all__\u0026#39; class UserView(ListModelMixin, RetrieveModelMixin, CreateModelMixin, UpdateModelMixin, GenericViewSet): queryset = models.UserInfo.objects.all() serializer_class = UserSerializer DestroyModelMixin 提供删除视图的类\n1 2 3 4 5 6 7 8 9 10 11 class DestroyModelMixin: \u0026#34;\u0026#34;\u0026#34; Destroy a model instance. \u0026#34;\u0026#34;\u0026#34; def destroy(self, request, *args, **kwargs): instance = self.get_object() self.perform_destroy(instance) return Response(status=status.HTTP_204_NO_CONTENT) def perform_destroy(self, instance): instance.delete() 默认是物理删除，即在数据库中抹去该数据\n如果想实现逻辑删除，重写perform_destroy方法即可\n排列组合类 要实现增删改查需要手动继承上面提到的这么多类吗？drf为我们想到了这一点，他提供了一些组合类供我们快速继承\nviewsets.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 from rest_framework.viewsets import ModelViewSet class ModelViewSet(mixins.CreateModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, mixins.ListModelMixin, GenericViewSet): class ReadOnlyModelViewSet(mixins.RetrieveModelMixin, mixins.ListModelMixin, GenericViewSet): generics.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 from rest_framework.generics import GenericAPIView class CreateAPIView(mixins.CreateModelMixin, GenericAPIView): def post(self, request, *args, **kwargs): return self.create(request, *args, **kwargs) class ListAPIView(mixins.ListModelMixin, GenericAPIView): def get(self, request, *args, **kwargs): return self.list(request, *args, **kwargs) class RetrieveAPIView(mixins.RetrieveModelMixin, GenericAPIView): def get(self, request, *args, **kwargs): return self.retrieve(request, *args, **kwargs) class DestroyAPIView(mixins.DestroyModelMixin, GenericAPIView): def delete(self, request, *args, **kwargs): return self.destroy(request, *args, **kwargs) class UpdateAPIView(mixins.UpdateModelMixin, GenericAPIView): def put(self, request, *args, **kwargs): return self.update(request, *args, **kwargs) def patch(self, request, *args, **kwargs): return self.partial_update(request, *args, **kwargs) class ListCreateAPIView(mixins.ListModelMixin, mixins.CreateModelMixin, GenericAPIView): def get(self, request, *args, **kwargs): return self.list(request, *args, **kwargs) def post(self, request, *args, **kwargs): return self.create(request, *args, **kwargs) class RetrieveUpdateAPIView(mixins.RetrieveModelMixin, mixins.UpdateModelMixin, GenericAPIView): def get(self, request, *args, **kwargs): return self.retrieve(request, *args, **kwargs) def put(self, request, *args, **kwargs): return self.update(request, *args, **kwargs) def patch(self, request, *args, **kwargs): return self.partial_update(request, *args, **kwargs) class RetrieveDestroyAPIView(mixins.RetrieveModelMixin, mixins.DestroyModelMixin, GenericAPIView): def get(self, request, *args, **kwargs): return self.retrieve(request, *args, **kwargs) def delete(self, request, *args, **kwargs): return self.destroy(request, *args, **kwargs) class RetrieveUpdateDestroyAPIView(mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, GenericAPIView): def get(self, request, *args, **kwargs): return self.retrieve(request, *args, **kwargs) def put(self, request, *args, **kwargs): return self.update(request, *args, **kwargs) def patch(self, request, *args, **kwargs): return self.partial_update(request, *args, **kwargs) def delete(self, request, *args, **kwargs): return self.destroy(request, *args, **kwargs) 视图总结 学了那么多视图类，该如何选择继承呢？\n继承APIView，核心功能+自己实现业务 -\u0026gt; 自定义操作（读取redis，文件） ModelViewSet或五大类+GenericViewSet 路由的as_view需要参数，建立get-\u0026gt;list的关系 GenericAPIView+五大类 路由的as_view不需要参数，直接是GET/POST/PUT等等 路由 自动生成对应关系 在上面的视图中当我们继承了ViewSetMixin类，那么as_view就会发生变化，在路由中就需要自己写参数来建立get -\u0026gt; list，post -\u0026gt; create等关系，还是比较麻烦的，其实drf为我们提供了自动生成的功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from rest_framework import routers router = routers.SimpleRouter() router.register(r\u0026#39;api/user\u0026#39;, five.UserView) urlpatterns = [ # path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;api/demo/\u0026#39;, demo.DemoView.as_view()), path(\u0026#39;api/demo/\u0026lt;int:pk\u0026gt;/\u0026#39;, demo.DemoDetailView.as_view()), path(\u0026#39;api/gvs/\u0026#39;, gvs.GvsView.as_view({\u0026#34;get\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;post\u0026#34;: \u0026#34;create\u0026#34;})), path(\u0026#39;api/gvs/\u0026lt;int:pk\u0026gt;/\u0026#39;, gvs.GvsView.as_view({\u0026#34;get\u0026#34;: \u0026#34;retrieve\u0026#34;})), .... # path(\u0026#39;api/user/\u0026#39;, five.UserView.as_view({\u0026#34;get\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;post\u0026#34;: \u0026#34;create\u0026#34;})), # path(\u0026#39;api/user/\u0026lt;int:pk\u0026gt;/\u0026#39;, five.UserView.as_view({\u0026#34;get\u0026#34;: \u0026#34;retrieve\u0026#34;, \u0026#34;put\u0026#34;: \u0026#34;update\u0026#34;, \u0026#34;patch\u0026#34;: \u0026#34;partial_update\u0026#34;, \u0026#34;delete\u0026#34;: \u0026#34;destroy\u0026#34;})), ] urlpatterns += router.urls 如上述代码，只需实例化一个router类并指定api/user和对应的视图类即可，他会自动生成注释部分的对应关系\nUserView中继承了几个五大类，他就会生成一一对应的路由\n路由总结 视图继承APIView 1 2 3 4 5 6 from django.urls import path from app01 import views urlpatterns = [ path(\u0026#39;api/users/\u0026#39;, views.UserView.as_view()), # APIView ] 视图继承 ViewSetMixin（GenericViewSet、ModelViewSet） 1 2 3 4 5 6 7 from django.urls import path, re_path, include from app01 import views urlpatterns = [ path(\u0026#39;api/users/\u0026#39;, views.UserView.as_view({\u0026#34;get\u0026#34;:\u0026#34;list\u0026#34;,\u0026#34;post\u0026#34;:\u0026#34;create\u0026#34;})), path(\u0026#39;api/users/\u0026lt;int:pk\u0026gt;/\u0026#39;, views.UserView.as_view({\u0026#34;get\u0026#34;:\u0026#34;retrieve\u0026#34;,\u0026#34;put\u0026#34;:\u0026#34;update\u0026#34;,\u0026#34;patch\u0026#34;:\u0026#34;partial_update\u0026#34;,\u0026#34;delete\u0026#34;:\u0026#34;destory\u0026#34;})), ] 继承ViewSetMixin形式的自动分发 1 2 3 4 5 6 7 8 9 10 11 12 from rest_framework import routers from app01 import views router = routers.SimpleRouter() router.register(r\u0026#39;api/users\u0026#39;, views.UserView) urlpatterns = [ # 其他URL # path(\u0026#39;xxxx/\u0026#39;, xxxx.as_view()), ] urlpatterns += router.urls 还可以利用include给URL加前缀\n1 2 3 4 5 6 7 8 9 10 11 12 from django.urls import path, include from rest_framework import routers from app01 import views router = routers.SimpleRouter() router.register(r\u0026#39;users\u0026#39;, views.UserView) urlpatterns = [ path(\u0026#39;api/\u0026#39;, include((router.urls, \u0026#39;app_name\u0026#39;), namespace=\u0026#39;instance_name\u0026#39;)), # 其他URL # path(\u0026#39;forgot-password/\u0026#39;, ForgotPasswordFormView.as_view()), ] 拓展URL 上述介绍了自动生成对应关系，实现get请求访问api/user/是查询列表，访问api/user/1/是查询单条数据，post访问api/user/是创建数据等等，如果要将api/user/xxx/1/对应的请求也囊括进来，我们就需要在SimpleRouter的基础上进行拓展\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from rest_framework.decorators import action class UserView(ListModelMixin, RetrieveModelMixin, CreateModelMixin, UpdateModelMixin, DestroyModelMixin, GenericViewSet): queryset = models.UserInfo.objects.all() serializer_class = UserSerializer @action(detail=False, methods=[\u0026#39;get\u0026#39;], url_path=\u0026#39;yyy/(?P\u0026lt;xx\u0026gt;\\d+)/xxx\u0026#39;) def yyy(self, request, xx, pk=None): print(\u0026#34;yyy来了\u0026#34;) return Response(\u0026#39;yyy\u0026#39;) @action(detail=True, methods=[\u0026#39;get\u0026#39;]) def get_info(self, request, pk=None): print(\u0026#34;get_info来了\u0026#34;) return Response(\u0026#39;get_info\u0026#39;) 当请求为api/user/yyy/123/xxx/时匹配第一个yyy函数，detail=False表示对应的获取数据列表格式，即自己拓展的url时拼接在api/user/后面的，而不是api/user/1/\n当请求为api/user/1/get_info/时匹配第二个get_info函数，detail=True表示拓展的url拼装类似api/user/1/后面，因为自己没有定义url_path，因此就以函数名为拓展的url内容\n筛选器 我们在介绍GenericAPIView时其实已经提到了筛选器，就是那个filter_queryset方法\n在详细介绍其使用之前，我们先来列举一下什么时候会有用到这个筛选器\n筛选器的使用场景 情况一：继承GenericAPIView 或 GenericViewSet\n列表 queryset = self.get_queryset() 详细 obj = self.get_object() queryset = self.get_queryset() queryset = self.filter_queryset(queryset) obj = queryset.get(pk=1) 修改 obj = self.get_object() 删除 obj = self.get_object() 情况二：继承：ListModelMixin, CreateModelMixin, GenericViewSet)\n列表 queryset = self.get_queryset() queryset = self.filter_queryset(queryset) 详细 obj = self.get_object() queryset = self.get_queryset() queryset = self.filter_queryset(queryset) obj = queryset.get(pk=1) 修改 obj = self.get_object() 删除 obj = self.get_object() 也就是说，当继承的是第二种时，不管是增删改查都会有筛选器的参与\n它可以帮我们进一步对queryset做筛选，一般用于构建动态条件，因为静态的条件可以直接在queryset赋值时写入\n如何使用 观察源码可以发现，其实就是去类列表filter_backends中循环获取每一个类，调用它的filter_queryset方法来做筛选\n1 2 3 4 def filter_queryset(self, queryset): for backend in list(self.filter_backends): queryset = backend().filter_queryset(self.request, queryset, self) return queryset 使用示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from rest_framework.filters import BaseFilterBackend class MyFilterBackend(BaseFilterBackend): def filter_queryset(self, request, queryset, view): # request.query_params.get(\u0026#34;xxx\u0026#34;) return queryset class MyFilterBackend2(BaseFilterBackend): def filter_queryset(self, request, queryset, view): return queryset class UserView(ListModelMixin, RetrieveModelMixin, CreateModelMixin, UpdateModelMixin, DestroyModelMixin, GenericViewSet): filter_backends = [MyFilterBackend, MyFilterBackend2] 在filter_queryset中，可以直接获取url中携带的参数，然后进行数据筛选，而不需要在视图函数中再实现该动作\napi/user/?age=10\u0026amp;height\u0026gt;180\n第三方filter 在drf开发时有一个常用的第三方过滤器：DjangoFilterBackend\n1 2 3 pip install django-filter # 为了与django3.2兼容，需要指定版本下载 pip install django-filter==21.1 注册app\n1 2 3 4 5 INSTALLED_APPS = [ ... \u0026#39;django_filters\u0026#39;, ... ] 如何使用 案例一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from rest_framework.viewsets import ModelViewSet from rest_framework.serializers import ModelSerializer from django_filters.rest_framework import DjangoFilterBackend from api import models class FtSerializer(ModelSerializer): class Meta: model = models.UserInfo fields = \u0026#39;__all__\u0026#39; class FtView(ModelViewSet): serializer_class = FtSerializer queryset = models.UserInfo.objects.all().order_by(\u0026#39;-id\u0026#39;) filter_backends = [DjangoFilterBackend, ] filterset_fields = [\u0026#34;id\u0026#34;, \u0026#34;username\u0026#34;] filterset_fields是存放需要用于筛选的字段的列表，如上面filterset_fields中有id和username，那么当请求的URL中携带id，他就会进行筛选，返回符合条件的\n然而这种筛选只支持判断相等，即id=1，而无法实现筛选出id\u0026gt;1的数据\n案例二 要想解决案例一的问题，我们就需要自定义\n不再是直接将数据库字段赋值给filterset_fields，而是给filterset_class赋值一个类，在类中定义筛选条件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from rest_framework.viewsets import ModelViewSet from rest_framework.serializers import ModelSerializer from django_filters.rest_framework import DjangoFilterBackend from django_filters import FilterSet, filters from api import models class FtSerializer(ModelSerializer): class Meta: model = models.UserInfo fields = \u0026#39;__all__\u0026#39; class MyFilterSet(FilterSet): min_id = filters.NumberFilter(field_name=\u0026#39;id\u0026#39;, lookup_expr=\u0026#39;gte\u0026#39;) us = filters.CharFilter(field_name=\u0026#39;username\u0026#39;, lookup_expr=\u0026#39;startswith\u0026#39;) class Meta: model = models.UserInfo fields = [\u0026#39;min_id\u0026#39;, \u0026#39;us\u0026#39;] class FtView(ModelViewSet): serializer_class = FtSerializer queryset = models.UserInfo.objects.all().order_by(\u0026#39;-id\u0026#39;) filter_backends = [DjangoFilterBackend, ] filterset_class = MyFilterSet 如上述代码，定义了字段min_id和us，那么在url中传参就应该传递api/user/?min_id=2\u0026amp;us=v\n而在字段的定义中，field_name代表的是与之校验的数据库字段名，lookup_expr是表达式\n案例三 上一个案例提到，lookup_expr是条件筛选的表达式，那么常见的有哪些\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 from rest_framework import serializers from rest_framework.viewsets import ModelViewSet from django_filters.rest_framework import DjangoFilterBackend, OrderingFilter from django_filters import FilterSet, filters from app01 import models class UserModelSerializer(serializers.ModelSerializer): level_text = serializers.CharField( source=\u0026#34;get_level_display\u0026#34;, read_only=True ) depart_title = serializers.CharField( source=\u0026#34;depart.title\u0026#34;, read_only=True ) extra = serializers.SerializerMethodField(read_only=True) class Meta: model = models.UserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;username\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;email\u0026#34;, \u0026#34;level_text\u0026#34;, \u0026#34;extra\u0026#34;, \u0026#34;depart_title\u0026#34;] def get_extra(self, obj): return 666 class MyFilterSet(FilterSet): # /api/users/?min_id=2 -\u0026gt; id\u0026gt;=2 min_id = filters.NumberFilter(field_name=\u0026#39;id\u0026#39;, lookup_expr=\u0026#39;gte\u0026#39;) # /api/users/?name=wupeiqi -\u0026gt; not ( username=wupeiqi ) name = filters.CharFilter(field_name=\u0026#34;username\u0026#34;, lookup_expr=\u0026#34;exact\u0026#34;, exclude=True) # /api/users/?depart=xx -\u0026gt; depart__title like %xx% depart = filters.CharFilter(field_name=\u0026#34;depart__title\u0026#34;, lookup_expr=\u0026#34;contains\u0026#34;) # /api/users/?token=true -\u0026gt; \u0026#34;token\u0026#34; IS NULL # /api/users/?token=false -\u0026gt; \u0026#34;token\u0026#34; IS NOT NULL token = filters.BooleanFilter(field_name=\u0026#34;token\u0026#34;, lookup_expr=\u0026#34;isnull\u0026#34;) # /api/users/?email=xx -\u0026gt; email like xx% email = filters.CharFilter(field_name=\u0026#34;email\u0026#34;, lookup_expr=\u0026#34;startswith\u0026#34;) # /api/users/?level=2\u0026amp;level=1 -\u0026gt; \u0026#34;level\u0026#34; = 1 OR \u0026#34;level\u0026#34; = 2（必须的是存在的数据，否则报错--\u0026gt;内部有校验机制） # level = filters.AllValuesMultipleFilter(field_name=\u0026#34;level\u0026#34;, lookup_expr=\u0026#34;exact\u0026#34;) level = filters.MultipleChoiceFilter(field_name=\u0026#34;level\u0026#34;, lookup_expr=\u0026#34;exact\u0026#34;, choices=models.UserInfo.level_choices) # /api/users/?age=18,20 -\u0026gt; age in [18,20] age = filters.BaseInFilter(field_name=\u0026#39;age\u0026#39;, lookup_expr=\u0026#34;in\u0026#34;) # /api/users/?range_id_max=10\u0026amp;range_id_min=1 -\u0026gt; id BETWEEN 1 AND 10 range_id = filters.NumericRangeFilter(field_name=\u0026#39;id\u0026#39;, lookup_expr=\u0026#39;range\u0026#39;) # /api/users/?ordering=id -\u0026gt; order by id asc # /api/users/?ordering=-id -\u0026gt; order by id desc # /api/users/?ordering=age -\u0026gt; order by age asc # /api/users/?ordering=-age -\u0026gt; order by age desc ordering = filters.OrderingFilter(fields=[\u0026#34;id\u0026#34;, \u0026#34;age\u0026#34;]) # /api/users/?size=1 -\u0026gt; limit 1（自定义搜索） size = filters.CharFilter(method=\u0026#39;filter_size\u0026#39;, distinct=False, required=False) class Meta: model = models.UserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;min_id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;depart\u0026#34;, \u0026#34;email\u0026#34;, \u0026#34;level\u0026#34;, \u0026#34;age\u0026#34;, \u0026#39;range_id\u0026#39;, \u0026#34;size\u0026#34;, \u0026#34;ordering\u0026#34;] def filter_size(self, queryset, name, value): int_value = int(value) return queryset[0:int_value] class UserView(ModelViewSet): filter_backends = [DjangoFilterBackend, ] filterset_class = MyFilterSet queryset = models.UserInfo.objects.all() serializer_class = UserModelSerializer def perform_create(self, serializer): \u0026#34;\u0026#34;\u0026#34; 序列化：对请求的数据校验成功后，执行保存。\u0026#34;\u0026#34;\u0026#34; serializer.save(depart_id=1, password=\u0026#34;123\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026#39;exact\u0026#39;: _(\u0026#39;\u0026#39;), \u0026#39;iexact\u0026#39;: _(\u0026#39;\u0026#39;), \u0026#39;contains\u0026#39;: _(\u0026#39;contains\u0026#39;), \u0026#39;icontains\u0026#39;: _(\u0026#39;contains\u0026#39;), \u0026#39;startswith\u0026#39;: _(\u0026#39;starts with\u0026#39;), \u0026#39;istartswith\u0026#39;: _(\u0026#39;starts with\u0026#39;), \u0026#39;endswith\u0026#39;: _(\u0026#39;ends with\u0026#39;), \u0026#39;iendswith\u0026#39;: _(\u0026#39;ends with\u0026#39;), \u0026#39;gt\u0026#39;: _(\u0026#39;is greater than\u0026#39;), \u0026#39;gte\u0026#39;: _(\u0026#39;is greater than or equal to\u0026#39;), \u0026#39;lt\u0026#39;: _(\u0026#39;is less than\u0026#39;), \u0026#39;lte\u0026#39;: _(\u0026#39;is less than or equal to\u0026#39;), \u0026#39;in\u0026#39;: _(\u0026#39;is in\u0026#39;), \u0026#39;range\u0026#39;: _(\u0026#39;is in range\u0026#39;), \u0026#39;isnull\u0026#39;: _(\u0026#39;\u0026#39;), 全局配置\n1 2 3 4 5 # settings.py 全局配置 REST_FRAMEWORK = { \u0026#39;DEFAULT_FILTER_BACKENDS\u0026#39;: [\u0026#39;django_filters.rest_framework.DjangoFilterBackend\u0026#39;,] } 虽然第三方筛选器给我们提供了自定义的功能，让我们可以灵活拓展。但是如果筛选条件真的很复杂，还是建议使用自带的筛选器自定义\n","date":"2025-02-27T18:16:40+08:00","permalink":"https://yn0t1me.github.io/p/drf/","title":"Drf"},{"content":"Django项目创建 项目+虚拟环境\nDjango项目的创建 1 2 # 安装指定版本的djano pip install django==3.2 命令行操作 1 2 cd 项目目录 django-admin startproject 项目名 项目结构\n1 2 3 4 5 6 7 8 myproject ├── manage.py [项目的管理工具] └── myproject ├── __init__.py ├── settings.py 【配置文件，只有一部分。程序启动时，先读取django内部配置，再读settings.py】 ├── urls.py\t【主路由，在里面编写 /xxx/xxx/xxx ---\u0026gt; index 】 ├── asgi.py 【异步】 └── wsgi.py 【同步，主】 项目启动\n1 2 cd 项目名 python manage.py runserver IP:端口（可默认不写） app\n1 2 cd 项目 python manage.py startapp app名 项目结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 myproject ├── manage.py ├── myproject │ ├── __init__.py │ ├── asgi.py │ ├── settings.py │ ├── urls.py │ └── wsgi.py └── web ├── __init__.py ├── admin.py ├── apps.py ├── migrations │ └── __init__.py ├── models.py ├── tests.py └── views.py Pycharm操作 创建django项目\n生成效果\n虚拟环境 使用虚拟环境可以是各个项目之间的环境隔离开，为每一个项目单独创建一个虚拟环境，而不是使用系统解释器\n命令行 此处只介绍virtualenv的用法\n1 2 3 4 5 6 7 # 首先pip安装virualenv库 随便哪个系统解释器均可 pip install virtualenv cd 目标文件夹 virtualenv 虚拟环境名 --python=系统解释器 virtualenv /目标文件夹/虚拟环境名 --python=系统解释器 操作\n将D:\\envs视为以后存放虚拟环境的目录 1 2 cd \\envs virtualenv crm --python=python39 激活虚拟环境 1 2 cd crm\\Scripts activate 出现图示(虚拟环境名)表明激活成功\n安装包 1 pip install 包名 创建django项目 1 2 cd 项目目录 django-admin startproject crm 1 2 python manage.py startapp xxx python manage.py runserver 退出虚拟环境 1 deactivate Pycharm 创建指定django版本的项目\n创建纯净项目+创建虚拟环境 创建django项目 安装django\n1 pip install django==3.2 创建项目\n1 django-admin startproject myproj 因为我的pycharm虚拟环境有问题，只有在Script目录下才被激活，因此指定了一下创建路径\n配置django的启动按钮 fix键\napp创建 单个app目录结构如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 myproj ├── manage.py ├── myproj │ ├── __init__.py │ ├── asgi.py │ ├── settings.py │ ├── urls.py │ └── wsgi.py └── web ├── __init__.py ├── admin.py ├── apps.py ├── migrations │ └── __init__.py ├── models.py ├── tests.py └── views.py 要使用多app时，建议在根目录建立apps目录，在其中依次建立以app名命名的目录\n1 2 3 4 5 6 7 8 9 10 myproj .venv myproj ... ... manage.py apps web backend api 1 2 3 4 # 先创建如上结构的目录 python manage.py startapp spi apps/api python manage.py startapp web apps/web python manage.py startapp backend apps/backend 纯净版 将不需要使用的app，中间件，模板在settings文件中注释即可得到一个纯净版的django项目\nDjango项目文件结构及作用（个人习惯） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 D:\\Data\\Codefield\\CODE-Python\\py全栈\\模块六\\day06\u0026gt;treee -I .venv -f . |-- ./day06 | |-- ./day06/__init__.py | |-- ./day06/__pycache__ | | |-- 省略 | |-- ./day06/asgi.py | |-- ./day06/local_settings.py【本地配置，如数据库等配置，区别于settings】 | |-- ./day06/settings.py | |-- ./day06/urls.py【书写路由与视图函数对应关系】 | `-- ./day06/wsgi.py |-- ./django_error.log 【错误日志】 |-- ./manage.py |-- ./requirements【库依赖文件】 |-- ./scripts【脚本文件，随意写，放杂物】 | |-- ./scripts/init_admin.py | |-- ./scripts/init_customer.py | `-- ./scripts/\\303\\346\\317\\362\\266\\324\\317\\363\\274\\314\\263\\320.py |-- ./shell【部署时方便操作的bash脚本】 | |-- ./shell/reboot.sh | |-- ./shell/shop.sh | `-- ./shell/uwsgi_day06.ini |-- ./utils【小的功能库】 | |-- ./utils/__pycache__ | | |-- 略 | |-- ./utils/aliyun.py【短信收发】 | |-- ./utils/bootstrap.py【bootstrap样式渲染脚本】 | |-- ./utils/encrypt.py【密码加解密】 | |-- ./utils/group.py | |-- ./utils/link.py | |-- ./utils/md.py | |-- ./utils/pager.py【分页组件】 | |-- ./utils/response.py【response类，用于方便构建返回值】 | `-- ./utils/video.py【获取视频原播放量的脚本】 `-- ./web【单app】 |-- ./web/__init__.py |-- ./web/__pycache__ | |-- 略 |-- ./web/admin.py |-- ./web/apps.py |-- ./web/forms【编写form组件用于生成表单，校验提交信息】 | |-- ./web/forms/__pycache__ | | `-- ./web/forms/__pycache__/account.cpython-39.pyc | `-- ./web/forms/account.py |-- ./web/migrations【数据库操作记录文件】 | |-- ./web/migrations/0001_initial.py | |-- 略 |-- ./web/models.py【编写数据库结构，字段等等】 |-- ./web/static【静态文件存放目录】 | |-- ./web/static/css | | |-- ./web/static/css/commons.css | | |-- 略 | |-- ./web/static/images | | `-- ./web/static/images/default.png | |-- ./web/static/js | | |-- ./web/static/js/JQuery3.6.0.js | | |-- 略 | `-- ./web/static/plugins | |-- ./web/static/plugins/bootstrap | | |-- ./web/static/plugins/bootstrap/css | | |-- ./web/static/plugins/bootstrap/fonts | | `-- ./web/static/plugins/bootstrap/js | `-- ./web/static/plugins/font-awesome | |-- 略 |-- ./web/templates | |-- ./web/templates/form.html【表单显示模板】 | |-- ./web/templates/form2.html【表单显示模板2】 | |-- ./web/templates/home.html【各种页面】 | |-- ./web/templates/include【include】 | | |-- ./web/templates/include/delete_modal.html | | `-- ./web/templates/include/search_group.html | |-- ./web/templates/layout.html【用于继承的模板文件】 | |-- ./web/templates/tag【tag】 | | `-- ./web/templates/tag/my_menu.html | `-- ./web/templates/transaction_list.html |-- ./web/templatetags【处理复杂页面渲染逻辑】 | |-- ./web/templatetags/__pycache__ | | |-- 略 | |-- ./web/templatetags/color.py | |-- ./web/templatetags/menu.py | `-- ./web/templatetags/permission.py |-- ./web/tests.py `-- ./web/views【视图函数，处理逻辑】 |-- ./web/views/__pycache__ | |-- 略 |-- ./web/views/account.py |-- ./web/views/customer.py |-- ./web/views/level.py |-- ./web/views/my_order.py |-- ./web/views/my_transaction.py `-- ./web/views/policy.py 经典的MVC设计模式及其优点：\nMVC即 Model-View-Controller(模型-视图-控制器) ，是经典的软件开发设计模式\nModel (模型) ： 简而言之即数据模型。模型不是数据本身（比如数据库里的数据），而是抽象的描述数据的构成和逻辑关系。通常模型包括了数据表的各个字段（比如人的年龄和出生日期）和相互关系（单对单，单对多关系等)。Web开发框架会根据模型的定义来自动生成数据表。 View (视图)： 主要用于显示数据，用来展示用户可以看到的内容或提供用户可以输入或操作的界面。数据来源于哪里？当然是数据库啦。那么用户输入的数据给谁? 当然是给控制器啦。 Controller(控制器)：应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据（比如增加或更新数据表）。 MVC设计模式实现了软件或网络应用开发过程中数据、业务逻辑和用户界面的分离，使软件开发更清晰，也是维护变得更容易。这与静态网页设计中使用html和css实现了内容和样式的分离是同一个道理。\nDjango的MVT设计模式由Model模型，View（视图）和Template（模板）三部分组成，分别对应单个app目录下的models.py, views.py和templates文件夹\n因实际开发时view函数过多，为了方便管理通常使用views目录取代单个view.py文件，在views目录下按功能编写各个py文件\nDjango Model(模型): 这个与经典MVC模式下的模型Model差不多。 Django View(视图): 这个与MVC下的控制器Controller更像。视图不仅负责根据用户请求从数据库读取数据、指定向用户展示数据的方式(网页或json数据), 还可以指定渲染模板并处理用户提交的数据。 Django Template(模板): 这个与经典MVC模式下的视图View一致。模板用来呈现Django view传来的数据，也决定了用户界面的外观。Template里面也包含了表单，可以用来搜集用户的输入内容。 Django工作流程：\n当用户发来一个请求(request)时，Django会对请求头信息进行解析，解析出用户需要访问的url地址，然后根据路由urls.py中的定义的对应关系把请求转发到相应的视图处理。视图会从数据库读取需要的数据，指定渲染模板，最后返回响应数据\n简易开发流程\n新建app并注册 先使用python manage.py startapp web创建一个名为web的app，并将其添加到settings.py中\n1 2 3 4 5 6 7 8 9 INSTALLED_APPS = [ \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;web.apps.WebConfig\u0026#39;, ] 在urls中添加路径与视图函数对应关系 创建模型 在app下新建名为models.py，在其中编写数据库字段及表与表的关联关系\n使用python manage.py makemigrations和python manage.py migrate命令让django在数据库中创建数据表\n创建视图函数 在app下新建名为views的目录，根据业务功能创建account.py，并在其中定义login函数，从数据库读取数据，处理逻辑，指定渲染模板并将数据传递给对应模板\n编辑模板 创建在web/templates下创建login.html文件用于展示视图传来的数据，Django还提供了自己的模板语言用来渲染模板。\n路由配置 项目文件夹和每个应用(app)目录下的urls.py文件构成了Django的路由配置系统(URLconf)。服务器收到用户请求后，会根据用户请求的url地址和urls.py里配置的url-视图映射关系，去调用执行相应的视图函数或视图类，最后由视图返回给客户端数据\nURLconf如何工作 手动路由分发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from django.urls import path from apps.web import views urlpatterns = [ path(\u0026#39;user/add/\u0026#39;, views.login), path(\u0026#39;user/delete/\u0026#39;, views.login), path(\u0026#39;user/edit/\u0026#39;, views.login), path(\u0026#39;user/list/\u0026#39;, views.login), # 提取公共部分，防止重复编写 path(\u0026#39;user/\u0026#39;, ([ path(\u0026#39;add/\u0026#39;, views.login), path(\u0026#39;delete/\u0026#39;, views.login), # /user/delete/ path(\u0026#39;edit/\u0026#39;, views.login), path(\u0026#39;list/\u0026#39;, views.login), ], None, None)), ] include+app，将功能拆分到不同的app中 要把app的urls加到项目的URL配置中\n1 2 3 4 5 6 from django.urls import include, path urlpatterns = [ path(\u0026#39;web/\u0026#39;, include(\u0026#39;apps.web.urls\u0026#39;)), ... ] 1 2 3 4 5 6 7 from django.urls import include, path from apps.api import views urlpatterns = [ # web/auth path(\u0026#39;auth/\u0026#39;, views.auth), ] URL设计方法 path\u0026lt;变量类型:变量名\u0026gt; 1 2 3 urlpatterns = [ path(\u0026#39;news/\u0026lt;int:nid\u0026gt;/edit/\u0026#39;, views.news), ] int，整数 str，字符串 slug，字母+数字+下划线+- uuid，uuid格式 path，路径，可以包含/ re_path(?p\u0026lt;变量名\u0026gt;表达式) 1 2 3 urlpatterns = [ re_path(r\u0026#39;user/(?P\u0026lt;xxid\u0026gt;\\w+-\\d+)/(?P\u0026lt;yid\u0026gt;\\d+)/\u0026#39;, views.user), ] 路由分发本质 URL对应函数\n1 path(\u0026#39;user/add/\u0026#39;, views.login), URL对应元组\n1 path(\u0026#39;user/\u0026#39;, (元素,appname元素,namespance元素) ), 1 2 path(\u0026#39;user/\u0026#39;, include(\u0026#34;apps.api.urls\u0026#34;) ),# include本质返回的就是一个形如([],None,None))的元组 path(\u0026#39;user/\u0026#39;, ([],None,None) ), include源码解读\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def include(arg, namespace=None): app_name = None if isinstance(arg, tuple): try: urlconf_module, app_name = arg # urlconf_module为列表，app_name为None except ValueError: ... else: urlconf_module = arg # urlconf_module被赋值为一个字符串如\u0026#34;apps.api.urls\u0026#34; if isinstance(urlconf_module, str): urlconf_module = import_module(urlconf_module) # urlconf_module为导入的模块如urls patterns = getattr(urlconf_module, \u0026#39;urlpatterns\u0026#39;, urlconf_module) # 利用反射语法去取urls模块中的值，此处patterns为一个列表，当urlconf_module为列表时，patterns为默认值即列表 app_name = getattr(urlconf_module, \u0026#39;app_name\u0026#39;, app_name) # app_name为None if namespace and not app_name: raise ImproperlyConfigured( \u0026#39;Specifying a namespace in include() without providing an app_name \u0026#39; \u0026#39;is not supported. Set the app_name attribute in the included \u0026#39; \u0026#39;module, or pass a 2-tuple containing the list of patterns and \u0026#39; \u0026#39;app_name instead.\u0026#39;, ) namespace = namespace or app_name # namespace=app_name=None if isinstance(patterns, (list, tuple)): for url_pattern in patterns: pattern = getattr(url_pattern, \u0026#39;pattern\u0026#39;, None) if isinstance(pattern, LocalePrefixPattern): raise ImproperlyConfigured( \u0026#39;Using i18n_patterns in an included URLconf is not allowed.\u0026#39; ) return (urlconf_module, app_name, namespace) # ([],None,None) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 path(\u0026#39;user/add/\u0026#39;, views.login), path(\u0026#39;user/delete/\u0026#39;, views.login), path(\u0026#39;user/edit/\u0026#39;, views.login), path(\u0026#39;user/list/\u0026#39;, views.login), path(\u0026#39;user/\u0026#39;, ([ path(\u0026#39;add/\u0026#39;, views.login), path(\u0026#39;delete/\u0026#39;, views.login), path(\u0026#39;edit/\u0026#39;, views.login), path(\u0026#39;list/\u0026#39;, views.login), ], None, None)), path(\u0026#39;users\u0026#39;, include(([ path(\u0026#39;add/\u0026#39;, views.login), path(\u0026#39;delete/\u0026#39;, views.login), path(\u0026#39;edit/\u0026#39;, views.login), path(\u0026#39;list/\u0026#39;, views.login), ], None))), include(\u0026#34;apps.api.urls\u0026#34;) # 一般是每个app中的urls，但其实是可以随意写的，只要其中有urlpatterns参数即可 urlpatterns = [ ] name 相当于给每个URL取了个全局变量的名字。可以让你能够在Django的任意处，尤其是模板内显式地引用它\n1 2 3 4 5 urlpatterns = [ path(\u0026#39;Login/\u0026lt;str:role\u0026gt;/\u0026#39;, views.login, name=\u0026#34;v1\u0026#34;), re_path(r\u0026#39;auth/(\\d+)/(\\w+)/\u0026#39;, views.auth, name=\u0026#34;v2\u0026#34;), re_path(r\u0026#39;xxxx/(?P\u0026lt;nid\u0026gt;\\d+)/(?P\u0026lt;tpl\u0026gt;\\w+)/\u0026#39;, views.auth, name=\u0026#34;v3\u0026#34;), ] 在视图函数中生成URL 有参数名传参用kargs={k1:k2}\n无参数名传参用args=(v1,v2)\n1 2 3 4 from django.urls import reverse url1 = reverse(\u0026#34;v1\u0026#34;, kwargs={\u0026#34;role\u0026#34;: \u0026#34;hhh\u0026#34;}) url2 = reverse(\u0026#34;v2\u0026#34;, args=(666, \u0026#34;hhh\u0026#34;)) 在模板中生成URL url是个模板标签，其作用是对命名的url进行方向解析，动态生成链接。\n命名的url里有几个参数，使用url模板标签反向生成动态链接时，就需要向它传递几个参数\n有名字的要给他传值，无名字的空格分隔即可\n1 2 \u0026lt;a href=\u0026#34;{% url \u0026#39;v1\u0026#39; role=\u0026#34;111\u0026#34; %}\u0026#34;\u0026gt;跳转\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;{% url \u0026#39;v2\u0026#39; 666 \u0026#34;111\u0026#34; %}\u0026#34;\u0026gt;跳转\u0026lt;/a\u0026gt; 拓展 1 用name属性配合做权限管理 namespace 假设不同的app（比如web和api）中有同名url该如何区分？\n主路由\n1 2 3 4 5 6 7 from django.urls import path, re_path, include # 很多功能，很多URL urlpatterns = [ path(\u0026#39;api/\u0026#39;, include(\u0026#34;apps.api.urls\u0026#34;,namespace=\u0026#39;x1\u0026#39;)), path(\u0026#39;web/\u0026#39;, include(\u0026#34;apps.web.urls\u0026#34;,namespace=\u0026#39;x2\u0026#39;)), ] api/urls.py\n1 2 3 4 5 6 7 8 from django.urls import path, re_path from . import views # 很多功能，很多URL urlpatterns = [ path(\u0026#39;login/\u0026#39;, views.login,name=\u0026#34;login\u0026#34;), path(\u0026#39;auth/\u0026#39;, views.auth, name=\u0026#39;auth\u0026#39;), ] app_name = \u0026#34;api\u0026#34; web/urls.py\n1 2 3 4 5 6 7 8 9 from django.urls import path, re_path from . import views # 很多功能，很多URL urlpatterns = [ path(\u0026#39;home/\u0026#39;, views.home,name=\u0026#39;home\u0026#39;), path(\u0026#39;order/\u0026#39;, views.order,name=\u0026#39;order\u0026#39;), path(\u0026#39;auth/\u0026#39;, views.order, name=\u0026#39;auth\u0026#39;), ] app_name = \u0026#34;web\u0026#34; 只需要在web/urls.py加上app_name='web'这个命名空间即可\n视图中使用 1 2 3 4 from django.urls import reverse url = reverse(\u0026#34;x1:auth\u0026#34;) # /api/auth/ url2 = reverse(\u0026#34;x2:auth\u0026#34;) # /web/auth/ 模板中使用 1 2 \u0026lt;a href=\u0026#34;{% url \u0026#39;x1:auth\u0026#39; %}\u0026#34;\u0026gt;跳转\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;{% url \u0026#39;x2:auth\u0026#39; %}\u0026#34;\u0026gt;跳转\u0026lt;/a\u0026gt; 补充\nurl末尾的/ APPEND_SLASH是一个设置项，用于确定Django是否自动为没有尾随斜杠（/）的URL添加斜杠。默认情况下，APPEND_SLASH设置为True，这意味着如果用户请求的URL没有以斜杠结尾，Django会发出一个301重定向到带有尾随斜杠的URL\n当前匹配对象 ResolverMatch对象是在URL解析过程中创建的，它包含了匹配到的URL模式的相关信息。当你访问一个URL时，Django的URL解析器会尝试找到匹配的模式，如果找到，它会创建一个ResolverMatch对象，并将其存储在请求对象的resolver_match属性中。\nResolverMatch对象在URL解析发生后才设置，这意味着它在所有视图中都是可用的，但在URL解析发生前的中间件中不可用（process_request）\n1 2 def my_view(request): resolver_match = request.resolver_match 作用\n直接访问URL中捕获的参数 根据参数不同处理视图逻辑分支 URL名称解析，用来动态生成链接 中间件支持，做权限控制 partial 1 2 3 4 5 6 def _xx(a1, a2): return a1 + a2 data = _xx(11, 22) print(data) 1 2 3 4 5 6 7 8 9 from functools import partial def _xx(a1, a2): return a1 + a2 yy = partial(_xx, a2=100) data = yy(2) print(data) 利用partial使得_path函数传入的Pattern不同，处理路由的方式不同\n视图 文件or文件夹 所有视图函数放在一个view.py会难以维护且影响可读性，建议根据功能业务不同命名对应的py文件，将所有py文件放在views目录下\n绝对导入和相对导入 原则：\n能用绝对导入就用绝对导入，层级过深不方便再用相对导入\n一定不要在项目根目录做相对导入\n视图参数 1 2 3 4 5 from django.shortcuts import HttpResponse def login(request): return HttpResponse(\u0026#34;login\u0026#34;) request是什么呢？\nrequest是由Django的中间件系统自动创建并传递给视图的一个对象，封装存放了浏览器发给服务器的所有内容，包括请求相关内容和django额外添加的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from django.shortcuts import HttpResponse def login(request): # 1.当前URL /api/login/ print(request.path_info) # 2.URL传递的参数 print(request.GET) print(request.GET.get(\u0026#34;age\u0026#34;)) # 3.请求方式 GET/POST print(request.method) # 4.如果post请求，传递请求体（原始数据） print(request.body) # b\u0026#39;{\u0026#34;code\u0026#34;:\u0026#34;083Sjmll2yla694F3bll2DguCM2SjmlG\u0026#34;,\u0026#34;unionId\u0026#34;:\u0026#34;oP6QCsyT_9bk1dfSaVf0GEV5Y-yE\u0026#34;}\u0026#39; b\u0026#39;v1=123\u0026amp;v2=456\u0026#39; # 4.1 请求体+请求头 b\u0026#39;v1=123\u0026amp;v2=456\u0026#39; + content-type:application/x-www-form-urlencoded print(request.POST) print(request.POST.get(\u0026#34;v1\u0026#34;)) print(request.POST.get(\u0026#34;v2\u0026#34;)) # 4.2 请求体+请求头 文件 print(request.FILES) # 文件格式 + content-type:multipart/form-data print(request.FILES.get(\u0026#34;n1\u0026#34;)) print(request.FILES.get(\u0026#34;n2\u0026#34;)) # 5.请求头 # {\u0026#39;Content-Length\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;text/plain\u0026#39;, \u0026#39;Host\u0026#39;: \u0026#39;127.0.0.1:8000\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;, \u0026#39;Cache-Control\u0026#39;: \u0026#39;max-age=0\u0026#39;, \u0026#39;Sec-Ch-Ua\u0026#39;: \u0026#39;\u0026#34; Not A;Brand\u0026#34;;v=\u0026#34;99\u0026#34;, \u0026#34;Chromium\u0026#34;;v=\u0026#34;102\u0026#34;, \u0026#34;Google Chrome\u0026#34;;v=\u0026#34;102\u0026#34;\u0026#39;, \u0026#39;Sec-Ch-Ua-Mobile\u0026#39;: \u0026#39;?0\u0026#39;, \u0026#39;Sec-Ch-Ua-Platform\u0026#39;: \u0026#39;\u0026#34;macOS\u0026#34;\u0026#39;, \u0026#39;Upgrade-Insecure-Requests\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\u0026#39;, \u0026#39;Sec-Fetch-Site\u0026#39;: \u0026#39;none\u0026#39;, \u0026#39;Sec-Fetch-Mode\u0026#39;: \u0026#39;navigate\u0026#39;, \u0026#39;Sec-Fetch-User\u0026#39;: \u0026#39;?1\u0026#39;, \u0026#39;Sec-Fetch-Dest\u0026#39;: \u0026#39;document\u0026#39;, \u0026#39;Accept-Encoding\u0026#39;: \u0026#39;gzip, deflate, br\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7\u0026#39;, \u0026#39;Cookie\u0026#39;: \u0026#39;csrftoken=CdidpKSGbLxzmOXnbmlkvrZep1eJmKLAA81T73UjcjxEnMOa4YOZqtc849AkYfUy\u0026#39;} print(request.headers) # 5.1 请求头有个特殊的cookie # request.headers[\u0026#39;cookie\u0026#39;] # \u0026#39;csrftoken=CdidpKSGbLxzmOXnbmlkvrZep1eJmKLAA81T73UjcjxEnMOa4YOZqtc849AkYfUy;session=xxxx\u0026#39; # {\u0026#39;csrftoken\u0026#39;: \u0026#39;CdidpKSGbLxzmOXnbmlkvrZep1eJmKLAA81T73UjcjxEnMOa4YOZqtc849AkYfUy\u0026#39;} print(request.COOKIES) # 6.requests中其他值 print(request.resolver_match) return HttpResponse(\u0026#34;login\u0026#34;) 补充：request源码解读\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def _get_post(self): # 去请求体解析body赋值给_post if not hasattr(self, \u0026#39;_post\u0026#39;): self._load_post_and_files() return self._post def _set_post(self, post): self._post = post @property def FILES(self): # 去请求体解析body赋值给_files if not hasattr(self, \u0026#39;_files\u0026#39;): self._load_post_and_files() return self._files POST = property(_get_post, _set_post) # 查询时执行_get_post，赋值时执行_set_post _load_post_and_files()函数解析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def _load_post_and_files(self): \u0026#34;\u0026#34;\u0026#34;Populate self._post and self._files if the content-type is a form type\u0026#34;\u0026#34;\u0026#34; if self.method != \u0026#39;POST\u0026#39;: self._post, self._files = QueryDict(encoding=self._encoding), MultiValueDict() return if self._read_started and not hasattr(self, \u0026#39;_body\u0026#39;): self._mark_post_parse_error() return if self.content_type == \u0026#39;multipart/form-data\u0026#39;: if hasattr(self, \u0026#39;_body\u0026#39;): # Use already read data data = BytesIO(self._body) else: data = self try: self._post, self._files = self.parse_file_upload(self.META, data) except MultiPartParserError: # An error occurred while parsing POST data. Since when # formatting the error the request handler might access # self.POST, set self._post and self._file to prevent # attempts to parse POST data again. self._mark_post_parse_error() raise elif self.content_type == \u0026#39;application/x-www-form-urlencoded\u0026#39;: self._post, self._files = QueryDict(self.body, encoding=self._encoding), MultiValueDict() else: self._post, self._files = QueryDict(encoding=self._encoding), MultiValueDict() 返回值 HttpResponse JsonResponse render redirect 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 3.1 字符串/字节/文本数据（图片验证码） return HttpResponse(\u0026#34;login\u0026#34;) # 3.2 JSON格式（前后端分离、app小程序后端、ajax请求） data_dict = {\u0026#34;status\u0026#34;: True, \u0026#39;data\u0026#39;: [11, 22, 33]} return JsonResponse(data_dict) # 3.3 重定向 return redirect(\u0026#34;https://www.baidu.com\u0026#34;) return redirect(\u0026#34;http://127.0.0.1:8000/api/auth/\u0026#34;) return redirect(\u0026#34;/api/auth/\u0026#34;) # 省略http://127.0.0.1:8000 return redirect(\u0026#34;auth\u0026#34;) # name from django.urls import reverse url = reverse(\u0026#34;auth\u0026#34;) return redirect(url) # name # 3.4 渲染 # - a.找到 \u0026#39;login.html\u0026#39; 并读取的内容，问题：去哪里找？ # - 默认先去settings.TEMPLATES.DIRS指定的路径找。（公共） # - 按注册顺序每个已注册的app中找他templates目录，去这个目录中寻找\u0026#39;login.html\u0026#39; # - 一般情况下，原则，那个app中的的模板，去哪个那个app中寻找。 # - b.渲染（替换）得到替换完成的字符串 # - c.返回浏览器 return render(request, \u0026#39;api/login.html\u0026#39;) html文件放置\n响应头 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from django.shortcuts import HttpResponse, redirect, render from django.http import JsonResponse def login(request): # 设置响应内容 res = HttpResponse(\u0026#34;login\u0026#34;) # 设置响应头 res[\u0026#39;xx1\u0026#39;] = \u0026#34;hahaha\u0026#34; res[\u0026#39;xx2\u0026#39;] = \u0026#34;hahaha\u0026#34; res[\u0026#39;xx3\u0026#39;] = \u0026#34;hahaha\u0026#34; # 设置cookie res.set_cookie(\u0026#39;k1\u0026#39;,\u0026#34;aaaaaaaa\u0026#34;) res.set_cookie(\u0026#39;k2\u0026#39;,\u0026#34;bbbbbb\u0026#34;) return res FBV和CBV 源码分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 自定义的UsersView类没有as_view()方法，于是找其父类View的as_view()方法 def as_view(cls, **initkwargs): \u0026#34;\u0026#34;\u0026#34;Main entry point for a request-response process.\u0026#34;\u0026#34;\u0026#34; for key in initkwargs: ... def view(request, *args, **kwargs): # self=UsersView() self = cls(**initkwargs) self.setup(request, *args, **kwargs) if not hasattr(self, \u0026#39;request\u0026#39;): ... return self.dispatch(request, *args, **kwargs) ... return view def dispatch(self, request, *args, **kwargs): if request.method.lower() in self.http_method_names: # hander为UsersView对象的get方法或post方法 handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed # hander() 调用 return handler(request, *args, **kwargs) # 本质还是一个函数 静态资源 开发需要：css，js，图片 1 2 - 根目录的 /static/ - 已经app目录下载 /static/ 文件夹下 媒体文件：用户上传的数据 1 - 根目录的 /media/ 静态文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 已注册的app的static目录 INSTALLED_APPS = [ # \u0026#39;django.contrib.admin\u0026#39;, # \u0026#39;django.contrib.auth\u0026#39;, # \u0026#39;django.contrib.contenttypes\u0026#39;, # \u0026#39;django.contrib.sessions\u0026#39;, # \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#34;apps.api.apps.ApiConfig\u0026#34;, \u0026#34;apps.web.apps.WebConfig\u0026#34;, ] ... # 根目录下的static目录 STATIC_URL = \u0026#39;/static/\u0026#39; STATICFILES_DIRS = ( os.path.join(BASE_DIR, \u0026#39;static\u0026#39;), # 项目级别的静态文件目录 ) 顺序：优先查找根目录下的static目录，若找不到再按注册顺序去已注册的app下的static目录\n如何导入？\n导入模块，调用里面的函数帮我去setting文件中读取STATIC_URL\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 {% load static %} \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;登录页面\u0026lt;/h1\u0026gt; \u0026lt;a href=\u0026#34;/xxx/xxxxx/\u0026#34;\u0026gt;调换dao xx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;{% url \u0026#39;login\u0026#39; %}\u0026#34;\u0026gt;跳转\u0026lt;/a\u0026gt; \u0026lt;img src=\u0026#34;{% static \u0026#39;api/1.png\u0026#39; %}\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 生产环境\n收集静态文件 1 2 # 将所有的静态文件收集到一个位置，以便Web服务器可以高效地提供这些文件 python manage.py collectstatic 配置Web服务器 在生产环境中，你需要配置Web服务器（如Nginx或Apache）来提供静态文件。你需要指定静态文件的目录（通常是 STATIC_ROOT）\n媒体文件 在你的 settings.py 文件中，你需要定义两个设置项：\nMEDIA_URL：媒体文件的URL前缀。 MEDIA_ROOT：服务器上存储上传文件的路径。 1 2 3 4 5 6 # settings.py # 上传的文件可以通过类似 http://yourdomain.com/media/yourfile.jpg 的URL来访问。 MEDIA_URL = \u0026#39;/media/\u0026#39; # BASE_DIR 是你的Django项目的根目录，media 是在项目根目录下的一个子目录，用于存储上传的文件 MEDIA_ROOT = BASE_DIR / \u0026#39;media\u0026#39; 在 urls.py 中添加以下URL模式，在开发环境中运行服务器时，Django将能够通过 /media/ URL前缀提供上传的文件\n1 2 3 4 5 6 7 8 9 10 11 # urls.py from django.conf import settings from django.conf.urls.static import static urlpatterns = [ # ... 你的其他url配置 ] if settings.DEBUG: urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) 模板 html模板的寻找顺序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 TEMPLATES = [ { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.template.backends.django.DjangoTemplates\u0026#39;, \u0026#39;DIRS\u0026#39;: [os.path.join(BASE_DIR, \u0026#39;templates\u0026#39;)], \u0026#39;APP_DIRS\u0026#39;: True, \u0026#39;OPTIONS\u0026#39;: { \u0026#39;context_processors\u0026#39;: [ \u0026#39;django.template.context_processors.debug\u0026#39;, \u0026#39;django.template.context_processors.request\u0026#39;, # \u0026#39;django.contrib.auth.context_processors.auth\u0026#39;, # \u0026#39;django.contrib.messages.context_processors.messages\u0026#39;, ], }, }, ] 参数介绍\nBACKEND 指定模板引擎的后端 DIRS 一个包含额外模板目录路径的列表,通常，这里用于存放全局模板 APP_DIRS 如果设置为True，则Django会在每个安装的应用的templates目录下寻找模板 OPTIONS 一个字典，包含模板引擎的选项 寻找顺序\n如果配置了DIRS目录，则Django会现在这些目录中寻找 在DIRS中找不到，会继续在每个app的templates目录中搜索，且顺序按照INSTALLED_APP的注册顺序进行 如何选择？\n简单的项目，模板都放在根目录 复杂的项目，模板放在各自的app中，公共部分放在templates目录 拓展：修改内置app的模板\n在根目录的templates目录下创建同名文件夹同名html文件，即可覆盖内置app提供的模板，因为有优先查找DIRS目录\n模板处理的本质 渲染完成后，生成了字符串，再返回给浏览器\n文件命名为.html只是为了编写html方便，实际上什么后缀都可以\n模板处理流程\n视图函数获取数据，创建上下文字典并传递给模板 1 2 3 4 5 6 7 from django.shortcuts import render from .models import MyModel def home(request): data = MyModel.objects.all() # 从数据库获取数据 context = {\u0026#39;data\u0026#39;: data} # 创建上下文 return render(request, \u0026#39;myapp/home.html\u0026#39;, context) # 渲染模板 渲染模板 render(）函数 根据模板名称查找模板 加载模板，准备渲染 处理上下文 将上下文字典插入模板。模板中的占位符（变量和标签）会被实际数据替代 处理模板中的模板标签和过滤器，例如：循环遍历数据、条件判断等 1 2 3 4 5 6 \u0026lt;h1\u0026gt;My Data\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; {% for item in data %} \u0026lt;li\u0026gt;{{ item.name }}\u0026lt;/li\u0026gt; {% endfor %} \u0026lt;/ul\u0026gt; 生成最终输出，返回响应 弹窗内容为{{ n2 }}，因为在js文件是在浏览器端发起的请求，此时模板渲染早已完成\n常用语法 变量传递\n调用方法不用加（）\n内置函数\n标签\n1 2 3 4 5 6 7 8 9 10 11 12 # if {% if condition %} \u0026lt;!-- code --\u0026gt; {% endif %} # for {% for item in items %} \u0026lt;!-- code --\u0026gt; {% endfor %} # url {% url \u0026#39;name\u0026#39; arg %} 模板继承\n1 2 3 4 {% extends \u0026#34;base.html\u0026#34; %} {% block title %}{% endblock %} {% block content %}{% endblock %} 自定义模板标签\nfilter 用于修改变量值，通常在模板变量后面使用，用管道符号|分隔\n1 2 - 数据处理，参数：1-2个 - 数据处理，if条件 1 2 3 4 5 6 7 8 # 在templatetags/custom_filters.py中 from django import template register = template.Library() @register.filter(name=\u0026#39;lowercase\u0026#39;) def lowercase(value): return value.lower() 模板中\n1 {{ my_variable|lowercase }} simple_tag 一个自定义的模板标签，它不接受任何模板变量，只接收位置参数和关键字参数，并返回一个字符串结果\n1 参数无限制 \u0026amp; 返回文本 1 2 3 4 5 6 7 8 # 在templatetags/custom_tags.py中 from django import template register = template.Library() @register.simple_tag def my_simple_tag(arg): return f\u0026#34;\u0026lt;p\u0026gt;{arg}\u0026lt;/p\u0026gt;\u0026#34; 模板中\n1 {% my_simple_tag \u0026#34;Hello, World!\u0026#34; %} inclusion_tag 类似于simple_tag，但它返回的是渲染后的模板片段，而不是一个简单的字符串。这允许你将模板的某个部分抽象成一个独立的模板文件，并在需要时包含进来\n1 参数无限制，返回html片段 1 2 3 4 5 6 7 8 # 在templatetags/custom_tags.py中 from django import template register = template.Library() @register.inclusion_tag(\u0026#39;custom_template.html\u0026#39;) def my_inclusion_tag(data): return {\u0026#39;data\u0026#39;: data} custom_template.html文件\n1 2 3 \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{{ data }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 模板中\n1 {% my_inclusion_tag \u0026#34;Some data\u0026#34; %} 继承与母版 基础模板（母版） 通常包含以下内容\n通用的HTML结构 占位符（block)，用于字幕版覆盖或扩展内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;{% block title %}My Site{% endblock %}\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;header\u0026gt; \u0026lt;!-- 通用头部内容 --\u0026gt; \u0026lt;/header\u0026gt; {% block content %} \u0026lt;!-- 默认内容，子模板可以覆盖或扩展 --\u0026gt; {% endblock %} \u0026lt;footer\u0026gt; \u0026lt;!-- 通用底部内容 --\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 子模板 子模板继承基础模板，并可以覆盖或扩展其中的内容\n1 2 3 4 5 6 7 8 {% extends \u0026#34;base.html\u0026#34; %} {% block title %}Home Page{% endblock %} {% block content %} \u0026lt;h1\u0026gt;Welcome to the Home Page\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is the home page content.\u0026lt;/p\u0026gt; {% endblock %} 母版一般放在根目录下的templates目录，若要视app为组件，可在app下的templates也放一份\n模板的导入 先继承模板，再导入嵌套模板，最后再进行渲染\n1 {% include \u0026#34;template_name.html\u0026#34; %} 中间件 Django生命周期\n类 定义方法 注册 简单实例（原始） MiddlewareMixin（推荐） 食用方法 自定义process_request和process_response方法，其他继承MiddlewareMixin即可\n源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class MiddlewareMixin: def __init__(self, get_response=None): self.get_response = get_response def __call__(self, request): response = None if hasattr(self, \u0026#39;process_request\u0026#39;): response = self.process_request(request) response = response or self.get_response(request) if hasattr(self, \u0026#39;process_response\u0026#39;): response = self.process_response(request, response) return response class MyMd(MiddlewareMixin): def process_request(self,request): ... def process_response(self,request, response): ... django内部默认执行call方法，传入参数。 执行流程 process_request都没有返回值，如果有返回值则直接执行其process_response，不再执行后续中间件及视图函数\n用于权限判断，ip黑名单拦截\nprocess_response都有返回值，用于给response添加信息\n中间件间的执行顺序按照注册顺序\n总结：\n先按顺序依次执行各个中间件的process_request，再进行路由匹配，在返回去执行process_view方法才进入视图函数，若某一process_view有返回值，则直接跳走，完整执行process_reponse\nprocess_view是在django中写死了的\n其他 process_exception 当视图抛出异常时，Django会寻找一个合适的响应\nDjango会从后向前遍历中间件栈，调用每个中间件的process_exception方法，直到找到一个返回了响应对象（HttpResponse或其子类实例）的方法，如果到达中间件栈的开始都没有找到返回响应的方法，Django将显示默认的500错误页面（服务器内部错误）\n这个方法允许开发者在异常发生时执行一些清理工作，或者返回一个自定义的响应给客户端，而不是默认的错误页面\nprocess_template_response 在视图被完全执行后调用，如果响应实例有render()方法，表明它是一个TemplateResponse或等效对象。这个方法允许你在模板渲染之后、响应发送到客户端之前，对TemplateResponse对象进行处理\n执行顺序\nprocess_template_response方法在视图函数返回一个TemplateResponse对象后被调用。 如果视图返回的是一个TemplateResponse对象，Django会从中间件栈的末尾开始调用中间件的process_template_response方法，直到找到一个返回了TemplateResponse对象的方法或者到达中间件栈的开始。 中间件在响应阶段会按照相反的顺序运行，其中包括process_template_response。 总结 定义中间类 类方法 process_request process_view process_reponse process_exception，视图函数出现异常，自定义异常页面。 process_template_response，视图函数返回TemplateResponse对象 or 对象中含有.render方法。 ORM操作 ORM（Object-Relational Mapping，对象关系映射）是Django框架的核心组件之一，它允许开发者使用Python代码来操作数据库，而无需编写SQL语句。ORM抽象了数据库的操作，使得开发者可以像操作普通Python对象一样操作数据库\n本质就是翻译的\n特点：开发效率高，执行效率低\nORM基本操作步骤 settings.py，连接数据库 1 2 3 4 5 6 DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.sqlite3\u0026#39;, \u0026#39;NAME\u0026#39;: BASE_DIR / \u0026#39;db.sqlite3\u0026#39;, } } settings.py，注册app 1 2 3 4 INSTALLED_APP = [ ... \u0026#34;app01.apps.App01Config\u0026#34; ] 编写models类 1 2 3 class UserInfo(models.Model): .... ..... 执行命令 1 2 3 python manage.py makemigrations # 创建迁移文件，找到所有已注册的app中的models.py中的类读取 -\u0026gt; migrations配置 python manage.py migrate # 应用迁移到数据库，读取已注册的app下的migrations配置 -\u0026gt; SQL语句 -\u0026gt; 同步数据库 # 自带的app已默认生成migrations 连接数据库 1 2 3 4 5 6 DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.sqlite3\u0026#39;, \u0026#39;NAME\u0026#39;: BASE_DIR / \u0026#39;db.sqlite3\u0026#39;, } } 1 2 3 4 5 6 7 8 9 10 DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.mysql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;xxxxxxxx\u0026#39;, # 数据库名字 \u0026#39;USER\u0026#39;: \u0026#39;root\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;root123\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, # ip \u0026#39;PORT\u0026#39;: 3306, } } 项目连接MySQL： 安装MySQL并启动MySQL服务 手动创建数据库 配置django的settings.py 1 2 3 4 5 6 7 8 9 10 DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.mysql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;xxxxxxxx\u0026#39;, # 数据库名字 \u0026#39;USER\u0026#39;: \u0026#39;root\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;root123\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, # ip \u0026#39;PORT\u0026#39;: 3306, } } 安装第三方组件 选其一即可 pymysql 1 pip install pymysql 1 2 3 项目根目录/项目名目录/__init__.py import pymysql pymysql.install_as_MySQLdb() - mysqlclient 1 pip install mysqlclient 其他数据库 pgsql 1 2 3 4 5 6 7 8 9 10 11 12 DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.postgresql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;mydatabase\u0026#39;, \u0026#39;USER\u0026#39;: \u0026#39;mydatabaseuser\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;mypassword\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;PORT\u0026#39;: 5432, } } # 需要 pip install psycopg2 1 2 3 4 5 6 7 8 9 10 11 DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.oracle\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#34;xxxx\u0026#34;, # 库名 \u0026#34;USER\u0026#34;: \u0026#34;xxxxx\u0026#34;, # 用户名 \u0026#34;PASSWORD\u0026#34;: \u0026#34;xxxxx\u0026#34;, # 密码 \u0026#34;HOST\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, # ip \u0026#34;PORT\u0026#34;: 1521, # 端口 } } # 需要 pip install cx-Oracle 连接池 django默认内置没有连接池\n1 2 pymysql -\u0026gt; 操作数据库 DBUtils -\u0026gt; 连接池 django-db-connection-pool组件\n1 pip install django-db-connection-pool 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 DATABASES = { \u0026#34;default\u0026#34;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;dj_db_conn_pool.backends.mysql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;day04\u0026#39;, # 数据库名字 \u0026#39;USER\u0026#39;: \u0026#39;root\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;root123\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, # ip \u0026#39;PORT\u0026#39;: 3306, \u0026#39;POOL_OPTIONS\u0026#39;: { \u0026#39;POOL_SIZE\u0026#39;: 10, # 最小 \u0026#39;MAX_OVERFLOW\u0026#39;: 10, # 在最小的基础上，还可以增加10个，即：最大20个。 \u0026#39;RECYCLE\u0026#39;: 24 * 60 * 60, # 连接可以被重复用多久，超过会重新创建，-1表示永久。 \u0026#39;TIMEOUT\u0026#39;:30, # 池中没有连接最多等待的时间。 } } } 多数据库 django支持项目连接多个数据库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 DATABASES = { \u0026#34;default\u0026#34;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;dj_db_conn_pool.backends.mysql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;day05db\u0026#39;, # 数据库名字 \u0026#39;USER\u0026#39;: \u0026#39;root\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;root123\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, # ip \u0026#39;PORT\u0026#39;: 3306, \u0026#39;POOL_OPTIONS\u0026#39;: { \u0026#39;POOL_SIZE\u0026#39;: 10, # 最小 \u0026#39;MAX_OVERFLOW\u0026#39;: 10, # 在最小的基础上，还可以增加10个，即：最大20个。 \u0026#39;RECYCLE\u0026#39;: 24 * 60 * 60, # 连接可以被重复用多久，超过会重新创建，-1表示永久。 \u0026#39;TIMEOUT\u0026#39;: 30, # 池中没有连接最多等待的时间。 } }, \u0026#34;bak\u0026#34;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;dj_db_conn_pool.backends.mysql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;day05bak\u0026#39;, # 数据库名字 \u0026#39;USER\u0026#39;: \u0026#39;root\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;root123\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, # ip \u0026#39;PORT\u0026#39;: 3306, \u0026#39;POOL_OPTIONS\u0026#39;: { \u0026#39;POOL_SIZE\u0026#39;: 10, # 最小 \u0026#39;MAX_OVERFLOW\u0026#39;: 10, # 在最小的基础上，还可以增加10个，即：最大20个。 \u0026#39;RECYCLE\u0026#39;: 24 * 60 * 60, # 连接可以被重复用多久，超过会重新创建，-1表示永久。 \u0026#39;TIMEOUT\u0026#39;: 30, # 池中没有连接最多等待的时间。 } }, } 读写分离 1 2 3 192.168.1.2 default master [写] 组件 192.168.2.12 bak slave [读] 生成数据库表 1 2 3 4 5 python manage.py makemigrations # 找到所有已注册的app中的models.py中的类读取 -\u0026gt; migrations配置 python manage.py migrate python manage.py migrate --database=default python manage.py migrate --database=bak 后续再进行开发时 1 2 3 models.UserInfo.objects.using(\u0026#34;default\u0026#34;).create(title=\u0026#34;武沛齐\u0026#34;) models.UserInfo.objects.using(\u0026#34;bak\u0026#34;).all() 编写router类，简化后续开发时操作 1 2 3 4 5 6 7 class DemoRouter(object): def db_for_read(...): return \u0026#34;bak\u0026#34; def db_for_write(...): return \u0026#34;default\u0026#34; 1 router = [\u0026#34;DemoRouter\u0026#34;] 1 2 3 - settings文件配置 DATABASE_ROUTERS - 编写settings中配置的文件和类 进行数据库操作时，会根据读还是写进入db_for_read或db_for_write函数，然后根据其返回的数据库名对其进行操作 分库（多app -\u0026gt; 多数据库） 100张表，A库存放app01生成的50张表，B库存放app02生成的50张表\napp01/models 1 2 3 4 5 from django.db import models class UserInfo(models.Model): title = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32) app02/models 1 2 3 4 5 from django.db import models class Role(models.Model): title = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32) 命令 1 2 3 python manage.py makemigrations python manage.py migrate app01 --database=default python manage.py migrate app02 --database=bak 读写操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from django.shortcuts import render, HttpResponse from app01 import models as m1 from app02 import models as m2 def index(request): # app01中的操作 -\u0026gt; default v1 = m1.UserInfo.objects.all() print(v1) # app02中的操作 -\u0026gt; bak v2 = m2.Role.objects.using(\u0026#39;bak\u0026#39;).all() print(v2) return HttpResponse(\u0026#34;返回\u0026#34;) router 分库（单app） 100张表，20张表-A数据库；50张表-B数据库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from django.shortcuts import render, HttpResponse from app01 import models as m1 def index(request): # app01中的操作 -\u0026gt; default v1 = m1.UserInfo.objects.all() print(v1) # app01中的操作 -\u0026gt; bak v2 = m1.Role.objects.using(\u0026#39;bak\u0026#39;).all() print(v2) return HttpResponse(\u0026#34;返回\u0026#34;) 注意事项 分库，将表拆分到不同的数据库 1 2 3 不要做跨数据库关联 -\u0026gt; django不支持 尽可能将关联的表放到一个库中 为什么分库 减轻数据库压力\n表关系 单表 1 2 class Role(models.Model): title = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32) 一对多 1 2 3 4 class Meta: db_table = \u0026#34;depart\u0026#34; # 自定义表名，默认是app名_表名 index_together={} # 联合索引 unique_together=((),) # 联合唯一索引 多对多 如果关系只有3列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Boy(models.Model): \u0026#34;\u0026#34;\u0026#34; 1 杰森斯坦森 2 汤普森 \u0026#34;\u0026#34;\u0026#34; name = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32, unique=True) b = models.ManyToManyField(to=\u0026#34;Girl\u0026#34;) class Girl(models.Model): \u0026#34;\u0026#34;\u0026#34; 1 alex 2 苑昊 \u0026#34;\u0026#34;\u0026#34; name = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32, unique=True) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Boy(models.Model): \u0026#34;\u0026#34;\u0026#34; 1 杰森斯坦森 2 汤普森 \u0026#34;\u0026#34;\u0026#34; name = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32, unique=True) class Girl(models.Model): \u0026#34;\u0026#34;\u0026#34; 1 alex 2 苑昊 \u0026#34;\u0026#34;\u0026#34; name = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32, unique=True) b = models.ManyToManyField(to=\u0026#34;Boy\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 # 初学阶段建议 class Boy(models.Model): name = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32, unique=True) class Girl(models.Model): name = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32, unique=True) class B2G(models.Model): bid = models.ForeignKey(to=\u0026#34;Boy\u0026#34;, on_delete=models.CASCADE) gid = models.ForeignKey(to=\u0026#34;Girl\u0026#34;, on_delete=models.CASCADE) address = models.CharField(verbose_name=\u0026#34;地点\u0026#34;, max_length=32) 一对一 数据操作 单表 增 1 2 class Role(models.Model): title = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32) 1 2 3 4 5 6 7 8 9 10 11 obj1 = models.Role.objects.create(title=\u0026#34;管理员\u0026#34;, od=1) obj2 = models.Role.objects.create(**{\u0026#34;title\u0026#34;: \u0026#34;管理员\u0026#34;, \u0026#34;od\u0026#34;: 1}) 内存 -\u0026gt; save obj = models.Role(title=\u0026#34;客户\u0026#34;, od=1) obj.od = 100 obj.save() obj = models.Role(**{\u0026#34;title\u0026#34;: \u0026#34;管理员\u0026#34;, \u0026#34;od\u0026#34;: 1}) obj.od = 100 obj.save() 控制输出格式 重写__str__方法\n删 1 2 # models.Role.objects.all().delete() models.Role.objects.filter(title=\u0026#34;管理员\u0026#34;).delete() 改 1 2 3 models.Role.objects.all().update(od=99) models.Role.objects.filter(id=7).update(od=99, title=\u0026#34;管理员\u0026#34;) models.Role.objects.filter(id=7).update(**{\u0026#34;od\u0026#34;: 99, \u0026#34;title\u0026#34;: \u0026#34;管理员\u0026#34;}) 查 条件筛选\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # QuerySet = [obj, obj] v1 = models.Role.objects.all() for obj in v1: print(obj, obj.id, obj.title, obj.od) # QuerySet = [] # v2 = models.Role.objects.filter(od=99, id=99) v2 = models.Role.objects.filter(**{\u0026#34;od\u0026#34;: 99, \u0026#34;id\u0026#34;: 99}) for obj in v2: print(obj, obj.id, obj.title, obj.od) v3 = models.Role.objects.filter(id=99) print(v3.query) v3 = models.Role.objects.filter(id__gt=2) print(v3.query) # \u0026gt; v3 = models.Role.objects.filter(id__gte=2) print(v3.query) # \u0026gt;= v3 = models.Role.objects.filter(id__lt=2) print(v3.query) # \u0026lt; v3 = models.Role.objects.filter(id__in=[11, 22, 33]) print(v3.query) v3 = models.Role.objects.filter(title__contains=\u0026#34;户\u0026#34;) print(v3.query) v3 = models.Role.objects.filter(title__startswith=\u0026#34;户\u0026#34;) print(v3.query) v3 = models.Role.objects.filter(title__isnull=True) print(v3.query) 不等于\n1 2 3 4 5 v3 = models.Role.objects.filter(id=99) print(v3.query) # 不等于 v3 = models.Role.objects.exclude(id=99).filter(od=88) print(v3.query) 获取字典，元组列表\n1 2 3 4 5 6 7 8 9 # queryset=[obj,obj] v3 = models.Role.objects.filter(id=99) # queryset=[{\u0026#39;id\u0026#39;: 6, \u0026#39;title\u0026#39;: \u0026#39;客户\u0026#39;}, {\u0026#39;id\u0026#39;: 7, \u0026#39;title\u0026#39;: \u0026#39;客户\u0026#39;}] v4 = models.Role.objects.filter(id__gt=0).values(\u0026#34;id\u0026#34;, \u0026#39;title\u0026#39;) # QuerySet = [(6, \u0026#39;客户\u0026#39;), (7, \u0026#39;客户\u0026#39;)] v5 = models.Role.objects.filter(id__gt=0).values_list(\u0026#34;id\u0026#34;, \u0026#39;title\u0026#39;) print(v5[0]) 获取单个对象\n1 2 3 4 5 v6 = models.Role.objects.filter(id__gt=0).first() # print(v6) # 对象 v7 = models.Role.objects.filter(id__gt=10).exists() print(v7) # True/False 排序\n1 2 3 4 5 # asc v8 = models.Role.objects.filter(id__gt=0).order_by(\u0026#34;id\u0026#34;) # id desc od asc v9 = models.Role.objects.filter(id__gt=0).order_by(\u0026#34;-id\u0026#34;, \u0026#39;od\u0026#39;) 一对多 1 2 3 4 5 6 7 8 9 10 class Depart(models.Model): \u0026#34;\u0026#34;\u0026#34; 部门 \u0026#34;\u0026#34;\u0026#34; title = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32) class Admin(models.Model): name = models.CharField(verbose_name=\u0026#34;姓名\u0026#34;, max_length=32) pwd = models.CharField(verbose_name=\u0026#34;密码\u0026#34;, max_length=32) depart = models.ForeignKey(verbose_name=\u0026#34;部门\u0026#34;, to=\u0026#34;Depart\u0026#34;, on_delete=models.CASCADE) 增 1 2 3 4 5 6 models.Admin.objects.create(name=\u0026#39;武沛齐1\u0026#39;, pwd=\u0026#39;123123123\u0026#39;, depart_id=2) # models.Admin.objects.create(**{..}) obj = models.Depart.objects.filter(id=2).first() models.Admin.objects.create(name=\u0026#39;武沛齐2\u0026#39;, pwd=\u0026#39;123123123\u0026#39;, depart=obj) models.Admin.objects.create(name=\u0026#39;武沛齐2\u0026#39;, pwd=\u0026#39;123123123\u0026#39;, depart_id=obj.id) 删 1 2 3 4 5 6 7 8 9 10 # filter() # 当前表的字段 + depart__字段 -\u0026gt; 连表和条件 # 找到部门id=3的所有的员工，删除 models.Admin.objects.filter(depart_id=3).delete() # 删除销售部的所有员工 obj = models.Depart.objects.filter(title=\u0026#34;销售部\u0026#34;).first() models.Admin.objects.filter(depart_id=obj.id).delete() # 跨表 models.Admin.objects.filter(depart__title=\u0026#34;销售部\u0026#34;, name=\u0026#39;武沛齐\u0026#39;).delete() 改 1 2 3 4 5 # 查询 models.Admin.objects.filter(id=2).update(name=\u0026#39;xxx\u0026#39;, pwd=\u0026#39;xxxx\u0026#39;) models.Admin.objects.filter(name=\u0026#34;武沛齐\u0026#34;).update(depart_id=2) # models.Admin.objects.filter(id=2).update(depart__title=\u0026#34;技术部\u0026#34;) -\u0026gt; 只能更新自己表字段 查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1. select * from admin queryset=[obj,obj,] v1 = models.Admin.objects.filter(id__gt=0) for obj in v1: print(obj.name, obj.pwd, obj.id, obj.depart_id) # 以这种方式查找尽量不要跨表，效率很低 # 2. select * from admin inner join depart queryset=[obj,obj,] v2 = models.Admin.objects.filter(id__gt=0).select_related(\u0026#34;depart\u0026#34;) for obj in v2: print(obj.name, obj.pwd, obj.id, obj.depart_id, obj.depart.title) # 3. select id,name.. from admin inner join depart queryset=[{},{}] v3 = models.Admin.objects.filter(id__gt=0).values(\u0026#34;id\u0026#34;, \u0026#39;name\u0026#39;, \u0026#39;pwd\u0026#39;, \u0026#34;depart__title\u0026#34;) print(v3) # 4. select id,name.. from admin inner join depart queryset=[(),()] v4 = models.Admin.objects.filter(id__gt=0).values_list(\u0026#34;id\u0026#34;, \u0026#39;name\u0026#39;, \u0026#39;pwd\u0026#39;, \u0026#34;depart__title\u0026#34;) print(v4) 多对多 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from django.db import models class Boy(models.Model): name = models.CharField(verbose_name=\u0026#34;姓名\u0026#34;, max_length=32, db_index=True) class Girl(models.Model): name = models.CharField(verbose_name=\u0026#34;姓名\u0026#34;, max_length=32, db_index=True) class B2G(models.Model): bid = models.ForeignKey(to=\u0026#34;Boy\u0026#34;, on_delete=models.CASCADE) gid = models.ForeignKey(to=\u0026#34;Girl\u0026#34;, on_delete=models.CASCADE) address = models.CharField(verbose_name=\u0026#34;地点\u0026#34;, max_length=32) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def index(request): models.Boy.objects.create(name=\u0026#34;宝强\u0026#34;) models.Boy.objects.create(name=\u0026#34;羽凡\u0026#34;) models.Boy.objects.create(name=\u0026#34;乃亮\u0026#34;) models.Girl.objects.bulk_create( objs=[models.Girl(name=\u0026#34;小路\u0026#34;), models.Girl(name=\u0026#34;百合\u0026#34;), models.Girl(name=\u0026#34;马蓉\u0026#34;)], batch_size=3 ) # 创建关系 models.B2G.objects.create(bid_id=1, gid_id=3, address=\u0026#34;北京\u0026#34;) models.B2G.objects.create(bid_id=1, gid_id=2, address=\u0026#34;北京\u0026#34;) models.B2G.objects.create(bid_id=2, gid_id=2, address=\u0026#34;北京\u0026#34;) models.B2G.objects.create(bid_id=2, gid_id=1, address=\u0026#34;北京\u0026#34;) b_obj = models.Boy.objects.filter(name=\u0026#39;宝强\u0026#39;).first() g_object = models.Girl.objects.filter(name=\u0026#34;小路\u0026#34;).first() models.B2G.objects.create(bid=b_obj, gid=g_object, address=\u0026#34;北京\u0026#34;) # 1.宝强都与谁约会。 queyset=[obj,obj,obj] q = models.B2G.objects.filter(bid__name=\u0026#39;宝强\u0026#39;).select_related(\u0026#34;gid\u0026#34;) for item in q: print(item.id, item.address, item.bid.name, item.gid.name) q = models.B2G.objects.filter(bid__name=\u0026#39;宝强\u0026#39;).values(\u0026#34;id\u0026#34;, \u0026#39;bid__name\u0026#39;, \u0026#39;gid__name\u0026#39;) for item in q: print(item[\u0026#39;id\u0026#39;], item[\u0026#39;bid__name\u0026#39;], item[\u0026#39;gid__name\u0026#39;]) # 2.百合 都与谁约会。 q = models.B2G.objects.filter(gid__name=\u0026#39;百合\u0026#39;).values(\u0026#34;id\u0026#34;, \u0026#39;bid__name\u0026#39;, \u0026#39;gid__name\u0026#39;) for item in q: print(item[\u0026#39;id\u0026#39;], item[\u0026#39;bid__name\u0026#39;], item[\u0026#39;gid__name\u0026#39;]) # 3.删除 models.B2G.objects.filter(id=1).delete() models.Boy.objects.filter(id=1).delete() return HttpResponse(\u0026#34;返回\u0026#34;) 一对一 cookie和seeesion cookie 1 2 127.0.0.1 v1.wupeiqi.com 127.0.0.1 v2.wupeiqi.com 配置session 文件版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 MIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, # \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, # \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, ] # session SESSION_ENGINE = \u0026#39;django.contrib.sessions.backends.file\u0026#39; SESSION_FILE_PATH = \u0026#39;xxxx\u0026#39; SESSION_COOKIE_NAME = \u0026#34;sid\u0026#34; # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串 SESSION_COOKIE_PATH = \u0026#34;/\u0026#34; # Session的cookie保存的路径 SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名 SESSION_COOKIE_SECURE = False # 是否Https传输cookie SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输 SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周） SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期 SESSION_SAVE_EVERY_REQUEST = True # 是否每次请求都保存Session，默认修改之后才保存 数据库版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 INSTALLED_APPS = [ # \u0026#39;django.contrib.admin\u0026#39;, # \u0026#39;django.contrib.auth\u0026#39;, # \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, # \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#34;app01.apps.App01Config\u0026#34;, ] MIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, # \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, # \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, ] # session SESSION_ENGINE = \u0026#39;django.contrib.sessions.backends.db\u0026#39; SESSION_COOKIE_NAME = \u0026#34;sid\u0026#34; # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串 SESSION_COOKIE_PATH = \u0026#34;/\u0026#34; # Session的cookie保存的路径 SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名 SESSION_COOKIE_SECURE = False # 是否Https传输cookie SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输 SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周） SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期 SESSION_SAVE_EVERY_REQUEST = True # 是否每次请求都保存Session，默认修改之后才保存 缓存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 INSTALLED_APPS = [ # \u0026#39;django.contrib.admin\u0026#39;, # \u0026#39;django.contrib.auth\u0026#39;, # \u0026#39;django.contrib.contenttypes\u0026#39;, # \u0026#39;django.contrib.sessions\u0026#39;, # \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#34;app01.apps.App01Config\u0026#34;, ] MIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, # \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, # \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, ] # session SESSION_ENGINE = \u0026#39;django.contrib.sessions.backends.cache\u0026#39; SESSION_CACHE_ALIAS = \u0026#39;default\u0026#39; SESSION_COOKIE_NAME = \u0026#34;sid\u0026#34; # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串 SESSION_COOKIE_PATH = \u0026#34;/\u0026#34; # Session的cookie保存的路径 SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名 SESSION_COOKIE_SECURE = False # 是否Https传输cookie SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输 SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周） SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期 SESSION_SAVE_EVERY_REQUEST = True # 是否每次请求都保存Session，默认修改之后才保存 缓存 服务器 + redis安装启动 django 安装连接redis包 1 pip install django-redis - settings.py 1 2 3 4 5 6 7 8 9 10 11 CACHES = { \u0026#34;default\u0026#34;: { \u0026#34;BACKEND\u0026#34;: \u0026#34;django_redis.cache.RedisCache\u0026#34;, \u0026#34;LOCATION\u0026#34;: \u0026#34;redis://127.0.0.1:6379\u0026#34;, \u0026#34;OPTIONS\u0026#34;: { \u0026#34;CLIENT_CLASS\u0026#34;: \u0026#34;django_redis.client.DefaultClient\u0026#34;, \u0026#34;CONNECTION_POOL_KWARGS\u0026#34;: {\u0026#34;max_connections\u0026#34;: 100} # \u0026#34;PASSWORD\u0026#34;: \u0026#34;密码\u0026#34;, } } } - 手动操作redis 1 2 3 4 5 from django_redis import get_redis_connection conn = get_redis_connection(\u0026#34;default\u0026#34;) conn.set(\u0026#34;xx\u0026#34;,\u0026#34;123123\u0026#34;) conn.get(\u0026#34;xx\u0026#34;) ","date":"2025-02-27T18:10:47+08:00","permalink":"https://yn0t1me.github.io/p/django/","title":"Django"}]