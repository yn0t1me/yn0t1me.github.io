[{"content":"1. 前言 1.1 前后端分离 1.2 django的FBV和CBV FBV：function base views，即编写函数来处理业务请求（函数） 1 2 3 4 5 6 from django.contrib import admin from django.urls import path from app01 import views urlpatterns = [ path(\u0026#39;users/\u0026#39;, views.users), ] 1 2 3 4 5 6 7 8 from django.http import JsonResponse def users(request,*args, **kwargs): if request.method == \u0026#34;GET\u0026#34;: return JsonResponse({\u0026#34;code\u0026#34;:1000,\u0026#34;data\u0026#34;:\u0026#34;xxx\u0026#34;}) elif request.method == \u0026#39;POST\u0026#39;: return JsonResponse({\u0026#34;code\u0026#34;:1000,\u0026#34;data\u0026#34;:\u0026#34;xxx\u0026#34;}) ... CBV，class base views，即编写类来处理业务请求（类加反射） 1 2 3 4 5 6 from django.contrib import admin from django.urls import path from app01 import views urlpatterns = [ path(\u0026#39;users/\u0026#39;, views.UserView.as_view()), ] 1 2 3 4 5 6 7 8 from django.views import View class UserView(View): def get(self, request, *args, **kwargs): return JsonResponse({\u0026#34;code\u0026#34;: 1000, \u0026#34;data\u0026#34;: \u0026#34;xxx\u0026#34;}) def post(self, request, *args, **kwargs): return JsonResponse({\u0026#34;code\u0026#34;: 1000, \u0026#34;data\u0026#34;: \u0026#34;xxx\u0026#34;}) 其实，CBV和FBV的底层实现本质上相同的。\n1.3 drf 1 2 3 4 5 6 # django中的CBV class View() # drf框架中的CBV class APIViews(View) # 自定义的类 class UserInfo(APIViews) 2. 创建项目 2.1 django配置 创建纯净python项目并配置虚拟环境 安装django库并完成基础的项目配置 1 2 3 4 5 6 # 安装django库 pip install django==3.2 # 创建项目目录 django-admin startproject day13 . # 创建一个app python manage.py startapp api 纯净版django项目（对settings.py文件操作） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 INSTALLED_APPS = [ # \u0026#39;django.contrib.admin\u0026#39;, # \u0026#39;django.contrib.auth\u0026#39;, # \u0026#39;django.contrib.contenttypes\u0026#39;, # \u0026#39;django.contrib.sessions\u0026#39;, # \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, ] MIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, # \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, # \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, # \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, # \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, ] TEMPLATES = [ { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.template.backends.django.DjangoTemplates\u0026#39;, \u0026#39;DIRS\u0026#39;: [], \u0026#39;APP_DIRS\u0026#39;: True, \u0026#39;OPTIONS\u0026#39;: { \u0026#39;context_processors\u0026#39;: [ \u0026#39;django.template.context_processors.debug\u0026#39;, \u0026#39;django.template.context_processors.request\u0026#39;, # \u0026#39;django.contrib.auth.context_processors.auth\u0026#39;, # \u0026#39;django.contrib.messages.context_processors.messages\u0026#39;, ], }, }, ] 配置项目启动按钮 测试简单实例 1 2 3 4 5 6 7 # api/views.py from django.shortcuts import render, HttpResponse def home(request): return HttpResponse(\u0026#34;成功\u0026#34;) 1 2 3 4 5 6 7 8 9 10 # day13/urls.py # from django.contrib import admin from django.urls import path from api import views urlpatterns = [ # path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;home/\u0026#39;, views.home), ] 2.2 配置drf 安装drf框架 1 pip install djangorestframework==3.13.1 settings.py配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 INSTALLED_APPS = [ # \u0026#39;django.contrib.admin\u0026#39;, # \u0026#39;django.contrib.auth\u0026#39;, # \u0026#39;django.contrib.contenttypes\u0026#39;, # \u0026#39;django.contrib.sessions\u0026#39;, # \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;api.apps.ApiConfig\u0026#39;, \u0026#39;rest_framework\u0026#39;, ] MIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, # \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, # \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, # \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, ] TEMPLATES = [ { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.template.backends.django.DjangoTemplates\u0026#39;, \u0026#39;DIRS\u0026#39;: [], \u0026#39;APP_DIRS\u0026#39;: True, \u0026#39;OPTIONS\u0026#39;: { \u0026#39;context_processors\u0026#39;: [ \u0026#39;django.template.context_processors.debug\u0026#39;, \u0026#39;django.template.context_processors.request\u0026#39;, # \u0026#39;django.contrib.auth.context_processors.auth\u0026#39;, # \u0026#39;django.contrib.messages.context_processors.messages\u0026#39;, ], }, }, ] ################## drf匿名用户 ################## # 在request中源码可以找到 REST_FRAMEWORK = { \u0026#34;UNAUTHENTICATED_USER\u0026#34;: None } 简单实例 1 2 3 4 5 6 7 8 9 # from django.contrib import admin from django.urls import path from api import views urlpatterns = [ # path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;home/\u0026#39;, views.home), path(\u0026#39;user/\u0026#39;, views.UserView.as_view()), ] 1 2 3 4 5 6 7 8 9 10 11 12 from django.shortcuts import render, HttpResponse from rest_framework.views import APIView from rest_framework.response import Response def home(request): return HttpResponse(\u0026#34;成功\u0026#34;) class UserView(APIView): def get(self, request): return Response(\u0026#34;返回成功\u0026#34;) 3. request 3.1 oop知识 getattr：\n__getattr__：\n只有在属性查找失败时才会被调用（即在对象的 __dict__ 和类的 __dict__ 中都找不到属性时）。 它是一个“后备”方法，通常用于动态地提供属性或方法。 __getattribute__：\n是一个更底层的方法，会在每次属性访问时被调用，无论属性是否存在。 它的优先级高于 __getattr__，并且可以完全控制属性的访问行为。 直接访问或利用反射 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Foo(object): def __init__(self, name, age): self.name = name self.age = age def show(self): return 123 obj = Foo(\u0026#34;小三\u0026#34;, 19) # obj.name # obj.age # obj.show() # v1=obj.show v1 = getattr(obj, \u0026#39;show\u0026#39;) # \u0026lt;bound method Foo.show of \u0026lt;__main__.Foo object at 0x000001D9870DBFD0\u0026gt;\u0026gt; print(v1()) __getattr__ 当对象.一个不存在的成员时触发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Foo(object): def __init__(self, name, age): self.name = name self.age = age def show(self): return 123 def __getattr__(self, item): print(\u0026#34;-----\u0026gt;\u0026#34;, item) return 999 obj = Foo(\u0026#34;小三\u0026#34;, 19) # 不触发 __getattr # obj.name # obj.age # obj.show() # 触发 __getattr__ (不存在的成员) # print(obj.xxx) v2 = getattr(obj, \u0026#34;xxxx\u0026#34;) print(v2) # -----\u0026gt; xxxx # 999 getattribute 只要执行 对象.xxx都会执行__getattribute__ 父类object中的__getattribute__的处理机制 对象中有值，返回 对象中无值，报错 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Foo(object): def __init__(self, name, age): self.name = name self.age = age def show(self): return 123 def __getattribute__(self, item): print(\u0026#34;-----\u0026gt;\u0026#34;, item) return 999 obj = Foo(\u0026#34;小三\u0026#34;, 19) print(obj.name) print(obj.age) print(obj.xxx) # -----\u0026gt; name # 999 # -----\u0026gt; age # 999 # -----\u0026gt; xxx # 999 类分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class HttpRequest(object): def __init__(self): pass def v1(self): print(\u0026#34;v1\u0026#34;) def v2(self): print(\u0026#34;v2\u0026#34;) class Request(object): def __init__(self, req, xx): self._request = req self.xx = xx req = HttpRequest() req.v1() req.v2() request = Request(req, 111) request._request.v1() request._request.v2() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class HttpRequest(object): def __init__(self): pass def v1(self): print(\u0026#34;v1\u0026#34;) def v2(self): print(\u0026#34;v2\u0026#34;) class Request(object): def __init__(self, req, xx): self._request = req self.xx = xx # 对象中无的成员，会触发 def __getattr__(self, attr): # attr=\u0026#34;v1\u0026#34; try: return getattr(self._request, attr) except AttributeError: return self.__getattribute__(attr) req = HttpRequest() request = Request(req, 111) # request._request.v1() request.v1() # request.v1=request._request.v1 request的简单实现原理（属性代理） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class HttpRequest(object): def __init__(self): pass def method(self): print(\u0026#34;v1\u0026#34;) def path_info(self): print(\u0026#34;v2\u0026#34;) class DrfRequest(object): def __init__(self, req, xx): self._request = req self.xx = xx def __getattr__(self, attr): try: return getattr(self._request, attr) except AttributeError: return self.__getattribute__(attr) request = HttpRequest() request = DrfRequest(request, 123123) # 普通写法 request._request.method # 利用__getattr__和__getattribute__ request.method request.path_info # 报错 request.uuuu 3.2 参数 普通匹配：\u0026lt;数据类型:参数名\u0026gt;，视图直接用参数接收，或者self.kwargs中获取\n不指定参数名正则匹配（导入re_path）：(正则表达式)，视图直接用参数接收，或者self.args中获取\n指定参数名正则匹配：(?P\u0026lt;参数名\u0026gt;正则表达式)，视图直接用参数接收，或者self.kwargs中获取\n命名捕获组（Named Capture Group）：(?P\u0026lt;参数名\u0026gt;正则表达式)\n测试代码 1 2 3 4 5 6 7 8 9 10 from django.contrib import admin from django.urls import path, re_path from api import views urlpatterns = [ # path(\u0026#39;admin/\u0026#39;, admin.site.urls), # path(\u0026#39;users/\u0026lt;str:version\u0026gt;/\u0026lt;int:pid\u0026gt;/\u0026#39;, views.UserView.as_view()), # re_path(\u0026#39;users/(\\w+)/(\\d+)/\u0026#39;, views.UserView.as_view()), re_path(\u0026#39;users/(?P\u0026lt;version\u0026gt;\\w+)/(?P\u0026lt;pid\u0026gt;\\d+)/\u0026#39;, views.UserView.as_view()), ] 1 2 3 4 5 6 7 8 9 10 from rest_framework.views import APIView from rest_framework.response import Response class UserView(APIView): def get(self, request, version, pid): print(version, pid) print(self.kwargs) print(self.args) return Response(\u0026#34;...\u0026#34;) 3.3 源码分析 流程梳理-文字版 1 2 3 4 5 6 7 8 9 10 注意：下列调用方法的找寻路线遵循先UserView类，后APIView类，最后是View类，就不再详细赘述找寻过程 首先入口是路由中调用UserView类的as_View()方法，找到APIView类的as_view()方法，又调用View类的as_view()方法 View类的as_view()方法调用APIView类的dispatch方法 dispatch()方法调用initialize_request()方法，将django的request传给drf的Request类，Request 的构造函数接收上述参数，并将它们存储在实例中，并且定义了__getattr__方法，用于在drf的request中无缝访问原生django的request 此时initialize_request()方法调用完毕，回到dispatch()方法 dispatch()通过getattr反射获取请求方法，并调用，将结果一步步返回 源代码分析-精简版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class APIView(View): def as_view(cls, **initkwargs): view = super().as_view(**initkwargs) return csrf_exempt(view) def initialize_request(self, request, *args, **kwargs): parser_context = self.get_parser_context(request) return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) def dispatch(self, request, *args, **kwargs): self.args = args self.kwargs = kwargs # request还是django中的request request = self.initialize_request(request, *args, **kwargs) # 此时的request时drf的request，request._request就是原生django的request # request._request.method # request.method # __getattr__ self.request = request self.headers = self.default_response_headers if request.method.lower() in self.http_method_names: # 获取get/post/put等方法 handler = getattr(self, request.method.lower(),self.http_method_not_allowed) # 调用get/post等方法(UserView中) response = handler(request, *args, **kwargs) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response class View: def as_view(cls, **initkwargs): def view(request, *args, **kwargs): return self.dispatch(request, *args, **kwargs) return view class Request: def __init__(self, request, parsers=None, authenticators=None, negotiator=None, parser_context=None): self._request = request def __getattr__(self, attr): try: return getattr(self._request, attr) except AttributeError: return self.__getattribute__(attr) class UserView(APIView): def get(self, request, version, pid): print(version, pid) print(self.kwargs) print(self.args) return Response(\u0026#34;...\u0026#34;) 3.4 request对象 Django 原生 HttpRequest\ndjango.core.handlers.wsgi.WSGIRequest 包含了请求的所有数据 request.method：请求方法（GET、POST 等） request.GET 和 request.POST：查询参数和表单数据 request.body：请求体的原始数据 DRF 的 Request 对象\nrest_framework.request.Request 提供了更灵活的方式来处理请求数据 self._request：存储 Django 的原生 HttpRequest 对象 request.query_params：用于获取 URL 查询参数（GET 请求的参数） request.data：用于获取请求体中的数据，支持多种格式（如 JSON、表单数据等） request.method：获取请求方法（如 GET、POST、PUT 等），与 Django 的 request.method 功能相同 request.user 和 request.auth：当前请求的用户对象，经过认证后的用户信息和认证相关的额外信息，例如 Token request.parsers：当前请求使用的解析器列表，用于解析请求体数据 request.authenticators：当前请求使用的认证器列表 request.is_ajax()：判断请求是否为 AJAX 请求 request.accepted_renderer：获取当前请求的渲染器，用于决定响应数据的格式 request.accepted_media_type：获取客户端请求的 Accept 头部信息，用于内容协商 request.stream：获取请求体的原始流数据 drf中的request其实是对请求的再次封装，其目的就是在原来的request对象基础中再进行封装一些drf中需要用到的值\n测试代码 1 2 3 4 5 6 7 8 9 10 from django.contrib import admin from django.urls import path, re_path from api import views urlpatterns = [ # path(\u0026#39;admin/\u0026#39;, admin.site.urls), # path(\u0026#39;users/\u0026lt;str:version\u0026gt;/\u0026lt;int:pid\u0026gt;/\u0026#39;, views.UserView.as_view()), # re_path(\u0026#39;users/(\\w+)/(\\d+)/\u0026#39;, views.UserView.as_view()), re_path(\u0026#39;users/(?P\u0026lt;version\u0026gt;\\w+)/(?P\u0026lt;pid\u0026gt;\\d+)/\u0026#39;, views.UserView.as_view()), ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from rest_framework.views import APIView from rest_framework.response import Response from rest_framework.request import Request class UserView(APIView): def get(self, request, version, pid): # drf的request对象 print(request.query_params) print(request.data) print(request.auth) print(request.user) # django的request对象 print(request.GET) print(request.method) print(request.path_info) return Response(\u0026#34;...\u0026#34;) 5. 认证 在开发API过程中，有些功能需要登录才能访问，有些无需登录。drf中的认证组件主要就是用来实现此功能\n5.1 快速使用 通过编写类的形式实现，一个类就是一个认证组件\n编写类 -\u0026gt; 认证组件 应用组件 案例1 项目要开发3个接口，其中1个无需登录接口、2个必须登录才能访问的接口。\n局部配置 authentication_classes = []\n无需登录的不配置认证类，默认是匿名用户，需要登陆的配置认证类，通过返回元组赋值request.user 和 request.auth，未通过抛出异常。若返回None则是匿名用户，不符合需求\n认证失败信息定制 匿名用户 认证组件中返回的两个值，分别赋值给：request.user 和 request.auth urls.py 1 2 3 4 5 6 7 8 9 from django.urls import path from api import views urlpatterns = [ path(\u0026#39;login/\u0026#39;, views.LoginView.as_view()), path(\u0026#39;user/\u0026#39;, views.UserView.as_view()), path(\u0026#39;order/\u0026#39;, views.OrderView.as_view()), ] views.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from rest_framework.views import APIView from rest_framework.response import Response from rest_framework.request import Request from rest_framework.authentication import BaseAuthentication from rest_framework.exceptions import AuthenticationFailed class MyAuthentication(BaseAuthentication): def authenticate(self, request): # /xxx/xxx/xxx?token=123123123 # token = request._request.GET.get(\u0026#39;token\u0026#39;) token = request.query_params.get(\u0026#39;token\u0026#39;) if token: return \u0026#34;user\u0026#34;, token # raise AuthenticationFailed(\u0026#34;认证失败\u0026#34;) raise AuthenticationFailed({\u0026#34;code\u0026#34;: 20000, \u0026#34;error\u0026#34;: \u0026#34;认证失败\u0026#34;}) class LoginView(APIView): authentication_classes = [] def get(self, request): print(request.user, request.auth) return Response(\u0026#34;LoginView\u0026#34;) class UserView(APIView): authentication_classes = [MyAuthentication, ] def get(self, request): print(request.user, request.auth) return Response(\u0026#34;UserView\u0026#34;) class OrderView(APIView): authentication_classes = [MyAuthentication, ] def get(self, request): print(request.user, request.auth) return Response(\u0026#34;OrderView\u0026#34;) 案例2 项目要开发100个接口，其中1个无需登录接口、99个必须登录才能访问的接口。\n此时，就需要用到drf的全局配置（认证组件的类不能放在视图view.py中，会因为导入APIView导致循环引用，该案例放置在ext/auth.py中）\ndrf会先加载全局配置，在加载局部配置，局部配置会覆盖全局配置\next\\auth.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from rest_framework.authentication import BaseAuthentication from rest_framework.exceptions import AuthenticationFailed class MyAuthentication(BaseAuthentication): def authenticate(self, request): # /xxx/xxx/xxx?token=123123123 # token = request._request.GET.get(\u0026#39;token\u0026#39;) token = request.query_params.get(\u0026#39;token\u0026#39;) if token: return \u0026#34;user\u0026#34;, token # raise AuthenticationFailed(\u0026#34;认证失败\u0026#34;) raise AuthenticationFailed({\u0026#34;code\u0026#34;: 20000, \u0026#34;error\u0026#34;: \u0026#34;认证失败\u0026#34;}) urls.py 1 2 3 4 5 6 7 8 9 from django.urls import path from api import views urlpatterns = [ path(\u0026#39;login/\u0026#39;, views.LoginView.as_view()), path(\u0026#39;user/\u0026#39;, views.UserView.as_view()), path(\u0026#39;order/\u0026#39;, views.OrderView.as_view()), ] views.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from rest_framework.views import APIView from rest_framework.response import Response from ext.auth import MyAuthentication class LoginView(APIView): authentication_classes = [] def get(self, request): print(request.user, request.auth) return Response(\u0026#34;LoginView\u0026#34;) class UserView(APIView): def get(self, request): print(request.user, request.auth) return Response(\u0026#34;UserView\u0026#34;) class OrderView(APIView): def get(self, request): print(request.user, request.auth) return Response(\u0026#34;OrderView\u0026#34;) 案例3 状态码一致性问题： 如果认证组件中未定义，则统一为 HTTP_403_FORBIDDEN\n如果自定义了，还会加上一个响应头\n定义get_authenticate_header方法\n参考源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def handle_exception(self, exc): if isinstance(exc, (exceptions.NotAuthenticated,exceptions.AuthenticationFailed)): auth_header = self.get_authenticate_header(self.request) if auth_header: exc.auth_header = auth_header else: exc.status_code = status.HTTP_403_FORBIDDEN return response def get_authenticate_header(self, request): authenticators = self.get_authenticators() if authenticators: return authenticators[0].authenticate_header(request) 案例4 项目要开发100个接口，其中1个无需登录接口、98个必须登录才能访问的接口、1个公共接口（未登录时显示公共/已登录时显示个人信息）。\n原来的认证信息只能放在URL中传递，如果程序中支持放在很多地方，例如：URL中、请求头中等。\n认证组件中，如果是使用了多个认证类，会按照顺序逐一执行其中的authenticate方法\n返回None或无返回值，表示继续执行后续的认证类 返回 (user, auth) 元组，则不再继续并将值赋值给request.user和request.auth 抛出异常 AuthenticationFailed(...)，认证失败，不再继续向后走。 多个认证组件每一个都返回None，都没有认证成功，视图函数也会被执行，只不过self.user，self.auth为None\next\\auth.py 设置一个检查参数的认证类，一个检查请求头的认证类，通过一个即为认证成功，然后设置一个认证类直接抛出异常\n对于无需登陆的，局部设置无认证类\n对于需要登陆的，则将所有认证类加上，若类1与类2未通过，走到类3会直接抛出异常即认证不通过\n对于公共接口，局部设置前两个认证类，若未通过则以匿名用户访问\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from rest_framework.authentication import BaseAuthentication from rest_framework.exceptions import AuthenticationFailed class ParamAuthentication(BaseAuthentication): def authenticate(self, request): token = request.query_params.get(\u0026#39;token\u0026#39;) if not token: return return \u0026#34;user\u0026#34;, token def authenticate_header(self, request): return \u0026#39;Token\u0026#39; class HeaderAuthentication(BaseAuthentication): def authenticate(self, request): token = request.META.get(\u0026#39;HTTP_AUTHORIZATION\u0026#39;) if not token: return return \u0026#34;user\u0026#34;, token def authenticate_header(self, request): return \u0026#39;Token\u0026#39; class NotAuthentication(BaseAuthentication): def authenticate(self, request): raise AuthenticationFailed({\u0026#34;code\u0026#34;: 20000, \u0026#34;error\u0026#34;: \u0026#34;认证失败\u0026#34;}) def authenticate_header(self, request): return \u0026#39;Token\u0026#39; views.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from rest_framework.views import APIView from rest_framework.response import Response from ext.auth import ParamAuthentication, HeaderAuthentication # 无需登录 class UserView(APIView): authentication_classes = [] def get(self, request): return Response(\u0026#34;用户信息\u0026#34;) # 公共接口 class OrderView(APIView): authentication_classes = [ParamAuthentication, HeaderAuthentication, ] def get(self, request): if request.user: message = f\u0026#34;{request.user}的订单信息\u0026#34; else: message = \u0026#34;公共订单信息\u0026#34; return Response(message) # 必须登录 class InfoView(APIView): def get(self, request): message = f\u0026#34;{request.user}的用户信息\u0026#34; return Response(message) settings.py 1 2 3 4 5 6 7 8 9 REST_FRAMEWORK = { \u0026#34;UNAUTHENTICATED_USER\u0026#34;: None, # 未登录时，request.user=None \u0026#34;UNAUTHENTICATED_TOKEN\u0026#34;: None, # 未登录时，request.auth=None \u0026#34;DEFAULT_AUTHENTICATION_CLASSES\u0026#34;: [ \u0026#34;ext.auth.ParamAuthentication\u0026#34;, \u0026#34;ext.auth.HeaderAuthentication\u0026#34;, \u0026#34;ext.auth.NotAuthentication\u0026#34;, ] } 5.2 面向对象-继承 局部配置与全局配置的优先关系\n1 2 3 4 5 6 7 8 9 10 11 12 13 class APIView(View): authentication_classes = 读取配置文件中的列表 def dispatch(self): self.authentication_classes class UserView(APIView): authentication_classes = [11,22,33,44] obj = UserView() obj.dispatch() # authentication_classes = [11,22,33,44] 5.3 组件源码 1 2 3 4 5 在request的初始化阶段加载认证组件，即调用initialize_request方法时，通过get_authenticators方法获取认证类实例对象列表authenticators get_authenticators方法循环authentication_classes，实例化生成认证类实例对象存储在列表中 authentication_classes读取的局部配置和全局配置 加载完成后，认证过程，即调用initial方法时，调用perform_authentication方法，获取request.user的值 user为空值即未认证，触发_authenticate方法，循环认证类实例对象列表authenticators，调用自己的认证方法，返回元组就赋值user和auth，退出循环；返回None继续循环；抛出异常就捕获异常，在dispatch中捕获；如果循环完没返回元组也没异常，执行_not_authenticated方法处理匿名用户 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 class Request: def __init__(self, request, authenticators=None): self._request = request self.authenticators = authenticators or () @property def user(self): if not hasattr(self, \u0026#39;_user\u0026#39;): with wrap_attributeerrors(): self._authenticate() return self._user @user.setter def user(self, value): self._user = value self._request.user = value def _authenticate(self): # authenticator是认证类实例化后的对象，循环逐一认证 # 如果认证过程抛出异常，认证不通过 # 若认证过程没有抛出异常，也没有返回self.user, self.auth，则匿名执行视图函数 for authenticator in self.authenticators: try: user_auth_tuple = authenticator.authenticate(self) # 调用认证类的authenticate方法，返回元组 except exceptions.APIException: self._not_authenticated() raise if user_auth_tuple is not None: self._authenticator = authenticator self.user, self.auth = user_auth_tuple return self._not_authenticated() def _not_authenticated(self): self._authenticator = None if api_settings.UNAUTHENTICATED_USER: self.user = api_settings.UNAUTHENTICATED_USER() else: self.user = None if api_settings.UNAUTHENTICATED_TOKEN: self.auth = api_settings.UNAUTHENTICATED_TOKEN() else: self.auth = None class APIView(View): authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES def as_view(cls, **initkwargs): view = super().as_view(**initkwargs) return csrf_exempt(view) def dispatch(self, request, *args, **kwargs): # 第一步：请求的封装(django的 request + drf的 authenticators认证组件) --\u0026gt; 加载认证组件过程 # request.authenticators [对象1，对象2，...] request = self.initialize_request(request, *args, **kwargs) self.request = request # 第二步：认证过程 try: self.initial(request, *args, **kwargs) handler = getattr(self, request.method.lower(), self.http_method_not_allowed) # 第三步：执行视图函数 response = handler(request, *args, **kwargs) except Exception as exc: # 认证时抛出错误在这里被捕获 response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response def initialize_request(self, request, *args, **kwargs): return Request( request, authenticators=self.get_authenticators(), # [对象1，对象2，...] ) def initial(self, request, *args, **kwargs): self.perform_authentication(request) self.check_permissions(request) self.check_throttles(request) def perform_authentication(self, request): request.user def get_authenticators(self): # 返回一个列表每一个元素都是认证类对象 [对象1，对象2，...] return [auth() for auth in self.authentication_classes] # 优先读取局部配置，后全局配置 def handle_exception(self, exc): if isinstance(exc, (exceptions.NotAuthenticated,exceptions.AuthenticationFailed)): auth_header = self.get_authenticate_header(self.request) if auth_header: exc.auth_header = auth_header else: exc.status_code = status.HTTP_403_FORBIDDEN return response def get_authenticate_header(self, request): authenticators = self.get_authenticators() if authenticators: return authenticators[0].authenticate_header(request) class View: def as_view(cls, **initkwargs): def view(request, *args, **kwargs): return self.dispatch(request, *args, **kwargs) return view class UserView(APIView): def get(self, request): print(request.user, request.auth) return Response(\u0026#34;UserView\u0026#34;) 5.4 拓展-子类约束 1 2 3 4 5 6 7 8 9 class Foo(object): # 对子类进行约束，约束子类中必须要定义该方法，不然就报错 def f1(self): raise NotImplementedError(\u0026#34;...\u0026#34;) class Bar(Foo): def f1(self): print(\u0026#34;123\u0026#34;) BaseAuthentication类定义 1 2 3 4 5 6 7 8 9 10 class BaseAuthentication: \u0026#34;\u0026#34;\u0026#34; All authentication classes should extend BaseAuthentication. \u0026#34;\u0026#34;\u0026#34; def authenticate(self, request): \u0026#34;\u0026#34;\u0026#34; Authenticate the request and return a two-tuple of (user, token). \u0026#34;\u0026#34;\u0026#34; raise NotImplementedError(\u0026#34;.authenticate() must be overridden.\u0026#34;) 5.5 案例-用户登录和认证 5.5.1 创建数据表 不配置其他数据库，采用默认的sqlite做简单测试\n注册app --\u0026gt; settings.py 1 2 3 4 5 6 7 8 9 10 INSTALLED_APPS = [ # \u0026#39;django.contrib.admin\u0026#39;, # \u0026#39;django.contrib.auth\u0026#39;, # \u0026#39;django.contrib.contenttypes\u0026#39;, # \u0026#39;django.contrib.sessions\u0026#39;, # \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;rest_framework\u0026#39;, \u0026#39;api.apps.ApiConfig\u0026#39;, ] api/models.py 1 2 3 4 5 6 7 8 9 10 from django.db import models # Create your models here. class UserInfo(models.Model): \u0026#34;\u0026#34;\u0026#34;用户表\u0026#34;\u0026#34;\u0026#34; username = models.CharField(verbose_name=\u0026#34;用户名\u0026#34;, max_length=32) password = models.CharField(verbose_name=\u0026#34;用户名\u0026#34;, max_length=64) # 临时形式、后续可以使用jwt等 token = models.CharField(verbose_name=\u0026#34;TOKEN\u0026#34;, max_length=64, null=True, blank=True) 创建数据库 手动添加数据做测试 5.5.2 路由系统 1 2 3 4 5 6 7 8 9 from django.urls import path from api import views urlpatterns = [ path(\u0026#39;login/\u0026#39;, views.LoginView.as_view()), path(\u0026#39;user/\u0026#39;, views.UserView.as_view()), path(\u0026#39;order/\u0026#39;, views.OrderView.as_view()), ] 5.5.3 认证组件 实际开发过程中应定制响应状态码，该案例使用简单的True和False标识状态\nsettings.py全局配置 1 2 3 4 5 6 7 8 9 REST_FRAMEWORK = { \u0026#34;UNAUTHENTICATED_USER\u0026#34;: None, # 未登录时，request.user=None \u0026#34;UNAUTHENTICATED_TOKEN\u0026#34;: None, # 未登录时，request.auth=None \u0026#34;DEFAULT_AUTHENTICATION_CLASSES\u0026#34;: [ \u0026#34;ext.auth.QueryParamsAuthentication\u0026#34;, \u0026#34;ext.auth.HeaderAuthentication\u0026#34;, \u0026#34;ext.auth.NoAuthentication\u0026#34;, ] } ext/auth.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from rest_framework.authentication import BaseAuthentication from rest_framework.exceptions import AuthenticationFailed from api import models class QueryParamsAuthentication(BaseAuthentication): def authenticate(self, request): # 获取请求参数值 token = request.query_params.get(\u0026#39;token\u0026#39;) if not token: return user_object = models.UserInfo.objects.filter(token=token).first() if user_object: return user_object, token # request.user = 用户对象，request.auth = token return def authenticate_header(self, request): return \u0026#39;Token\u0026#39; class HeaderAuthentication(BaseAuthentication): def authenticate(self, request): # 获取请求头 token = request.META.get(\u0026#39;HTTP_AUTHORIZATION\u0026#39;) if not token: return user_object = models.UserInfo.objects.filter(token=token).first() if user_object: return user_object, token # request.user = 用户对象，request.auth = token return def authenticate_header(self, request): return \u0026#39;Token\u0026#39; class NoAuthentication(BaseAuthentication): def authenticate(self, request): raise AuthenticationFailed({\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;认证失败\u0026#34;}) def authenticate_header(self, request): return \u0026#39;Token\u0026#39; 5.5.4 视图函数 postman发送post请求测试接口示例 登录生成token接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import uuid from rest_framework.views import APIView from rest_framework.response import Response from rest_framework.request import Request from api import models class LoginView(APIView): authentication_classes = [] # 局部配置，该函数无需登录 def post(self, request): # 1.接收用户post提交的用户名密码 # request.data直接是一个字典类型 user = request.data.get(\u0026#39;username\u0026#39;) pwd = request.data.get(\u0026#39;password\u0026#39;) # 2.数据库校验 user_object = models.UserInfo.objects.filter(username=user, password=pwd).first() if not user_object: return Response({\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;用户名或密码错误\u0026#34;}) # 3.登陆成功 token = str(uuid.uuid4()) user_object.token = token user_object.save() return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: token}) 需要认证的视图函数 1 2 3 class UserView(APIView): def get(self, request): return Response(\u0026#34;UserView\u0026#34;) 5.5.5 访问效果 在请求头中携带和在请求参数中携带均可，有对应的认证组件校验\n5.6 总结 编写组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # ext/auth.py from rest_framework.authentication import BaseAuthentication from rest_framework.exceptions import AuthenticationFailed class MyAuthentication(BaseAuthentication): def authenticate(self, request): # 去做用户认证 # 1.读取请求传递的token token = request.query_params.get(\u0026#39;token\u0026#39;) # 2.校验合法性 # 3.返回值 # 3.1 返回元组 (111,222) 认证成功 request.user request.auth # 3.2 抛出异常 认证失败 -\u0026gt; 返回错误信息 # 3.1 返回None 多个认证类 [类1，类2，类3，类4，，，] -\u0026gt; 匿名用户 if not token: return return \u0026#34;user\u0026#34;, token def authenticate_header(self, request): return \u0026#39;Token\u0026#39; class NotAuthentication(BaseAuthentication): def authenticate(self, request): raise AuthenticationFailed({\u0026#34;code\u0026#34;: 20000, \u0026#34;error\u0026#34;: \u0026#34;认证失败\u0026#34;}) def authenticate_header(self, request): return \u0026#39;Token\u0026#39; 全局配置匿名用户和认证类\n1 2 3 4 5 6 7 8 9 10 # settings.py REST_FRAMEWORK = { \u0026#34;UNAUTHENTICATED_USER\u0026#34;: None, # 未登录时，request.user=None \u0026#34;UNAUTHENTICATED_TOKEN\u0026#34;: None, # 未登录时，request.auth=None \u0026#34;DEFAULT_AUTHENTICATION_CLASSES\u0026#34;: [ \u0026#34;ext.auth.ParamAuthentication\u0026#34;, \u0026#34;ext.auth.HeaderAuthentication\u0026#34;, \u0026#34;ext.auth.NotAuthentication\u0026#34;, ] } 局部配置认证类\n1 2 3 4 5 # views.py class OrderView(APIView): authentication_classes = [... ] def get(self, request): 解决多认证参数传递（请求参数和请求头等等）和 必须认证，公共接口（可认证可匿名），无需认证三种类型接口 \u0026ndash;\u0026gt; 见案例4\n6. 权限 认证组件 = [认证类，认证类，认证类，]\t-\u0026gt;\t执行每一个认证类的authenticate方法\n认证成功或失败，不会再执行后续的认证类\n返回None，执行后续认证类\n权限组件 = [权限类，权限类，权限类，] -\u0026gt; 执行所有权限类的has_permission方法，返回True通过，返回False不通过\n执行所有的权限类 默认情况下，要保证所有的权限类中的has_permission方法都返回True，即与的关系\n掌握源码流程后，可以扩展+自定义，实现其他逻辑\n6.1 快速使用 编写类 1 2 3 4 5 6 7 8 9 10 class BasePermission(metaclass=BasePermissionMetaclass): \u0026#34;\u0026#34;\u0026#34; A base class from which all permission classes should inherit. \u0026#34;\u0026#34;\u0026#34; def has_permission(self, request, view): \u0026#34;\u0026#34;\u0026#34; Return `True` if permission is granted, `False` otherwise. \u0026#34;\u0026#34;\u0026#34; return True 阅读源码可知，自定义的权限类的has_permission应返回True或False来表示是否有权限\n1 2 3 4 5 6 7 8 9 10 11 12 # ext/per.py from rest_framework.permissions import BasePermission import random class MyPermission(BasePermission): def has_permission(self, request, view): # 获取请求中的数据，然后进行校验... v1 = random.randint(1, 3) if v1 == 2: return True return False 应用类 全局应用\t在settings.py中配置\n局部应用\t在视图函数中定义permission_classes = []参数\n根据业务需求灵活配置\n1 2 3 4 5 6 7 8 9 10 11 12 REST_FRAMEWORK = { \u0026#34;UNAUTHENTICATED_USER\u0026#34;: None, # 未登录时，request.user=None \u0026#34;UNAUTHENTICATED_TOKEN\u0026#34;: None, # 未登录时，request.auth=None \u0026#34;DEFAULT_AUTHENTICATION_CLASSES\u0026#34;: [ \u0026#34;ext.auth.ParamAuthentication\u0026#34;, \u0026#34;ext.auth.HeaderAuthentication\u0026#34;, \u0026#34;ext.auth.NotAuthentication\u0026#34;, ], \u0026#34;DEFAULT_PERMISSION_CLASSES\u0026#34;:[ \u0026#34;ext.per.Mypermission\u0026#34; ] } 6.2 错误信息和多个权限类 在权限类中自定义错误信息message 1 2 3 4 5 6 7 8 9 class MyPermission(BasePermission): message = {\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;无权访问\u0026#34;} def has_permission(self, request, view): # 获取请求中的数据，然后进行校验... v1 = random.randint(1, 3) if v1 == 2: return True return False 左图为默认错误信息，右图为自定义错误信息\n多个权限类 api/per.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from rest_framework.permissions import BasePermission class MyPermission1(BasePermission): message = {\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;无权访问\u0026#34;} def has_permission(self, request, view): print(\u0026#34;MyPermission1\u0026#34;) return False class MyPermission2(BasePermission): message = {\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;无权访问\u0026#34;} def has_permission(self, request, view): print(\u0026#34;MyPermission2\u0026#34;) return False class MyPermission3(BasePermission): message = {\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;无权访问\u0026#34;} def has_permission(self, request, view): print(\u0026#34;MyPermission3\u0026#34;) return False api/views.py\n1 2 3 4 5 6 7 8 9 10 11 12 from rest_framework.views import APIView from rest_framework.response import Response from ext.per import MyPermission1, MyPermission2, MyPermission3 class OrderView(APIView): authentication_classes = [] permission_classes = [MyPermission1, MyPermission2, MyPermission3] def get(self, request): print(request.user, request.auth) return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: [11, 22, 33, 44]}) 终端只打印了MyPermission1\n说明程序会按顺序校验每个权限类，一旦有一个返回False即校验不通过，则不再校验后续权限类，只有通过每一个权限类的校验才算有权限访问\n6.3 源码流程 as_view()等方法的调用在认证组件中已详细阐明，此处直接从dispatch()方法开始\n初始化的initialize_request无涉及，直接来到initial方法，调用check_permissions方法\ncheck_permissions方法循环权限类实例对象列表permission_classes，调用has_permission方法，一旦返回False，就调用permission_denied方法，并传入错误信息message和code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class APIView(View): permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES # 权限组件的全局配置 def permission_denied(self, request, message=None, code=None): if request.authenticators and not request.successful_authenticator: raise exceptions.NotAuthenticated() raise exceptions.PermissionDenied(detail=message, code=code) def get_permissions(self): # 获取权限类对象的列表 return [permission() for permission in self.permission_classes] def check_permissions(self, request): # 循环每一个权限类对象，判断权限校验是否通过 for permission in self.get_permissions(): # 如果未通过，则抛出异常在dispatch中捕获 if not permission.has_permission(request, self): self.permission_denied( request, message=getattr(permission, \u0026#39;message\u0026#39;, None), code=getattr(permission, \u0026#39;code\u0026#39;, None) ) def initial(self, request, *args, **kwargs): self.perform_authentication(request) # 认证组件的过程，循环执行每个authenticate方法；失败则抛出异常不向下执行 self.check_permissions(request) # 权限的校验 self.check_throttles(request) def dispatch(self, request, *args, **kwargs): # 封装drf的request request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: self.initial(request, *args, **kwargs) # 反射获取get/post等方法 handler = getattr(self, request.method.lower(), self.http_method_not_allowed) # 执行相应方法 response = handler(request, *args, **kwargs) # 异常处理 except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response class OrderView(APIView): permission_classes = [MyPermission1, MyPermission2, MyPermission3] # 权限组件的局部配置 def get(self, request): print(request.user, request.auth) return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: [11, 22, 33, 44]}) 6.4 组件的拓展 通过源码可以知道，在check_permissions中，只要有一个权限类校验不通过就是无权访问，那么如何才能实现拓展，使其满足只要有一个权限类通过就是有权限呢？显而易见需要重写check_permissions方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class OrderView(APIView): authentication_classes = [] permission_classes = [MyPermission1, MyPermission2, MyPermission3] def get(self, request): print(request.user, request.auth) return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: [11, 22, 33, 44]}) def check_permissions(self, request): no_permission_objects_list = [] for permission in self.get_permissions(): if permission.has_permission(request, self): return else: no_permission_objects_list.append(permission) else: self.permission_denied( request, message=getattr(no_permission_objects_list[0], \u0026#39;message\u0026#39;, None), code=getattr(no_permission_objects_list[0], \u0026#39;code\u0026#39;, None) ) 在OrderView视图中重写check_permissions方法，则在权限校验的生命周期中，自定义的check_permissions便覆盖了APIView中的默认check_permissions实现逻辑，达到自定义拓展的效果\n自定义的check_permissions实现了一旦某一权限类校验通过，就不再进行后续校验。若所有类均未通过，则返回第一个未通过的类的错误信息\n由此可见学习源码的重要性，不仅可以学习源码中优秀的代码编写方式，还可以在原有逻辑的基础上进行拓展\n上述是修改一个视图函数的权限校验逻辑，如何应用到其他视图呢？\n可以自定义一个NbApiView的类，继承APIView并且重写check_permissions，之后要实现或逻辑的权限认证的视图只需继承NbApiView即可\next/view.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from rest_framework.views import APIView class NbApiView(APIView): def check_permissions(self, request): no_permission_objects_list = [] for permission in self.get_permissions(): if permission.has_permission(request, self): return else: no_permission_objects_list.append(permission) else: self.permission_denied( request, message=getattr(no_permission_objects_list[0], \u0026#39;message\u0026#39;, None), code=getattr(no_permission_objects_list[0], \u0026#39;code\u0026#39;, None) ) api/views.py 1 2 3 4 5 6 7 8 9 10 11 12 13 from rest_framework.views import APIView from rest_framework.response import Response from ext.per import MyPermission1, MyPermission2, MyPermission3 from ext.view import NbApiView class OrderView(NbApiView): authentication_classes = [] permission_classes = [MyPermission1, MyPermission2, MyPermission3] def get(self, request): print(request.user, request.auth) return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: [11, 22, 33, 44]}) 6.5 案例-权限处理 6.5.1 创建数据表 1 2 3 4 5 6 7 class UserInfo(models.Model): \u0026#34;\u0026#34;\u0026#34;用户表\u0026#34;\u0026#34;\u0026#34; role = models.IntegerField(verbose_name=\u0026#34;角色\u0026#34;, choices=((1, \u0026#34;总监\u0026#34;), (2, \u0026#34;经理\u0026#34;), (3, \u0026#34;员工\u0026#34;)), default=3) username = models.CharField(verbose_name=\u0026#34;用户名\u0026#34;, max_length=32) password = models.CharField(verbose_name=\u0026#34;用户名\u0026#34;, max_length=64) # 临时形式、后续可以使用jwt等 token = models.CharField(verbose_name=\u0026#34;TOKEN\u0026#34;, max_length=64, null=True, blank=True) 1 2 makemigrations migrate 手动添加数据\n6.5.2 路由系统 1 2 3 4 5 6 7 8 9 from django.urls import path from api import views urlpatterns = [ path(\u0026#39;login/\u0026#39;, views.LoginView.as_view()), path(\u0026#39;user/\u0026#39;, views.UserView.as_view()), path(\u0026#39;order/\u0026#39;, views.OrderView.as_view()), path(\u0026#39;avatar/\u0026#39;, views.AvatarView.as_view()) ] 6.5.3 认证组件 根据传入token返回用户对象\next/auth.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from rest_framework.authentication import BaseAuthentication from rest_framework.exceptions import AuthenticationFailed from api import models class QueryParamsAuthentication(BaseAuthentication): def authenticate(self, request): token = request.query_params.get(\u0026#39;token\u0026#39;) if not token: return user_object = models.UserInfo.objects.filter(token=token).first() if user_object: return user_object, token # request.user = 用户对象，request.auth = token return def authenticate_header(self, request): return \u0026#39;Token\u0026#39; class HeaderAuthentication(BaseAuthentication): def authenticate(self, request): token = request.META.get(\u0026#39;HTTP_AUTHORIZATION\u0026#39;) if not token: return user_object = models.UserInfo.objects.filter(token=token).first() if user_object: return user_object, token # request.user = 用户对象，request.auth = token return def authenticate_header(self, request): return \u0026#39;Token\u0026#39; class NoAuthentication(BaseAuthentication): def authenticate(self, request): raise AuthenticationFailed({\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;认证失败\u0026#34;}) def authenticate_header(self, request): return \u0026#39;Token\u0026#39; 6.5.4 权限组件 ext/per.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from rest_framework.permissions import BasePermission class UserPermission(BasePermission): message = {\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;无权访问1\u0026#34;} def has_permission(self, request, view): if request.user.role == 3: return True return False class ManagerPermission(BasePermission): message = {\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;无权访问1\u0026#34;} def has_permission(self, request, view): if request.user.role == 2: return True return False class BossPermission(BasePermission): message = {\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;无权访问1\u0026#34;} def has_permission(self, request, view): if request.user.role == 1: return True return False ext/view.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from rest_framework.views import APIView class NbApiView(APIView): def check_permissions(self, request): no_permission_objects_list = [] for permission in self.get_permissions(): if permission.has_permission(request, self): return else: no_permission_objects_list.append(permission) else: self.permission_denied( request, message=getattr(no_permission_objects_list[0], \u0026#39;message\u0026#39;, None), code=getattr(no_permission_objects_list[0], \u0026#39;code\u0026#39;, None) ) 6.5.5 视图函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import uuid from rest_framework.views import APIView from rest_framework.response import Response from api import models from ext.per import UserPermission, ManagerPermission, BossPermission from ext.view import NbApiView class LoginView(APIView): authentication_classes = [] def post(self, request): # 1.接收用户post提交的用户名密码 # print(request.query_params) # 获取get请求提交的参数 # request.data直接是一个字典类型 user = request.data.get(\u0026#39;username\u0026#39;) pwd = request.data.get(\u0026#39;password\u0026#39;) # 2.数据库校验 user_object = models.UserInfo.objects.filter(username=user, password=pwd).first() if not user_object: return Response({\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;用户名或密码错误\u0026#34;}) # 3.登陆成功 token = str(uuid.uuid4()) user_object.token = token user_object.save() return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: token}) class UserView(NbApiView): # 经理、总检、普通用户都可以访问 permission_classes = [BossPermission, ManagerPermission, UserPermission] def get(self, request): print(request.user, request.auth) return Response(\u0026#34;UserView\u0026#34;) class OrderView(NbApiView): # 经理、总监可以访问 permission_classes = [BossPermission, ManagerPermission, ] def get(self, request): print(request.user, request.auth) return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: [11, 22, 33, 44]}) class AvatarView(NbApiView): # 总监、员工可以访问 permission_classes = [BossPermission, UserPermission, ] def get(self, request): print(request.user, request.auth) return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: [11, 22, 33, 44]}) 6.5.6 访问效果 token2对应经理\ntoken3对应员工\n员工可以访问/avatar,访问不了/order\n经理可以访问/order,访问不了/avatar\n6.6 思考 在开发过程中,发现drf中的request对象不好用,应该如何换成另一个request类对象?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class AvatarView(NbApiView): # 总监、员工可以访问 permission_classes = [BossPermission, UserPermission, ] def get(self, request): print(request.user, request.auth) return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: [11, 22, 33, 44]}) def initialize_request(self, request, *args, **kwargs): # super().initialize_request() parser_context = self.get_parser_context(request) return Request( request, parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context ) # 再自己定义一个Request类即可完成接管,齐活! drf中的认证/权限组件与django中的中间件有什么关系?\n认证/权限组件在中间件之后\n6.7 总结 默认按权限类列表定义的顺序判断每一个权限，返回True继续判断，知道所有权限类均通过；返回False直接退出，无权限\n通过修改check_permissions的逻辑可以实现，返回True直接退出，有权限；返回False继续判断，知道有True，若全为False，无权限\n全局配置\n1 2 3 4 5 6 7 8 9 10 11 12 REST_FRAMEWORK = { \u0026#34;UNAUTHENTICATED_USER\u0026#34;: None, # 未登录时，request.user=None \u0026#34;UNAUTHENTICATED_TOKEN\u0026#34;: None, # 未登录时，request.auth=None \u0026#34;DEFAULT_AUTHENTICATION_CLASSES\u0026#34;: [ \u0026#34;ext.auth.ParamAuthentication\u0026#34;, \u0026#34;ext.auth.HeaderAuthentication\u0026#34;, \u0026#34;ext.auth.NotAuthentication\u0026#34;, ], \u0026#34;DEFAULT_PERMISSION_CLASSES\u0026#34;:[ \u0026#34;ext.per.Mypermission\u0026#34; ] } ext/per.py\n1 2 3 4 5 6 7 8 9 10 11 from rest_framework.permissions import BasePermission class UserPermission(BasePermission): # 子定义错误信息 message = {\u0026#34;status\u0026#34;: False, \u0026#34;msg\u0026#34;: \u0026#34;无权访问1\u0026#34;} # 权限判断，True或False def has_permission(self, request, view): if request.user.role == 3: return True return False ext/view.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from rest_framework.views import APIView class NbApiView(APIView): def check_permissions(self, request): no_permission_objects_list = [] for permission in self.get_permissions(): if permission.has_permission(request, self): return else: no_permission_objects_list.append(permission) else: self.permission_denied( request, message=getattr(no_permission_objects_list[0], \u0026#39;message\u0026#39;, None), code=getattr(no_permission_objects_list[0], \u0026#39;code\u0026#39;, None) ) 视图函数\n1 2 3 4 5 6 7 8 9 10 from ext.per import UserPermission, ManagerPermission, BossPermission from ext.view import NbApiView # 继承自定义试图类，改变权限逻辑 class UserView(NbApiView): # 局部配置 permission_classes = [BossPermission, ManagerPermission, UserPermission] def get(self, request): 7. 限流 7.1 基本逻辑 开发过程中，某个接口不想让用户访问过于频繁，需要限流机制\n例如：平台发送验证码，除了云厂商提供的限制，可能还需要做其他限制，如IP限制、验证码等等\n限制访问频率需要找到唯一标识:\n- 已登录用户，可以使用用户信息主键，ID，用户名 - 未登录用户，可以采用IP作为唯一标识 如何限制？\n维护一个唯一标识：访问记录列表\n\u0026quot;121\u0026quot;：[ 20:35 20:32 20:22 20:12 ] 限制10分钟3次\n获取当前时间 20:36\n当前时间-10分钟=计数开始时间 20：26\n删除小于20：26的记录\n计算长度\n​\t4.1 超过，报错\n​\t4.2 未超过，访问\n7.2 快速使用 编写类 重写了获取唯一标识的get_cache_key方法，优先使用用户id，若没有再采用默认的获取请求ip做唯一标识\n后续可以连接redis将标识做键，访问记录存储为对应的值进行联动\next/throttle.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from rest_framework.throttling import SimpleRateThrottle from django.core.cache import cache as default_cache class MyThrottle(SimpleRateThrottle): scope = \u0026#34;XXX\u0026#34; THROTTLE_RATES = {\u0026#34;XXX\u0026#34;: \u0026#34;5/m\u0026#34;} # 限制频率 cache = default_cache # redis配置 # 获取唯一标识，后续可以连接redis做操作 def get_cache_key(self, request, view): if request.user: ident = request.user.pk # 用户ID else: ident = self.get_ident(request) # 获取请求用户IP（去request中找请求头） # cache_format = \u0026#39;throttle_%(scope)s_%(ident)s\u0026#39; return self.cache_format % {\u0026#39;scope\u0026#39;: self.scope, \u0026#39;ident\u0026#39;: ident} redis配置 1.django-redis配置 -\u0026gt;\tsettings.py 2.安装django-redis\tpip install django-redis 3.启动redis服务\n1 2 3 4 5 6 7 8 9 10 11 # settings.py CACHES = { \u0026#34;default\u0026#34;: { \u0026#34;BACKEND\u0026#34;: \u0026#34;django_redis.cache.RedisCache\u0026#34;, \u0026#34;LOCATION\u0026#34;: \u0026#34;redis://127.0.0.1:6379\u0026#34;, \u0026#34;OPTIONS\u0026#34;: { \u0026#34;CLIENT_CLASS\u0026#34;: \u0026#34;django_redis.client.DefaultClient\u0026#34;, \u0026#34;PASSWORD\u0026#34;: \u0026#34;\u0026#34;, } } } 应用类 1 2 3 4 5 6 from ext.throttle import MyThrottle class LoginView(APIView): authentication_classes = [] throttle_classes = [MyThrottle,] ... 7.3 源码流程 对象加载\n获取每个限流类对象，初始化（读取限流配置，获取时间间隔和访问次数）\nallow_request判断是否限流\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 从dispatch方法的initial方法开始，调用了check_throttles方法 check_throttles方法中： self.get_throttles()，从局部配置或全局配置读取限流类列表throttle_classes，然后逐一实例化，返回一个限流类对象列表 循环上述列表，调用每一个类的allow_request方法，如果返回False即被限流，将等待时间添加到列表throttle_durations中，并获取最大等待时间duration，然后抛出异常 对于每一个限流类，循环throttle_classes实例化时，重写了scope，THROTTLE_RATES，cache，get_cache_key等等属性方法，并调用__init__初始化 调用get_rate方法，获取THROTTLE_RATES[self.scope]作为rate，如5/m 调用parse_rate方法，将rate作为参数，返回次数与间隔给num_requests和duration 每一个类执行allow_request时，调用get_cache_key获取唯一标识key，从cache中根据key获取对应维护的记录列表给history，获取当前时间now，循环history，将时间小于now-duration即计数起点的记录pop掉，比较列表剩余长度与num_requests 如果超过限制，调用throttle_failure 正常访问，调用throttle_success 正常访问，throttle_success将本次记录加入history，并更新缓存，返回True 超过限制，调用throttle_failure返回False 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 class BaseThrottle: def allow_request(self, request, view): raise NotImplementedError(\u0026#39;.allow_request() must be overridden\u0026#39;) def get_ident(self, request): pass def wait(self): return None class SimpleRateThrottle(BaseThrottle): cache = default_cache timer = time.time cache_format = \u0026#39;throttle_%(scope)s_%(ident)s\u0026#39; scope = None # 全局配置的scope与THROTTLE_RATES对应关系，可以在settings.py中配置DEFAULT_THROTTLE_RATES，在自定义限流类中只需指定scope即可 THROTTLE_RATES = api_settings.DEFAULT_THROTTLE_RATES # 初始化访问限制的次数与时间 def __init__(self): if not getattr(self, \u0026#39;rate\u0026#39;, None): self.rate = self.get_rate() # \u0026#34;5/m\u0026#34; self.num_requests, self.duration = self.parse_rate(self.rate) def get_cache_key(self, request, view): raise NotImplementedError(\u0026#39;.get_cache_key() must be overridden\u0026#39;) def get_rate(self): if not getattr(self, \u0026#39;scope\u0026#39;, None): msg = (\u0026#34;You must set either `.scope` or `.rate` for \u0026#39;%s\u0026#39; throttle\u0026#34; % self.__class__.__name__) raise ImproperlyConfigured(msg) try: # THROTTLE_RATES = {\u0026#34;XXX\u0026#34;: \u0026#34;5/m\u0026#34;} # 限制频率 # scope = \u0026#34;XXX\u0026#34; return self.THROTTLE_RATES[self.scope] except KeyError: msg = \u0026#34;No default throttle rate set for \u0026#39;%s\u0026#39; scope\u0026#34; % self.scope raise ImproperlyConfigured(msg) # 将THROTTLE_RATES切割为次数和对应时间范围 def parse_rate(self, rate): # \u0026#34;5/m\u0026#34; if rate is None: return (None, None) num, period = rate.split(\u0026#39;/\u0026#39;) num_requests = int(num) # period[0]取出s、m或h，因此自定义THROTTLE_RATES时也可以将h写成hour，因为它只读取索引为零的字符 duration = {\u0026#39;s\u0026#39;: 1, \u0026#39;m\u0026#39;: 60, \u0026#39;h\u0026#39;: 3600, \u0026#39;d\u0026#39;: 86400}[period[0]] return (num_requests, duration) # 返回 5 60 def allow_request(self, request, view): if self.rate is None: return True # 获取唯一标识 self.key = self.get_cache_key(request, view) if self.key is None: return True # 获取历史访问记录[20:35 20:32 20:22 20:12] self.history = self.cache.get(self.key, []) # 获取当前时间 self.now = self.timer() # 循环 将小于计数开始时间剔除 while self.history and self.history[-1] \u0026lt;= self.now - self.duration: self.history.pop() # 计算长度 if len(self.history) \u0026gt;= self.num_requests: return self.throttle_failure() # 超过限制，返回False return self.throttle_success() # 正常访问，返回True def throttle_success(self): # 将本次请求事件加入历史访问记录中 self.history.insert(0, self.now) self.cache.set(self.key, self.history, self.duration) return True def throttle_failure(self): return False def wait(self): if self.history: remaining_duration = self.duration - (self.now - self.history[-1]) # 还需要等待的时间 else: remaining_duration = self.duration available_requests = self.num_requests - len(self.history) + 1 if available_requests \u0026lt;= 0: return None return remaining_duration / float(available_requests) class MyThrottle(SimpleRateThrottle): scope = \u0026#34;XXX\u0026#34; THROTTLE_RATES = {\u0026#34;XXX\u0026#34;: \u0026#34;5/m\u0026#34;} # 限制频率 cache = default_cache # redis配置 # 获取唯一标识，后续可以连接redis做操作 def get_cache_key(self, request, view): if request.user: ident = request.user.pk # 用户ID else: ident = self.get_ident(request) # 获取请求用户IP（去request中找请求头） # cache_format = \u0026#39;throttle_%(scope)s_%(ident)s\u0026#39; return self.cache_format % {\u0026#39;scope\u0026#39;: self.scope, \u0026#39;ident\u0026#39;: ident} class APIView(View): throttle_classes = api_settings.DEFAULT_THROTTLE_CLASSES def get_throttles(self): # 创建限流类实例对象，返回限流类对象列表，局部配置优先于全局 return [throttle() for throttle in self.throttle_classes] def check_throttles(self, request): throttle_durations = [] # 循环每个对象 -\u0026gt; allow_request到底如何实现的 for throttle in self.get_throttles(): # 超过频率限制，不允许访问 if not throttle.allow_request(request, self): # 将等待时间添加进列表 throttle_durations.append(throttle.wait()) if throttle_durations: durations = [ duration for duration in throttle_durations if duration is not None ] # 获取最大等待时间 duration = max(durations, default=None) # 抛出异常 self.throttled(request, duration) def throttled(self, request, wait): raise exceptions.Throttled(wait) def initial(self, request, *args, **kwargs): self.perform_authentication(request) # 认证组件的过程，循环执行每个authenticate方法；失败则抛出异常不向下执行 self.check_permissions(request) # 权限的校验 self.check_throttles(request) def dispatch(self, request, *args, **kwargs): # 封装drf的request request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: self.initial(request, *args, **kwargs) # 反射获取get/post等方法 handler = getattr(self, request.method.lower(), self.http_method_not_allowed) # 执行相应方法 response = handler(request, *args, **kwargs) # 异常处理 except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response class MyThrottle(SimpleRateThrottle): scope = \u0026#34;XXX\u0026#34; THROTTLE_RATES = {\u0026#34;XXX\u0026#34;: \u0026#34;5/m\u0026#34;} # 限制频率 cache = default_cache # redis配置 # 获取唯一标识，后续可以连接redis做操作 def get_cache_key(self, request, view): if request.user: ident = request.user.pk # 用户ID else: ident = self.get_ident(request) # 获取请求用户IP（去request中找请求头） # cache_format = \u0026#39;throttle_%(scope)s_%(ident)s\u0026#39; return self.cache_format % {\u0026#39;scope\u0026#39;: self.scope, \u0026#39;ident\u0026#39;: ident} class OrderView(APIView): permission_classes = [MyPermission1, MyPermission2, MyPermission3] # 权限组件的局部配置 throttle_classes = [] def get(self, request): print(request.user, request.auth) return Response({\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: [11, 22, 33, 44]}) 7.4 案例-限流的应用 在前几个组件案例的基础上实现，下列非完整代码，主要是限流功能的实现\n无需登录，限流 10/m 登录，限流 5/m settings.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 REST_FRAMEWORK = { \u0026#34;UNAUTHENTICATED_USER\u0026#34;: None, # 未登录时，request.user=None \u0026#34;UNAUTHENTICATED_TOKEN\u0026#34;: None, # 未登录时，request.auth=None \u0026#34;DEFAULT_AUTHENTICATION_CLASSES\u0026#34;: [ \u0026#34;ext.auth.QueryParamsAuthentication\u0026#34;, \u0026#34;ext.auth.HeaderAuthentication\u0026#34;, \u0026#34;ext.auth.NoAuthentication\u0026#34;, ], \u0026#34;DEFAULT_PERMISSION_CLASSES\u0026#34;: [ ], \u0026#34;DEFAULT_THROTTLE_RATES\u0026#34;: { \u0026#34;Ip\u0026#34;: \u0026#34;10/m\u0026#34;, \u0026#34;user\u0026#34;: \u0026#34;5/m\u0026#34;, } } ext/throttle.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from rest_framework.throttling import SimpleRateThrottle from django.core.cache import cache as default_cache class IpThrottle(SimpleRateThrottle): scope = \u0026#34;Ip\u0026#34; cache = default_cache # redis配置 # 确定是匿名的，因此直接获取ip做标识即可 def get_cache_key(self, request, view): ident = self.get_ident(request) # 获取请求用户IP（去request中找请求头） # cache_format = \u0026#39;throttle_%(scope)s_%(ident)s\u0026#39; return self.cache_format % {\u0026#39;scope\u0026#39;: self.scope, \u0026#39;ident\u0026#39;: ident} class UserThrottle(SimpleRateThrottle): scope = \u0026#34;user\u0026#34; cache = default_cache # redis配置 def get_cache_key(self, request, view): ident = request.user.pk # 用户ID return self.cache_format % {\u0026#39;scope\u0026#39;: self.scope, \u0026#39;ident\u0026#39;: ident} api/views.py 1 2 3 4 5 6 7 8 9 10 class LoginView(APIView): authentication_classes = [] throttle_classes = [IpThrottle, ] ... class AvatarView(NbApiView): # 总监、员工可以访问 permission_classes = [BossPermission, UserPermission, ] throttle_classes = [UserThrottle, ] ... 7.5 总结 全局配置限流频率settings.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 REST_FRAMEWORK = { \u0026#34;UNAUTHENTICATED_USER\u0026#34;: None, # 未登录时，request.user=None \u0026#34;UNAUTHENTICATED_TOKEN\u0026#34;: None, # 未登录时，request.auth=None \u0026#34;DEFAULT_AUTHENTICATION_CLASSES\u0026#34;: [ \u0026#34;ext.auth.QueryParamsAuthentication\u0026#34;, \u0026#34;ext.auth.HeaderAuthentication\u0026#34;, \u0026#34;ext.auth.NoAuthentication\u0026#34;, ], \u0026#34;DEFAULT_PERMISSION_CLASSES\u0026#34;: [ \u0026#34;ext.per.Mypermission\u0026#34;, ], \u0026#34;DEFAULT_THROTTLE_RATES\u0026#34;: { \u0026#34;Ip\u0026#34;: \u0026#34;10/m\u0026#34;, \u0026#34;user\u0026#34;: \u0026#34;5/m\u0026#34;, } } 限流组件的定义ext/throttle.py，局部配置可覆盖全局定义的频率\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from rest_framework.throttling import SimpleRateThrottle from django.core.cache import cache as default_cache class IpThrottle(SimpleRateThrottle): # 局部配置 scope = \u0026#34;Ip\u0026#34; THROTTLE_RATES = {\u0026#34;Ip\u0026#34;: \u0026#34;5/m\u0026#34;} cache = default_cache # redis配置 # 确定是匿名的，因此直接获取ip做标识即可 def get_cache_key(self, request, view): ident = self.get_ident(request) # 获取请求用户IP（去request中找请求头） # cache_format = \u0026#39;throttle_%(scope)s_%(ident)s\u0026#39; return self.cache_format % {\u0026#39;scope\u0026#39;: self.scope, \u0026#39;ident\u0026#39;: ident} class UserThrottle(SimpleRateThrottle): # 采用全局 scope = \u0026#34;user\u0026#34; cache = default_cache # redis配置 def get_cache_key(self, request, view): ident = request.user.pk # 用户ID return self.cache_format % {\u0026#39;scope\u0026#39;: self.scope, \u0026#39;ident\u0026#39;: ident} 视图函数应用限流类\n1 2 3 4 from ext.throttle import MyThrottle class LoginView(APIView): throttle_classes = [MyThrottle, ] ... 8. 版本 API版本控制是一个关键的实践，它有助于确保API的稳定性、可靠性和兼容性，同时为API的长期维护和演进提供支持。通过在请求中携带版本号，开发者可以更好地管理API的不同版本，并确保对客户端的影响最小化\n8.1 GET参数传递 配置文件中的VERSION_PARAM决定哪个参数表示版本信息\n参数携带的版本信息会被封装到request.version\nsettings.py 1 2 3 4 5 6 7 8 9 10 REST_FRAMEWORK = { # 携带版本信息的请求参数名 \u0026#39;VERSION_PARAM\u0026#39;: \u0026#39;version\u0026#39;, # 未传入版本参数时的默认版本 \u0026#39;DEFAULT_VERSION\u0026#39;: \u0026#34;v1\u0026#34;, # 版本范围列表 \u0026#39;ALLOWED_VERSIONS\u0026#39;: [\u0026#34;v1\u0026#34;, \u0026#34;v2\u0026#34;], # 默认版本类 \u0026#39;DEFAULT_VERSIONING_CLASS\u0026#39;: \u0026#39;rest_framework.versioning.QueryParameterVersioning\u0026#39;, } 8.2 反向生成URL 与django中的反向生成URL不同，drf反向生成的URL可以携带相关版本信息\nGET请求携带的其他参数不会自动生成\n8.3 源码解读 1 2 3 4 5 6 7 8 9 10 1 入口在APIView类的initial()方法，调用determine_version方法，将版本信息和版本类封装到request中version，versioning_scheme 2 determine_version方法，如果没有定义版本类，返回(None, None)，定义了版本类，将其实例化赋值给versioning_scheme，调用scheme的determine_version，返回结果赋值version。 2.1 版本类实例化时，继承父类，读取全局配置default_version，allowed_versions，version_param，实例化后赋值给versioning_scheme 2.2 调用scheme的determine_version，从请求参数中读取版本信息version，并且调用is_allowed_version方法，判断version值是否合法：allowed_versions为空或version是默认值或在allowed_versions范围内，合法：返回给version 当视图函数中要反向生成url时，request.versioning_scheme.reverse(\u0026#34;hm\u0026#34;,request=request) 1 调用版本类的reverse方法，并传入路由的别名 1.1 调用父类的reverse，传入路由别名，反向生成url（就是django中的） 1.2 调用replace_query_param，通过query_dict和urlencode将版本信息插入到url中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class BaseVersioning: default_version = api_settings.DEFAULT_VERSION allowed_versions = api_settings.ALLOWED_VERSIONS version_param = api_settings.VERSION_PARAM def determine_version(self, request, *args, **kwargs): msg = \u0026#39;{cls}.determine_version() must be implemented.\u0026#39; raise NotImplementedError(msg.format( cls=self.__class__.__name__ )) def reverse(self, viewname, args=None, kwargs=None, request=None, format=None, **extra): return _reverse(viewname, args, kwargs, request, format, **extra) def is_allowed_version(self, version): # 列表为空 -\u0026gt; 所有版本均可 if not self.allowed_versions: return True # version是默认值或者在allowed_versions列表范围内 return ((version is not None and version == self.default_version) or (version in self.allowed_versions)) class QueryParameterVersioning(BaseVersioning): \u0026#34;\u0026#34;\u0026#34; GET /something/?version=0.1 HTTP/1.1 Host: example.com Accept: application/json \u0026#34;\u0026#34;\u0026#34; invalid_version_message = _(\u0026#39;Invalid version in query parameter.\u0026#39;) def determine_version(self, request, *args, **kwargs): # 去请求参数中获取键为version_param的值即为版本，若不存在则读取settings.py中的默认值 version = request.query_params.get(self.version_param, self.default_version) if not self.is_allowed_version(version): raise exceptions.NotFound(self.invalid_version_message) return version # 传入视图名称和request def reverse(self, viewname, args=None, kwargs=None, request=None, format=None, **extra): # 本质上就是调用django的reverse反向生成URL url = super().reverse( viewname, args, kwargs, request, format, **extra ) # 将版本信息添加或替换进去 if request.version is not None: return replace_query_param(url, self.version_param, request.version) return url def replace_query_param(url, key, val): (scheme, netloc, path, query, fragment) = parse.urlsplit(force_str(url)) query_dict = parse.parse_qs(query, keep_blank_values=True) query_dict[force_str(key)] = [force_str(val)] query = parse.urlencode(sorted(query_dict.items()), doseq=True) return parse.urlunsplit((scheme, netloc, path, query, fragment)) class APIView(View): versioning_class = api_settings.DEFAULT_VERSIONING_CLASS def determine_version(self, request, *args, **kwargs): if self.versioning_class is None: return (None, None) # 实例化类对象，即QueryParameterVersioning(),，欸有__init__方法 scheme = self.versioning_class() # 返回版本信息与版本类对象 return (scheme.determine_version(request, *args, **kwargs), scheme) def initial(self, request, *args, **kwargs): # 将版本信息与版本类封装到request中 version, scheme = self.determine_version(request, *args, **kwargs) request.version, request.versioning_scheme = version, scheme # Ensure that the incoming request is permitted self.perform_authentication(request) self.check_permissions(request) self.check_throttles(request) def dispatch(self, request, *args, **kwargs): self.args = args self.kwargs = kwargs request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: self.initial(request, *args, **kwargs) handler = getattr(self, request.method.lower(), self.http_method_not_allowed) response = handler(request, *args, **kwargs) except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response class HomeView(APIView): # 配置文件 VERSION_PARAM # http://127.0.0.1:8000/home/?xx=123\u0026amp;page=44\u0026amp;vertion=v1 -\u0026gt; request.version versioning_class = QueryParameterVersioning def get(self, request): print(request.version) return Response(\u0026#34;...\u0026#34;) 8.4 URL路径传递 urls.py中path和re_path两种方式均可\n1 2 3 4 5 6 7 8 9 10 # 源码 class URLPathVersioning(BaseVersioning): def determine_version(self, request, *args, **kwargs): version = kwargs.get(self.version_param, self.default_version) if version is None: version = self.default_version if not self.is_allowed_version(version): raise exceptions.NotFound(self.invalid_version_message) return version 从kwargs中读取版本，因此视图函数要用*args和**kwargs接收，其他源码逻辑与GET参数传递基本相同\nURL参数传递不需要*args和**kwargs接收是因为传参可以从request中可以取出\n8.5 Accept请求头传递 反向生成的URL不含版本，因为他本来就不出现在url中\n参考代码\n1 2 3 4 5 6 7 8 9 10 # urls.py from django.urls import path, re_path from api import views urlpatterns = [ # path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;home/\u0026#39;, views.HomeView.as_view(), name=\u0026#39;hm\u0026#39;), # path(\u0026#39;api/\u0026lt;str:version\u0026gt;/home/\u0026#39;, views.HomeView.as_view(), name=\u0026#39;hm\u0026#39;), # re_path(r\u0026#39;^api/(?P\u0026lt;version\u0026gt;\\w+)/home/$\u0026#39;, views.HomeView.as_view(), name=\u0026#39;hm\u0026#39;), ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # views.py from rest_framework.views import APIView from rest_framework.response import Response from rest_framework.versioning import QueryParameterVersioning, URLPathVersioning, AcceptHeaderVersioning # Create your views here. class HomeView(APIView): # 配置文件 VERSION_PARAM # http://127.0.0.1:8000/home/?xx=123\u0026amp;page=44\u0026amp;vertion=v1 -\u0026gt; request.version versioning_class = AcceptHeaderVersioning def get(self, request, *args, **kwargs): print(request.version) print(request.versioning_scheme) url = request.versioning_scheme.reverse(\u0026#39;hm\u0026#39;, request=request) print(\u0026#34;反向生成的url:\u0026#34;, url) return Response(\u0026#34;...\u0026#34;) 8.6 总结 后续开发时，一般都采用URL路径传递的形式，下列给出开发示例\nsettings.py进行全局配置 1 2 3 4 5 6 7 8 REST_FRAMEWORK = { \u0026#39;UNAUTHENTICATED_USER\u0026#39;: None, \u0026#39;VERSION_PARAM\u0026#39;: \u0026#39;version\u0026#39;, \u0026#39;DEFAULT_VERSION\u0026#39;: \u0026#34;v1\u0026#34;, \u0026#39;ALLOWED_VERSIONS\u0026#39;: [\u0026#34;v1\u0026#34;, \u0026#34;v2\u0026#34;], # 全局配置 \u0026#39;DEFAULT_VERSIONING_CLASS\u0026#39;: \u0026#39;rest_framework.versioning.URLPathVersioning\u0026#39;, } views.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from rest_framework.views import APIView from rest_framework.response import Response from rest_framework.versioning import QueryParameterVersioning, URLPathVersioning, AcceptHeaderVersioning class HomeView(APIView): # 局部配置 versioning_class = URLPathVersioning def get(self, request, *args, **kwargs): print(request.version) print(request.versioning_scheme) # 反向生成url url = request.versioning_scheme.reverse(\u0026#39;hm\u0026#39;, request=request) print(\u0026#34;反向生成的url:\u0026#34;, url) return Response(\u0026#34;...\u0026#34;) urls.py 1 2 3 4 5 6 from django.urls import path, re_path from api import views urlpatterns = [ path(\u0026#39;api/\u0026lt;str:version\u0026gt;/home/\u0026#39;, views.HomeView.as_view(), name=\u0026#39;hm\u0026#39;), ] 9. 解析器 在 Django REST Framework（DRF）中，解析器（Parser）是用于处理传入请求数据的组件。解析器负责将原始请求数据request.body（如 JSON、表单数据、XML 等）解析成 Python 数据结构，使得视图函数可以方便地访问和操作请求数据，让序列化器可以进一步处理这些数据\n9.1 流程概述 解析器一般用于解析POST请求请求体中的数据，与内容协商机制（Content Negotiation）配合，content-type不同，客户端传递来的数据格式也不同，根据客户端的 Content-Type 头部选择合适的解析器来解析请求体\n大体的流程为：\n读取请求头 根据请求头解析数据 根据请求头获取解析器 -\u0026gt; 如JSON解析器 request.data = JSON解析器.parse request.data获取处理后的数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Form 解析器 content-type:\u0026#34;urlencode\u0026#34; class JSON 解析器 content-type:\u0026#34;application/json\u0026#34; def parse(): ... 请求者： GET http://127.0.0.1:8000/api/home/?xxx=123\u0026amp;abc=xxx --\u0026gt; request.query_params 请求头 POST http://127.0.0.1:8000/api/home/ 请求头 content-type:\u0026#34;urlencode...\u0026#34; content-type:\u0026#34;application/json\u0026#34; 请求体 name=zhangs\u0026amp;age=18 {\u0026#34;name\u0026#34;:\u0026#34;zhangs\u0026#34;,\u0026#34;age\u0026#34;:19} 9.2 常见应用 9.2.1 JSONParser 解析JSON格式的请求数据（application/json），返回python中的字典类型\n9.2.2 FormParser 解析表单（application/x-www-form-urlencoded）数据为QueryDict（字典）类型数据\n9.2.3 MultiPartParser 解析多部分表单数据（multipart/form-data），支持同时解析文件和表单字段，通常用于文件上传\n9.2.4 FileUploadParser 只能处理文件上传请求application/octet-stream\n9.3 源码流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 dispatch()的流程走完仅仅实现parsers，negotiator，parser_context等值的封装，真正的解析发生在调用request.data时 加载时触发dispatch()方法，调用initialize_request 调用get_parser_context方法，将视图对象，URL路由参数封装成对象赋值给parser_context 调用get_parsers，循环解析器类对象列表parser_classes创建实例列表parsers 调用get_content_negotiator，将协商器content_negotiation_class实例化后的对象赋值给negotiator 将parser_context，parsers，negotiator一并封装进Request中 在Request的init方法中：往parser_context中进一步添加了request和encoding数据 initialize_request执行完，调用initial方法 调用perform_content_negotiation方法，将被选择的渲染器实例赋值给accepted_renderer，将对应的媒体类型字符串赋值给accepted_media_type 循环实例化获取渲染器实例化对象列表renderers，conneg为协商器对象，调用conneg的select_renderer方法，根据客户端的 Accept 请求头和渲染器的优先级选择一个合适的渲染器 当调用request.data时，才真正地解析数据 如果_full_data有值，直接返回，无值，调用_load_data_and_files加载值 调用_parse， 循环解析器列表parsers，调用协商器的select_parser方法，将请求中的content_type与解析器内部的media_type匹配，找到匹配的解析器parser 调用解析器的parse方法，将数据解析成目标格式，赋值给parsed，返回(parsed.data, parsed.files) 用_data和_files接收解析后的数据，处理成完整的数据赋值给_full_data，下次调用request.data可以直接返回 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 class DefaultContentNegotiation(BaseContentNegotiation): # 根据请求头类型与解析器内定义的media_type匹配出对应的解析器 def select_parser(self, request, parsers): for parser in parsers: if media_type_matches(parser.media_type, request.content_type): return parser return None class FormParser(BaseParser): media_type = \u0026#39;application/x-www-form-urlencoded\u0026#39; def parse(self, stream, media_type=None, parser_context=None): parser_context = parser_context or {} encoding = parser_context.get(\u0026#39;encoding\u0026#39;, settings.DEFAULT_CHARSET) return QueryDict(stream.read(), encoding=encoding) class JSONParser(BaseParser): media_type = \u0026#39;application/json\u0026#39; renderer_class = renderers.JSONRenderer strict = api_settings.STRICT_JSON def parse(self, stream, media_type=None, parser_context=None): parser_context = parser_context or {} encoding = parser_context.get(\u0026#39;encoding\u0026#39;, settings.DEFAULT_CHARSET) try: decoded_stream = codecs.getreader(encoding)(stream) parse_constant = json.strict_constant if self.strict else None return json.load(decoded_stream, parse_constant=parse_constant) except ValueError as exc: raise ParseError(\u0026#39;JSON parse error - %s\u0026#39; % str(exc)) class Request: def __init__(self, request, parsers=None, authenticators=None, negotiator=None, parser_context=None): self._request = request self.parsers = parsers or () self.authenticators = authenticators or () self.negotiator = negotiator or self._default_negotiator() self.parser_context = parser_context self._data = Empty self._files = Empty self._full_data = Empty self._content_type = Empty self._stream = Empty if self.parser_context is None: self.parser_context = {} self.parser_context[\u0026#39;request\u0026#39;] = self self.parser_context[\u0026#39;encoding\u0026#39;] = request.encoding or settings.DEFAULT_CHARSET @property def data(self): if not _hasattr(self, \u0026#39;_full_data\u0026#39;): # 加载值 self._load_data_and_files() return self._full_data def _load_data_and_files(self): if not _hasattr(self, \u0026#39;_data\u0026#39;): self._data, self._files = self._parse() if self._files: self._full_data = self._data.copy() self._full_data.update(self._files) else: self._full_data = self._data if is_form_media_type(self.content_type): self._request._post = self.POST self._request._files = self.FILES @property def content_type(self): meta = self._request.META return meta.get(\u0026#39;CONTENT_TYPE\u0026#39;, meta.get(\u0026#39;HTTP_CONTENT_TYPE\u0026#39;, \u0026#39;\u0026#39;)) def _parse(self): # 获取请求头中的content_type media_type = self.content_type # 请求发送过来的原始数据 stream = self.stream # DefaultContentNegotiation.select_parser() # 循环解析器列表，找到content-type符合的解析器并返回 parser = self.negotiator.select_parser(self, self.parsers) # request [JSONParserm,FormParser] # 执行解析器的parse方法 parsed = parser.parse(stream, media_type, self.parser_context) try: return (parsed.data, parsed.files) except AttributeError: empty_files = MultiValueDict() return (parsed, empty_files) class APIView(View): renderer_classes = api_settings.DEFAULT_RENDERER_CLASSES parser_classes = api_settings.DEFAULT_PARSER_CLASSES content_negotiation_class = api_settings.DEFAULT_CONTENT_NEGOTIATION_CLASS def get_parser_context(self, http_request): return { \u0026#39;view\u0026#39;: self, \u0026#39;args\u0026#39;: getattr(self, \u0026#39;args\u0026#39;, ()), \u0026#39;kwargs\u0026#39;: getattr(self, \u0026#39;kwargs\u0026#39;, {}) } def get_parsers(self): return [parser() for parser in self.parser_classes] def get_content_negotiator(self): if not getattr(self, \u0026#39;_negotiator\u0026#39;, None): self._negotiator = self.content_negotiation_class() return self._negotiator def initialize_request(self, request, *args, **kwargs): # {视图对象，URL路由参数} parser_context = self.get_parser_context(request) return Request( request, # django的request parsers=self.get_parsers(), # 解析器 [JSONParser(),FormParser(),] authenticators=self.get_authenticators(), # 认证组件 [认证对象1，认证对象2] negotiator=self.get_content_negotiator(), # DefaultContentNegotiation() parser_context=parser_context # {视图对象，URL路由参数 + drf的request,encoding} ) def dispatch(self, request, *args, **kwargs): self.args = args self.kwargs = kwargs request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: self.initial(request, *args, **kwargs) handler = getattr(self, request.method.lower(), self.http_method_not_allowed) response = handler(request, *args, **kwargs) except Exception as exc: response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response def initial(self, request, *args, **kwargs): neg = self.perform_content_negotiation(request) # 第一个元素是被选择的渲染器实例，第二个元素是对应的媒体类型字符串 request.accepted_renderer, request.accepted_media_type = neg version, scheme = self.determine_version(request, *args, **kwargs) request.version, request.versioning_scheme = version, scheme # Ensure that the incoming request is permitted self.perform_authentication(request) self.check_permissions(request) self.check_throttles(request) # 该方法负责根据客户端的 Accept 请求头来确定响应的内容类型。这个方法会检查客户端接受哪些媒体类型，并根据服务器能够提供的媒体类型来选择一个合适的渲染器（Renderer） def perform_content_negotiation(self, request, force=False): renderers = self.get_renderers() conneg = self.get_content_negotiator() try: return conneg.select_renderer(request, renderers, self.format_kwarg) except Exception: if force: return (renderers[0], renderers[0].media_type) raise def get_renderers(self): return [renderer() for renderer in self.renderer_classes] def get_content_negotiator(self): if not getattr(self, \u0026#39;_negotiator\u0026#39;, None): self._negotiator = self.content_negotiation_class() return self._negotiator class HomeView(APIView): # 所有的解析器 parser_classes = [JSONParser, FormParser] # 根据请求，匹配对应的解析器 content_negotiation = DefaultContentNegotiation def post(self, request, *args, **kwargs): print(request.data, type(request.data)) return Response(\u0026#34;请求来了\u0026#34;) 9.4 解析器全局配置 如图，默认解析器有JSONParser,FormParser,MutiPartParser三种\n但为了防止不能上传图片等功能点因为默认解析器可以上传图片，导致request.data的类型的不确定性，建议局部配置\n修改全局配置\n1 2 3 4 5 6 7 8 9 10 11 REST_FRAMEWORK = { \u0026#39;UNAUTHENTICATED_USER\u0026#39;: None, \u0026#39;VERSION_PARAM\u0026#39;: \u0026#39;version\u0026#39;, \u0026#39;DEFAULT_VERSION\u0026#39;: \u0026#34;v1\u0026#34;, \u0026#39;ALLOWED_VERSIONS\u0026#39;: [\u0026#34;v1\u0026#34;, \u0026#34;v2\u0026#34;], \u0026#39;DEFAULT_VERSIONING_CLASS\u0026#39;: \u0026#39;rest_framework.versioning.QueryParameterVersioning\u0026#39;, \u0026#39;DEFAULT_PARSER_CLASSES\u0026#39;: [\u0026#39;rest_framework.parsers.JSONParser\u0026#39;, ] # 设置默认解析器只有JSONParser \u0026#39;DEFAULT_RENDERER_CLASSES\u0026#39;: \u0026#39;DEFAULT_CONTENT_NEGOTIATION_CLASS\u0026#39;: } 后续如果有上传图片的功能点，再局部配置其解析器即可\n1 parser_classes = [MutiPartParser,] 9.5 总结 解析器负责将客户端发送的请求体解析为 Python 可操作的数据结构。DRF 提供了多种默认解析器，例如 JSONParser，FormParser 和 MultiPartParser 渲染器负责将响应数据转换为客户端可读的格式。DRF 提供了多种默认渲染器，例如 JSONRenderer 和 BrowsableAPIRenderer 内容协商器负责根据客户端的 Accept 请求头和服务器支持的渲染器选择合适的渲染器。DRF 默认使用 DefaultContentNegotiation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 REST_FRAMEWORK = { \u0026#39;DEFAULT_PARSER_CLASSES\u0026#39;: [ \u0026#39;rest_framework.parsers.JSONParser\u0026#39;, \u0026#39;rest_framework.parsers.FormParser\u0026#39;, \u0026#39;rest_framework.parsers.MultiPartParser\u0026#39;, ], \u0026#39;DEFAULT_RENDERER_CLASSES\u0026#39;: [ \u0026#39;rest_framework.renderers.JSONRenderer\u0026#39;, \u0026#39;rest_framework.renderers.BrowsableAPIRenderer\u0026#39;, ] \u0026#39;DEFAULT_CONTENT_NEGOTIATION_CLASS\u0026#39;: [ \u0026#39;rest_framework.negotiation.DefaultContentNegotiation\u0026#39;, ] } 1 2 3 4 5 6 7 8 9 from rest_framework.parsers import JSONParser, FormParser, MultiPartParser from rest_framework.renderers import JSONRenderer from rest_framework.negotiation import DefaultContentNegotiation class MyUploadView(APIView): parser_classes = [JSONParser, FormParser, MultiPartParser] renderer_classes = [JSONRenderer] content_negotiation_class = DefaultContentNegotiation 10. 元类 在Python中，一切皆对象。类本身也是对象，而元类就是用来创建类的类。元类（metaclass）可以干预类的创建，控制类的实例化\n普通的类用来定义一般对象的属性和行为，元类用来定义普通的类及其实例对象的属性和行为\n10.1 类和对象的基础知识 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 类和对象，基于类实例化对象 # 类 class Foo: # 类变量 v1 = 123 def __init__(self, name): # 实例变量 self.name = name # 类方法 def func(self): pass # 对象 obj1 = Foo(\u0026#39;test\u0026#39;) obj2 = Foo(\u0026#39;test2\u0026#39;) 10.2 创建类的两种方式 方式一就是我们平常书写的形式，而方式二就显示地展示了元类创建类的过程，本质上方式一经过处理后就是通过方式二创建类的，只是方式一更加直观且易于书写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 创建类：方式1 class Foo: v1 = 123 def func(self): return 999 # 创建类：方式2 # 类名 = type(\u0026#34;类名\u0026#34;,(父类,),{成员}) # Foo = type(\u0026#34;Foo\u0026#34;, (object,), {\u0026#34;v1\u0026#34;: 123, \u0026#34;func\u0026#34;: lambda self: 999}) obj1 = Foo() print(obj1.v1) print(obj1.func()) 10.3 MyType创建类与拓展 使用元类，最常见方式是自定义一个元类，继承type，然后使用自定义的元类创建类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MyType(type): def __new__(cls, *args, **kwargs): xx = super().__new__(cls, *args, **kwargs) print(\u0026#34;创建类\u0026#34;, xx) return xx Foo = MyType(\u0026#34;Foo\u0026#34;, (object,), {\u0026#34;v1\u0026#34;: 123, \u0026#34;func\u0026#34;: lambda self: 999}) obj1 = Foo() print(obj1.v1) print(obj1.func()) # 创建类 \u0026lt;class \u0026#39;__main__.Foo\u0026#39;\u0026gt; # 123 # 999 应用在我们常用的类的创建方式时，就是要将元类指定为类的metaclass关键字参数，告诉Python在创建类时使用指定的元类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 基于type创建 # class Foo: # v1 = 123 # # def func(self): # pass # 基于MyType创建 class MyType(type): def __new__(cls, *args, **kwargs): xx = super().__new__(cls, *args, **kwargs) print(\u0026#34;创建类\u0026#34;, xx) return xx class Foo(object, metaclass=MyType): v1 = 123 def func(self): pass print(Foo) 元类中可以重写__new__和__init__方法来控制类的创建和初始化过程。__new__方法在类创建之前调用，__init__方法在类创建之后调用。\n__new__传入的name, bases, attrs其实就是我们使用方式二创建时传入的类名，父类及及属性，因此就可以在调用type的__new__创建类之前，对传入的name, bases, attrs进行修改，从而干预类的创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class MyType(type): def __new__(cls, name, bases, attrs): # Foo (\u0026lt;class \u0026#39;object\u0026#39;\u0026gt;,) {\u0026#39;__module__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;__qualname__\u0026#39;: \u0026#39;Foo\u0026#39;, \u0026#39;v1\u0026#39;: 123, \u0026#39;func\u0026#39;: \u0026lt;function Foo.func at 0x000002209BA9C310\u0026gt;} print(name, bases, attrs) # 可以在创建空间前对类进行更改，如添加/删除属性等等 del attrs[\u0026#39;v1\u0026#39;] attrs[\u0026#39;add\u0026#39;] = \u0026#39;xxx\u0026#39; xx = super().__new__(cls, name, bases, attrs) return xx class Foo(object, metaclass=MyType): v1 = 123 def func(self): pass print(Foo.add) print(Foo.v1) 10.4 继承关系 指定metaclass的类以及他所有的子类都将由指定的metaclass创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class MyType(type): def __new__(cls, name, bases, attrs): print(name, bases, attrs) xx = super().__new__(cls, name, bases, attrs) return xx class Info(object): pass class Foo(object, metaclass=MyType): pass class Bar(Foo): pass Info() Foo() Bar() 10.5 drf序列化源码案例 因为UserSerializer是Serializer的子类，而Serializer指定了metaclass=SerializerMetaclass，因此由上一小节的继承关系的介绍可知，UserSerializer也将由元类SerializerMetaclass创建，因此他的实例空间中有_declared_fields属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class SerializerMetaclass(type): def __new__(cls, name, bases, attrs): data_dict = {} for k, v in list(attrs.items()): # {\u0026#34;v1\u0026#34;:123,\u0026#34;v2\u0026#34;:123,\u0026#34;v3\u0026#34;:123} if isinstance(v, int): data_dict[k] = attrs.pop(k) attrs[\u0026#39;_declared_fields\u0026#39;] = data_dict return super().__new__(cls, name, bases, attrs) class BaseSerializer(object): pass class Serializer(BaseSerializer, metaclass=SerializerMetaclass): pass class ModelSerializer(Serializer): pass class UserSerializer(ModelSerializer): v1 = 123 v2 = 456 v3 = \u0026#34;哈哈哈\u0026#34; print(UserSerializer.v3) print(UserSerializer._declared_fields) 运行结果：\n1 2 哈哈哈 {\u0026#39;v1\u0026#39;: 123, \u0026#39;v2\u0026#39;: 456} 10.6 扩展 类是由MyType创建出来，所以类其实是MyType类实例化的对象。\nBase是类，也是MyType类的对象即Mytype()； Base()是Base类实例化的对象，相当于MyType()()\n因此Base类实例化的对象就会执行MyType类的__call__ 而obj()便会执行Base类的__call__ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class MyType(type): def __new__(cls, name, bases, attrs): print(name, bases, attrs) xx = super().__new__(cls, name, bases, attrs) return xx def __call__(cls, *args, **kwargs): print(\u0026#34;执行type的call\u0026#34;) obj = cls.__new__(cls, *args, **kwargs) print(\u0026#34;----\u0026#34;) cls.__init__(obj, *args, **kwargs) return obj class Base(object, metaclass=MyType): def __init__(self): print(\u0026#34;初始化\u0026#34;) def __new__(cls, *args, **kwargs): print(\u0026#34;实例化类的对象\u0026#34;) return object.__new__(cls) def __call__(self, *args, **kwargs): print(\u0026#34;Base.call\u0026#34;) obj = Base() # 执行MyType的__call__ obj() # 执行Base的__call__ 11. 序列化器 序列化器是Django框架中的一个重要概念，用于在Python对象和JSON等格式之间进行相互转换。通过序列化器，我们可以方便地将模型实例转换为JSON格式的数据，并且还可以对数据进行验证、创建和更新等操作。\n解析器： 将客户端发送的请求体（如JSON）解析为 Python 数据结构（如字典或列表） 解析后的数据存储在 request.data 中，供视图和序列化器使用 序列化器： 在视图中，request.data 被传递给序列化器，验证解析后的数据是否符合模型字段的要求 将验证后的数据转换为模型实例，保存到数据库 响应阶段，序列化器将模型实例序列化为Python 数据结构（通常是字典，列表，有序字典） 渲染器： 将Python 数据结构（通常是字典，列表，有序字典）进一步转换为JSON、XML 或其他格式 将序列化后的数据转换为字节流，最终返回给客户端 11.1 序列化 序列化过程 是将从ORM中获取的复杂的数据类型（如 Django 模型实例或查询集）转换为 Python 数据结构（通常是字典，列表，有序字典），然后进一步转换为 JSON、XML 或其他格式的过程（渲染器作用）\n11.1.1 Serializer Serializer是基础序列化器，需要手动定义每个字段\n先创建数据库，以便后续测试获取数据\n手动添加两组数据\n模型实例对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class DepartSerializer(serializers.Serializer): title = serializers.CharField() count = serializers.IntegerField() class DepartView(APIView): def get(self, request, *args, **kwargs): # 1.数据库中获取数据 obj.title obj.order obj.count depart_object = models.Depart.objects.all().first() # 模型实例 # 2.序列化器转换JSON格式 ser = DepartSerializer(instance=depart_object) # {\u0026#39;title\u0026#39;: \u0026#39;技术部\u0026#39;, \u0026#39;count\u0026#39;: 10} print(ser.data) # 字典 # 返回给用户 context = {\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: ser.data} # 字典 return Response(context) # Response对象通过渲染器将字典对象zhuan转换为JSON对象 Queryset数据集对象\n11.1.2 ModelSerializer ModelSerializer是Serializer的子类，专门为模型数据设计，提供了基于模型类自动生成字段的功能\n如下图，指定model为Depart类并指定fields即可基于模型类Depart的字段自动生成字段\n1 2 3 4 class DepartSerializer(serializers.ModelSerializer): class Meta: model = models.Depart fields = \u0026#39;__all__\u0026#39; 11.1.3 字段和参数 上面我们已经学习了Serializer和ModelSerializer两种序列化器，但是仅仅如此远远达不到我们开发时需要的灵活的，因此，这一部分将介绍对字段及参数的自定义，来实现灵活开发\n前置数据准备\n11.1.3.1 返回所有字段 返回模型类中定义的所有字段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class UserSerializer(serializers.ModelSerializer): class Meta: model = models.UserInfo fields = \u0026#39;__all__\u0026#39; class UserView(APIView): def get(self, request, *args, **kwargs): models.UserInfo.objects.all().update(ctime=datetime.datetime.now()) # 1.获取数据 queryset = models.UserInfo.objects.all() # 2.序列化 ser = UserSerializer(queryset, many=True) # 3.返回给用户 context = {\u0026#34;status\u0026#34;: True, \u0026#34;data\u0026#34;: ser.data} return Response(context) 11.1.3.2 指定字段返回 有时我们不需要将类中定义的全部字段返回，于是就需要自定义字段返回\n我们发现gender返回的是数据库中真实存储的1和2，那应该如何让他返回男和女呢？\n1 2 3 # 我们可以自定义字段 gender = serializers.CharField(source=\u0026#39;gender\u0026#39;) # 等同于直接在fields中添加 \u0026#39;gender\u0026#39;，拿到的还是1和2 # 它拿到每一个对象都会.source ，上述语句即obj.gender即可拿到数据库中的值，那么知道了这个，我们就可以自定义字段指定其source来拿到我们想要的数据 11.1.3.3 子定义字段返回 choices展示\nobj.get_gender_display即可获取choices中的男或女 foreignkey跨表查询\n通过FK进行跨表查询 时间数据格式设置\n1 2 3 4 5 6 7 8 9 class UserSerializer(serializers.ModelSerializer): gender_text = serializers.CharField(source=\u0026#39;get_gender_display\u0026#39;) depart = serializers.CharField(source=\u0026#39;depart.title\u0026#39;) ctime = serializers.DateTimeField(format=\u0026#39;%Y-%m-%d\u0026#39;) class Meta: model = models.UserInfo # fields = \u0026#39;__all__\u0026#39; fields = [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gender\u0026#39;, \u0026#39;gender_text\u0026#39;, \u0026#39;depart\u0026#39;, \u0026#39;ctime\u0026#39;] 我们已经能做到获取数据库中任何我们想要的数据，那我们可以添加非数据库字段吗？\n11.1.3.4 自定义方法 1 2 3 4 5 xxx = serializers.SerializerMethodField() # 当定义了一个名为xxx的SerializerMethodField字段时，会寻找get_xxx方法，将其返回值作为该字段的值 def get_xxx(self, obj): return \u0026#34;123\u0026#34; + obj.name # 传入的obj为每次循环的数据库对象，obj.name即可获取对应的数据库内的数据 11.1.4 嵌套与继承 老样子，先拓展一下我们的数据表，添加一个标签，让它与用户构建多对多的关系\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from django.db import models # Create your models here. class Depart(models.Model): title = models.CharField(verbose_name=\u0026#34;部门\u0026#34;, max_length=32) order = models.IntegerField(verbose_name=\u0026#34;顺序\u0026#34;) count = models.IntegerField(verbose_name=\u0026#34;人数\u0026#34;) class Tag(models.Model): caption = models.CharField(verbose_name=\u0026#34;标签\u0026#34;, max_length=32) class UserInfo(models.Model): name = models.CharField(verbose_name=\u0026#34;姓名\u0026#34;, max_length=32) age = models.IntegerField(verbose_name=\u0026#34;年龄\u0026#34;) gender = models.SmallIntegerField(verbose_name=\u0026#34;性别\u0026#34;, choices=((1, \u0026#34;男\u0026#34;), (2, \u0026#34;女\u0026#34;))) depart = models.ForeignKey(verbose_name=\u0026#34;部门\u0026#34;, to=\u0026#34;Depart\u0026#34;, on_delete=models.CASCADE) ctime = models.DateTimeField(verbose_name=\u0026#34;时间\u0026#34;, auto_now_add=True) tags = models.ManyToManyField(verbose_name=\u0026#34;标签\u0026#34;, to=\u0026#34;Tag\u0026#34;) 然后创建并应用迁移对象实现对数据库的操作\n添加如下数据以便后续测试\n11.1.4.1 嵌套 那么需求来了，我们如何返回一个用户对应的所有标签呢？\n最大的Queryset对象存放的是一个一个的用户对象obj，obj.tags.all()即可获得所有的标签对象[Tag1,Tag2,\u0026hellip;.]\n那么思路有了我们就可以用上面学会的自定义方法实现\n1 2 3 4 def get_xxx(self, obj): queryset = obj.tags.all() result = [{\u0026#34;id\u0026#34;: tag.id, \u0026#34;caption\u0026#34;: tag.caption} for tag in queryset] return result 我们通过自定义方法可以实现该需求，但仍需要自己书写逻辑，其实DRF的序列化支持嵌套，下面就来看看如何利用嵌套实现\n如上图，一个序列化器可以嵌套子序列化器，子序列化器中的操作与上一节介绍的无异，支持自定义字段，自定义方法等等，这样就快捷地实现了我们的需求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class D1(serializers.ModelSerializer): class Meta: model = models.Depart fields = [\u0026#34;id\u0026#34;, \u0026#34;title\u0026#34;] class D2(serializers.ModelSerializer): ex = serializers.SerializerMethodField() class Meta: model = models.Tag fields = [\u0026#34;caption\u0026#34;, \u0026#34;ex\u0026#34;] def get_ex(self, obj): return \u0026#34;xxx\u0026#34; class UserSerializer(serializers.ModelSerializer): depart = D1() tags = D2(many=True) class Meta: model = models.UserInfo fields = [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#34;depart\u0026#34;, \u0026#34;tags\u0026#34;] 总结：一般在有foreignkey或者manytomany时使用\n11.1.4.2 继承 如上图，Base序列化器定义了一个xx字段，而UserSerializer序列化器继承了Base，就可以直接使用xx字段\n1 2 3 4 5 6 7 8 class Base(serializers.Serializer): xx = serializers.CharField(source=\u0026#34;name\u0026#34;) class UserSerializer(serializers.ModelSerializer, Base): class Meta: model = models.UserInfo fields = [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#34;xx\u0026#34;] 至此，序列化数据的实现就已经全部介绍了，经过上面的学习，我们应该能够具备，无论是数据库中任何表结构关系，获取到模型对象或者是QuerySet时，可以将其进行序列化转为JSON数据返回\n11.2 源码流程 11.2.1 流程概述 第一步：加载字段，创建类\n1 2 class BaseSerializer(serializers.Serializer): xx = serializers.CharField(source=\u0026#34;name\u0026#34;) 在类成员中提取出xx字段并删除 汇总到 BaseSerializer._declared_fields = {\u0026quot;xx\u0026quot;:对象} 1 2 3 4 5 6 class UserSerializer(serializers.ModelSerializer, BaseSerializer): yy = serializers.CharField(source=\u0026#34;name\u0026#34;) class Meta: model = models.UserInfo fields = [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#34;yy\u0026#34; ,\u0026#34;xx\u0026#34;] 在类成员中提取出yy字段并删除 将自己即继承类中的字段都汇总到UserSerializer._declared_fields = {\u0026quot;yy\u0026quot;:对象,\u0026quot;xx\u0026quot;:对象,\u0026quot;name\u0026quot;:对象...} 第二步：序列化\n1 2 queryset = models.UserInfo.objects.all() ser = UserSerializer(queryset, many=True) # ListSerizlizer对象。循环queryset中的每一个对象，对其调用UserSerializer进行实例化 db-\u0026gt;queryset = [{id:xxx,name:xxx,age:xxx},{id:xxx,name:xxx,age:xxx},]\n1 2 instance = models.UserInfo.objects.all().first() ser = UserSerializer(instance, many=False) # UserSerializer对象 db-\u0026gt;instance = {id:xxx,name:xxx,age:xxx}\n序列化过程\ninstance = models.UserInfo.objects.all().first() ser = UserSerializer(instance, many=False) 当执行ser.data时触发 内部寻找对应关系 将UserSerializer._declared_fields中的字段与从数据库中的查到的数据的模型类字段一一对应 逐一进行序列化 11.2.2 创建字段对象 首先来思考一个问题\n1 2 3 4 5 class Foo(object,metaclass=type): v1 = 123 def func(self): return 999 上述代码的类，在创建时，是先加载字段v1和func还是先创建Foo这个类\n如果看不出来，我们不妨换个形式\n1 Foo = type(\u0026#34;Foo\u0026#34;, (object,), {\u0026#34;v1\u0026#34;: 123, \u0026#34;func\u0026#34;: lambda self: 999}) 现在想必很清晰了，一定是先加载完v1,func这两个字段，才能把他们当成参数传递给type去创建Foo类\n因此对于下列代码\n1 2 3 4 class InfoSerializer(serializers.Serializer): id = serializers.IntegerField() title = serializers.CharField() order = serializers.IntegerField 一定也是先加载id，title，order三个字段再实例化IntegerField()对象\u0026hellip;\n所以我们先来看DRF创建字段对象的源码实现(精简版，用于理解实现逻辑)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Field: _creation_counter = 0 def __init__(self, ...): self._creation_counter = Field._creation_counter Field._creation_counter += 1 class IntegerField(Field): def __init__(self, **kwargs): self.max_value = 111 super().__init__(**kwargs) class CharField(Field): def __init__(self, **kwargs): self.allow_blank = Flase super().__init__(**kwargs) class InfoSerializer(serializers.Serializer): id = serializers.IntegerField() # {max_value:111, _creation_counter:0} title = serializers.CharField() # {allow_blank:False, _creation_counter:1} order = serializers.IntegerField # {max_value:111, _creation_counter:2} id = serializers.IntegerField()在执行时，会实例化一个IntegerField对象，先调用自己的__init__方法给自己的实例空间写入值，如max_value，再调用父类Field的__init__方法，实现_creation_counter=0，同时将Field的类变量+1，即Field._creation_counter = 1\ntitle = serializers.CharField()在执行时，会实例化一个CharField对象，逻辑同上，但是他的_creation_counter=1，Field._creation_counter = 2\norder = serializers.IntegerField同理，_creation_counter=2，Field._creation_counter = 3\n如果还有其他XXSerializer类，他的字段也会接着给自己的_creation_counter赋值并且使类变量自增\n到这里想必大家都意识到了，Field类相当于维护了一个计数器，给每一个字段赋予了创建的顺序，意义何在？\n就是让后续开发时，根据字段创建的顺序，来决定源码处理的顺序(python3.6之前字典是无序的，因此需要这样一个逻辑)\n所以想让那个字段先处理，就把他的位置写的上面一些，例如密码password与确认密码confirm_password就需要这样一个先后关系\n11.2.3 创建类 上一小节中我们已经了解了字段对象的创建逻辑，那么在字段加载完成后，字段将会被作为参数传递进去创建InfoSerializer类\nInfoSerializer类的父类是Serializer类，该类在创建时指定了metaclass=SerializerMetaclass，由元类的知识我们知道，一旦Serializer指定了metaclass=SerializerMetaclass，那么其所有的子类在创建时都将指定元类为SerializerMetaclass，因此不管是继承的Serializer还是ModelSerializer，最终都由元类SerializerMetaclass创建\n下面我们就来看看SerializerMetaclass是怎么创建类的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class SerializerMetaclass(type): @classmethod def _get_declared_fields(cls, bases, attrs): # 1.1 列表推导式构建自己类的字段对象列表fields fields = [(field_name, attrs.pop(field_name)) for field_name, obj in list(attrs.items()) if isinstance(obj, Field)] # 1.2 排序 fields.sort(key=lambda x: x[1]._creation_counter) known = set(attrs) def visit(name): known.add(name) return name # 1.3 列表推导式构建父类的字段列表base_fields base_fields = [ # 将未重复的字段和实例添加到base_fields中，同时将字段标记为已添加 (visit(name), f) # 遍历父类，拿到子u但名称f和字段实例f for base in bases if hasattr(base, \u0026#39;_declared_fields\u0026#39;) for name, f in base._declared_fields.items() if name not in known ] # 1.4 将父类字段与自己的字段合并列表返回 return OrderedDict(base_fields + fields) def __new__(cls, name, bases, attrs): # 1.在attrs中新增_declared_fields字段用于存储自己的字段对象和父类的字段对象 attrs[\u0026#39;_declared_fields\u0026#39;] = cls._get_declared_fields(bases, attrs) # 2.再调用type的__new__创建类 return super().__new__(cls, name, bases, attrs) # 该类在创建时attr一共是五个值，一个整型三个字段对象和一个类 class InfoSerializer(serializers.Serializer): v1 = 123 id = serializers.IntegerField() title = serializers.CharField() order = serializers.IntegerField class Meta: 1.1 列表推导式构建自己类的字段列表fields 1 attrs --\u0026gt; {\u0026#34;v1\u0026#34;:123,\u0026#34;id\u0026#34;:IntegerField对象,\u0026#34;title\u0026#34;:CharField对象,...} 循环获取字段名field_name和字段值obj，如果obj是Field的子类，则构建元组加入fields列表，同时在attrs中剔除，\n因此循环结束后\n1 2 attrs --\u0026gt; {\u0026#34;v1\u0026#34;:123,\u0026#34;Meta\u0026#34;:对象} fields = [(\u0026#34;id\u0026#34;,对象),(\u0026#34;title\u0026#34;,对象),(\u0026#34;order\u0026#34;,对象)] 1.2 排序 还记得上一节创建字段对象时的那个计数器吗？这一步的排序便是依据各个字段对象内的_creation_counter大小进行排序\n1.3 列表推导式构建父类的字段列表base_fields 循环父类的_declared_fields，将当前类没有的字段添加到列表base_fields中\n1.4 将父类字段与自己的字段合并列表返回 简单的将两个列表相加返回，再调用type的__new__实现类的创建\n11.2.4 实例化类 创建对象以及前置的加载字段都是在django项目运行时就执行的，而当请求到来时，视图函数从数据库获取数据并序列化，此时就来到了实例化类的过程\n1 2 3 4 5 queryset = models.UserInfo.objects.all() ser = UserSerializer(queryset, many=True) instance = models.UserInfo.objects.all().first() ser = UserSerializer(instance, many=False) 先讲解第二个，即单个对象的情况\n实例化类依次执行BaseSerializer类的__new__，根据many属性的值分为两路，当前情况时调用父类即Field的__new__方法，Field又调用object基类的__new__创建实例\n创建实例后，会调用 BaseSerializer 的 __init__ 方法来初始化实例\n根据序列化器类继承的不同，调用ModelSerializer或Serializer的get_fields方法，该处讲解前一个情况，根据模型字段生成序列化字段\n调用get_fields() 获取序列化器中定义的所有字段fields\n显示声明的字段declared_fields 根据模型字段转化成序列化字段添加到fields中 调用_init_fields 初始化字段，将字段绑定到序列化器实例上（调用Field类的bind方法）\nfield_name parent source字段 source_attrs字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class BaseSerializer(Field): def __new__(cls, *args, **kwargs): if kwargs.pop(\u0026#39;many\u0026#39;, False): return cls.many_init(*args, **kwargs) # many=Flase则走这条逻辑，即只处理单对象，则调用object基类的__new__创建对象，紧接着寻找__init__方法 return super().__new__(cls, *args, **kwargs) def __init__(self, instance=None, data=empty, **kwargs): # 存储传入的模型实例或查询集 self.instance = instance # 获取序列化器中定义的所有字段 self.fields = self.get_fields() # 初始化字段，将字段绑定到序列化器实例上（调用Field类的bind方法） self._init_fields() def _init_fields(self): for field_name, field in self.fields.items(): field.bind(field_name, self) class ModelSerializer(Serializer): def get_fields(self): # 获取在类定义中显式声明的字段，即前面提到的id,title,order declared_fields = copy.deepcopy(self._declared_fields) # 获取模型的字段信息，去 UserSerializer 中的 Meta 中找 model 字段，即 model = models.UserInfo model = getattr(self.Meta, \u0026#39;model\u0026#39;) # 返回一个包含模型字段和关系的详细信息的字典,包含了每个字段的详细信息，例如字段类型、是否是关系字段（如外键、多对多字段等）以及其他元数据 info = model_meta.get_field_info(model) # 根据 declared_fields 和 info 来确定最终的字段名称列表。这个方法可能会根据序列化器的配置和模型的字段信息来排除或包含某些字段 field_names = self.get_field_names(declared_fields, info) fields = OrderedDict() # 根据模型字段生成序列化字段 for field_name in field_names: # 根据字段的类型和属性来决定使用哪个序列化器字段类，以及如何配置这个字段 # 简单来说就是把数据库字段转成序列化器字段类如models.CharField类转成CharField类，然后放入fields中 field_class, field_kwargs = self.build_field( source, info, model, depth ) # Create the serializer field. fields[field_name] = field_class(**field_kwargs) # Add in any hidden fields. fields.update(hidden_fields) return fields class Field: def bind(self, field_name, parent): # 字段的名称，用于在序列化器中标识字段 self.field_name = field_name # 字段所属的序列化器实例 self.parent = parent # 字段的源名称，用于从模型实例中获取数据，默认情况下，source 与字段名称相同 if self.source is None: self.source = field_name if self.source == \u0026#39;*\u0026#39;: self.source_attrs = [] else: # 如果是外键跨表的形式如depart.title，就会被分割成一个列表 self.source_attrs = self.source.split(\u0026#39;.\u0026#39;) 返回的ser是UserSerializer序列化器实例，是一个复杂的对象，包含以下内容\ninstance：传入的模型实例（UserInfo 对象） data：序列化后的数据（通过访问 ser.data 获得） fields：序列化器中定义的所有字段 每个字段实例都有自己的属性和方法，例如： field_name：字段的名称。 parent：字段所属的序列化器实例。 source：字段的源名称，用于从模型实例中获取数据。 to_representation：将字段值转换为可序列化的格式。 to_internal_value：将输入数据转换为 Python 数据类型。 errors：如果序列化过程中发生错误，存储错误信息 ser.data 是序列化后的数据\n当你访问 ser.data 时，序列化器会将模型实例转换为一个 Python 字典 这个字典可以被进一步渲染为 JSON 格式，以便返回给客户端 如果是第一个，即多个对象的queryset的情况\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class BaseSerializer(Field): def __new__(cls, *args, **kwargs): # many=True，处理多对象，进入if内部，执行many_init方法 if kwargs.pop(\u0026#39;many\u0026#39;, False): return cls.many_init(*args, **kwargs) return super().__new__(cls, *args, **kwargs) def __init__(self, instance=None, data=empty, **kwargs): self.instance = instance @classmethod def many_init(cls, *args, **kwargs): child_serializer = cls(*args, **kwargs) # 实例化当前类（如 UserSerializer）的单个对象序列化器 # 创建一个字典，将 child_serializer 作为子序列化器传递给 ListSerializer list_kwargs = { \u0026#39;child\u0026#39;: child_serializer, } meta = getattr(cls, \u0026#39;Meta\u0026#39;, None) list_serializer_class = getattr(meta, \u0026#39;list_serializer_class\u0026#39;, ListSerializer) # Meta中可以定义，默认为ListSerializer return list_serializer_class(*args, **list_kwargs) # 实例化ListSerializer()，并将每一个UserSerializer对象传入 class ListSerializer(BaseSerializer): def __init__(self, *args, **kwargs): # 子序列化器实例，用于序列化每个对象 self.child = kwargs.pop(\u0026#39;child\u0026#39;) super().__init__(*args, **kwargs) 此时返回的就是不是UserSerializer对象了，而是ListSerializer对象，其实就是一个列表，列表内元素都是UserSerializer对象\n11.2.5 序列化过程 上一节我们介绍的实例化类对应的是ser = UserSerializer(queryset, many=True)这一行代码，此时只是将数据封装到对象中，真正触发序列化动作的是当ser.data\n11.2.5.1 UserSerializer类 我们先说当前类，即UserSerializer类触发序列化的情况\nser.data \u0026ndash;\u0026gt; Serializer中的data \u0026ndash;\u0026gt; BaseSerializer中的data \u0026ndash;\u0026gt; self._data = self.to_representation(self.instance)\n于是关键就是Serializer的to_representation方法，我们下面来分析：\n获取所有的字段fields = Serializer._readable_fields __\n__self._readable_fields读取Serializer.fields的值 循环所有的字段对象for field in fields:\n去数据库对象中依据字段的信息获取数据attribute = field.get_attribute(instance)\nbind方法处理过的source，如果是外键跨表的形式如depart.title，就会被分割成一个列表存入self.source_attrs\nField.get_attribute调用 get_attribute(instance, self.source_attrs)\nget_attribute循环source_attrs取出instance对应该source的值\n将获取到的数据通过序列化器类的to_representation方法转变一下格式加入ret中，如IntegerField会对数据进行int()转换等等ret[field.field_name] = field.to_representation(attribute)\n将ref返回\n精简版的源码，结合上述文字流程食用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 from django.contrib.gis.gdal.raster import source class BaseSerializer(Field): @property def data(self): if not hasattr(self, \u0026#39;_data\u0026#39;): if self.instance is not None and not getattr(self, \u0026#39;_errors\u0026#39;, None): # 真正实现序列化的步骤 self._data = self.to_representation(self.instance) elif hasattr(self, \u0026#39;_validated_data\u0026#39;) and not getattr(self, \u0026#39;_errors\u0026#39;, None): self._data = self.to_representation(self.validated_data) else: self._data = self.get_initial() return self._data class Serializer(BaseSerializer, metaclass=SerializerMetaclass): @property def data(self): ret = super().data return ReturnDict(ret, serializer=self) def to_representation(self, instance): ret = OrderedDict() # 1.获取所有的字段：先前加载的 InfoSerializer._declared_fields + Meta中指定的fields字段一一创建对象 fields = self._readable_fields # 2. 循环所有的字段对象(都是序列化器字段对象) for field in fields: # 去字段对象中依据字段的信息获取数据 attribute = field.get_attribute(instance) # 将获取到的数据通过序列化器类的to_representation方法转换为适合 JSON 序列化的格式加入ret中，如IntegerField会对数据进行int()转换等等 ret[field.field_name] = field.to_representation(attribute) return ret @property def _readable_fields(self): for field in self.fields.values(): yield field class Field: def __init__(self, ...source): self.source = source def get_attribute(self, instance): # 此处的source_attrs是source经过bind处理后的 # get_attribute就去instance中取出对应的值，如列表[\u0026#34;depart\u0026#34;,\u0026#34;title\u0026#34;]，会循环去取值，返回instance.depart.title return get_attribute(instance, self.source_attrs) # 根据sourse和instance取得对应的值 def get_attribute(instance, attrs): for attr in attrs: try: if isinstance(instance, Mapping): instance = instance[attr] else: instance = getattr(instance, attr) except ObjectDoesNotExist: return None if is_simple_callable(instance): try: instance = instance() except (AttributeError, KeyError) as exc: # If we raised an Attribute or KeyError here it\u0026#39;d get treated # as an omitted field in `Field.get_attribute()`. Instead we # raise a ValueError to ensure the exception is not masked. raise ValueError( \u0026#39;Exception raised in callable attribute \u0026#34;{}\u0026#34;; original exception was: {}\u0026#39;.format(attr, exc)) return instance class IntegerField(Field): def __init__(self, **kwargs): self.max_value = 111 super().__init__(**kwargs) def to_representation(self, value): return int(value) class InfoSerializer(serializers.ModelSerializer): id = serializers.IntegerField() # {max_value:111, _creation_counter:0,source=\u0026#34;id\u0026#34;}source未定义默认为字段名 title = serializers.CharField() # {allow_blank:False, _creation_counter:1} order = serializers.IntegerField # {max_value:111, _creation_counter:2} class Meta: model = models.Depart fields = \u0026#34;__all__\u0026#34; 11.2.5.2 ListSerializer类 如果已经了解了UserSerializer类的序列化过程，那么ListSerializer类的序列化只是在他的基础上多了一个循环\nser.data \u0026ndash;\u0026gt; ListSerializer中的data \u0026ndash;\u0026gt; BaseSerializer中的data \u0026ndash;\u0026gt; self._data = self.to_representation(self.instance)\n但是此时的to_representation优先找的是ListSerializer类中自己定义的的\n我们先看一下ListSerializer类是如何实例化的\n1 2 3 4 5 6 7 8 9 @classmethod def many_init(cls, *args, **kwargs): child_serializer = cls(*args, **kwargs) # 实例化UserSerializer对象 list_kwargs = { \u0026#39;child\u0026#39;: child_serializer, } meta = getattr(cls, \u0026#39;Meta\u0026#39;, None) list_serializer_class = getattr(meta, \u0026#39;list_serializer_class\u0026#39;, ListSerializer) # Meta中可以定义，默认为ListSerializer return list_serializer_class(*args, **list_kwargs) # 实例化ListSerializer()，并将每一个UserSerializer对象传入 可以看到，ListSerializer类中是一个个UserSerializer对象\n因此ListSerializer类在to_representation方法时循环每一个UserSerializer对象并调用它的to_representation方法，显然，就是一遍又一遍的重复我们上一小节分析的UserSerializer类序列化的过程，此处便不再叙述\n1 2 3 4 5 6 7 8 class ListSerializer(BaseSerializer): def to_representation(self, data): iterable = data.all() if isinstance(data, models.Manager) else data return [ self.child.to_representation(item) for item in iterable ] 11.3 数据校验 路由 -\u0026gt; 视图 -\u0026gt; request.data -\u0026gt; 校验(序列化器的类) -\u0026gt; 操作数据\n接口设计的小规范：\n1 2 3 4 5 6 获取数据： api/v1/user/\t-\u0026gt;GET请求\t-\u0026gt;获取数据列表\tmodels.UserInfo.objects.all() api/v1/user/2/\t-\u0026gt;GET请求\t-\u0026gt;获取单个数据\tmodels.UserInfo.objects.filter(id=2).first() api/v1/user\t-\u0026gt;POST请求 -\u0026gt;新增数据 api/v1/user/3/\t-\u0026gt;PUT请求\t-\u0026gt;更新数据 下面我们就先看看序列化器的数据校验功能\n11.3.1 基本校验 序列化器中定义好字段，当请求到达时，视图函数获取到请求数据，将数据传递到序列化器中进行校验，利用if语句，如果校验通过，返回数据，不通过，返回错误信息\n还有第二种写法，在校验时传入raise_exception=True参数，校验通过则程序自动向下执行，不通过则抛出异常，由APIView类的dispatch方法接收异常处理\n建议采用第一种方式，因为可以自己控制异常的处理，如更改错误信息等，而方式二会由DRF处理，不可控\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class DepartSerializer(serializers.Serializer): username = serializers.CharField(required=True) password = serializers.CharField(required=True) class DepartView(APIView): def post(self, request, *args, **kwargs): # 1.获取原始数据 # print(request.data) # 2.校验(写法一) ser = DepartSerializer(data=request.data) if ser.is_valid(): print(ser.validated_data) else: print(ser.errors) # 校验(写法二) # ser = DepartSerializer(data=request.data) # ser.is_valid(raise_exception=True) # print(ser.validated_data) return Response(\u0026#34;...\u0026#34;) 11.3.2 内置和正则校验 上一小节我们学习了数据校验的基本格式，但对传递来的数据的限制仅仅是非空，当需求增加时，我们需要对字段有更严格的控制，就需要用到更多序列化器内置的要求以及使用正则自定义格式校验\n如下，title字段定义了最大长度和最小长度，order定义了最大值和最小值，level字段则是给出了choices，只可选择1或2(输入整形还是字符串并不影响)。这几个校验是序列化器内置的\n除此之外我们还可以子定义正则校验，代码中email1和email2使用的正则表达式相同，是DRF给我们封装好的，而email3就是我们通过自己写正则表达式创建的规则，并且可以定制错误信息\n1 2 3 4 5 6 7 8 9 10 11 12 from django.core.validators import RegexValidator, EmailValidator class DepartSerializer(serializers.Serializer): title = serializers.CharField(required=True, max_length=20, min_length=6) order = serializers.IntegerField(required=False, max_value=100, min_value=10) level = serializers.ChoiceField(choices=[(\u0026#34;1\u0026#34;, \u0026#34;高级\u0026#34;), (2, \u0026#34;中级\u0026#34;)]) # email1 = serializers.EmailField() # email2 = serializers.CharField(validators=[EmailValidator(message=\u0026#34;邮箱格式错误\u0026#34;)]) email3 = serializers.CharField(validators=[RegexValidator(r\u0026#34;\\d+\u0026#34;, message=\u0026#34;格式错误\u0026#34;)]) 11.3.3 钩子校验 和Django中的Form和ModelForm类似，DRF的序列化器的数据校验也提供了每个字段的钩子方法和一个全局的钩子方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from rest_framework import exceptions email = serializers.CharField(validators=[RegexValidator(r\u0026#34;\\d+\u0026#34;, message=\u0026#34;格式错误\u0026#34;)]) def validate_email(self, value): print(value) if len(value) \u0026gt; 6: raise exceptions.ValidationError(\u0026#34;字段钩子校验失败\u0026#34;) return value def validate(self, attrs): print(\u0026#34;validate=\u0026#34;, attrs) # api_settings.NON_FIELD_ERRORS_KEY # raise exceptions.ValidationError(\u0026#34;全局钩子校验失败\u0026#34;) return attrs 每个字段的钩子方法以validate_字段名命令，而全局的钩子方法直接是validate方法，他会在各个字段的钩子方法校验完成后再对整体进行校验，因此传入的attr是所有字段和值组成的有序字典，而单个字段钩子方法的value是单个字段的值\n总的钩子方法的错误信息也与字段的钩子不同\n它的错误信息的键默认是non_field_errors，可以通过api_settings.NON_FIELD_ERRORS_KEY进行配置，如：\n即可实现自定义错误信息的键\n11.3.4 Model校验 上面我们实现数据校验一直是使用Serializer类，所有的字段都需要我们自己编写，如果用到的字段大多都是将数据库中的字段，那么就可以采用ModelSerializer来自动生成字段\n1 2 3 4 5 6 7 8 9 10 11 class DepartModelSerializer(serializers.ModelSerializer): email3 = serializers.CharField(validators=[RegexValidator(r\u0026#34;\\d+\u0026#34;, message=\u0026#34;格式错误\u0026#34;)]) class Meta: model = models.Depart fields = [\u0026#39;title\u0026#39;, \u0026#39;order\u0026#39;, \u0026#39;count\u0026#39;, \u0026#39;email3\u0026#39;] extra_kwargs = { \u0026#39;title\u0026#39;: {\u0026#34;max_length\u0026#34;: 5, \u0026#34;min_length\u0026#34;: 1}, \u0026#39;order\u0026#39;: {\u0026#34;min_value\u0026#34;: 5}, \u0026#39;count\u0026#39;: {\u0026#34;validators\u0026#34;: [RegexValidator(r\u0026#34;\\d+\u0026#34;, message=\u0026#34;格式错误\u0026#34;)]} } 只需要在class Meta的fiedls填入需要生成的字段即可，若还需要自定义字段就像Serializer类一样自定义，然后加入到fields列表中即可\n采用这种方式不需要我们自己编写字段，那么校验规则怎么添加呢？\n只需要在class Meta中extra_kwargs字典中编写即可，示例如上\n11.3.5 保存数据之普通字段 如果采用的是Serializer类的序列化器，那么在保存数据时需要手动的进行ORM操作保存数据，但如果使用了\nModelSerializer类的序列化器，就可以使用.save实现便捷操作，他会一键保存到数据库对应的表中\n但是问题来了?如果用户传入的字段数大于或小于数据表对应的字段数，我们能不能手动调整？答案是肯定的\n字段过多，如下述例子，email3是多余字段，不需要存入数据库，我们可以在进行.save之前将其pop掉，用一个变量接收，可用于后续判断。该操作可用于注册时的重复输入密码步骤\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class DepartModelSerializer(serializers.ModelSerializer): email3 = serializers.CharField(validators=[RegexValidator(r\u0026#34;\\d+\u0026#34;, message=\u0026#34;格式错误\u0026#34;)]) class Meta: model = models.Depart fields = [\u0026#39;title\u0026#39;, \u0026#39;order\u0026#39;, \u0026#39;count\u0026#39;, \u0026#39;email3\u0026#39;] extra_kwargs = { \u0026#39;title\u0026#39;: {\u0026#34;max_length\u0026#34;: 5, \u0026#34;min_length\u0026#34;: 1}, \u0026#39;order\u0026#39;: {\u0026#34;min_value\u0026#34;: 5}, \u0026#39;count\u0026#39;: {\u0026#34;validators\u0026#34;: [RegexValidator(r\u0026#34;\\d+\u0026#34;, message=\u0026#34;格式错误\u0026#34;)]} } class DepartView(APIView): def post(self, request, *args, **kwargs): ser = DepartModelSerializer(data=request.data) if ser.is_valid(): print(\u0026#34;视图\u0026#34;, ser.validated_data) email3 = ser.validated_data.pop(\u0026#39;email3\u0026#39;) ser.save() else: print(ser.errors) return Response(\u0026#34;...\u0026#34;) 字段过少，比如创建用户时数据库中要添加操作人id，这显然不是用户输入的，所以我们就需要手动添加数据\n下列代码中数据库有count字段，但前端用户并未输入，因此便可以在.save时将count字段作为参数传入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class DepartModelSerializer(serializers.ModelSerializer): class Meta: model = models.Depart fields = [\u0026#39;title\u0026#39;, \u0026#39;order\u0026#39;] extra_kwargs = { \u0026#39;title\u0026#39;: {\u0026#34;max_length\u0026#34;: 5, \u0026#34;min_length\u0026#34;: 1}, \u0026#39;order\u0026#39;: {\u0026#34;min_value\u0026#34;: 5}, } class DepartView(APIView): def post(self, request, *args, **kwargs): ser = DepartModelSerializer(data=request.data) if ser.is_valid(): print(\u0026#34;视图\u0026#34;, ser.validated_data) ser.save(count=11) else: print(ser.errors) return Response(\u0026#34;...\u0026#34;) 11.3.6 保存数据之FK和M2M字段 上一小节我们介绍了普通字段的保存，但是还有两种比较特殊的字段，如果是ForeignKey字段和ManytoMany字段，该怎么进行保存\n我们先看FK\n如图，depart是一个FK，关联到职位表，用户在输入时实际上输入的是职位的id，如果id不存在就会报错。如果需求升级，就算该职位存在，还要做进一步校验，就需要我们的钩子方法，在钩子中，value值其实已经是用户传入的id对应的depart对象了，我们就可以对对象进行操作、校验\n然后我们来看M2M的情况\ntags是一个M2M，关联userinfo和tags表，用户传入一个列表，1和2对应tags表的id，表示当前创建用户与id=1和id=2的标签都有关联，于是在userinfo_tags表中生成两条记录\n此时，钩子方法中的value是一个列表，每一个元素都是传入的id对应的tags对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class UsModelSerializer(serializers.ModelSerializer): class Meta: model = models.UserInfo fields = [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gender\u0026#39;, \u0026#39;depart\u0026#39;, \u0026#39;tags\u0026#39;] class USView(APIView): def post(self, request, *args, **kwargs): ser = UsModelSerializer(data=request.data) if ser.is_valid(): print(\u0026#34;视图\u0026#34;, ser.validated_data) ser.save() else: print(ser.errors) return Response(\u0026#34;...\u0026#34;) 在FK的那个示例中，字段名为depart，但我们传入的实际上是depart_id，那么如果直接在fields中写depart_id而不是depart会发生什么呢?\nModelSerializer在处理数据库字段时其实并没有depart_id这个字段，他只有一个FK字段叫depart，所以他会报错，但是我们可以通过自定义的方式就可以实现\n1 2 3 4 5 6 class UsModelSerializer(serializers.ModelSerializer): depart_id = serializers.IntegerField() class Meta: model = models.UserInfo fields = [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gender\u0026#39;, \u0026#39;depart_id\u0026#39;, \u0026#39;tags\u0026#39;] 在M2M字段中，用户输入的是存放tags对象的id列表，而到达钩子方法是存放tags对象的列表，那么我们能不能自定义，让他传入钩子时就是用户输入的存放tags对象的id列表，然后可以进一步做操作，最后返回的还是存放tags对象的列表，使保存数据的功能不受影响\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class UsModelSerializer(serializers.ModelSerializer): tags = serializers.ListField() class Meta: model = models.UserInfo fields = [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gender\u0026#39;, \u0026#39;depart\u0026#39;, \u0026#39;tags\u0026#39;] def validated_tags(self, value): print(value) queryset = models.Tag.objects.filter(id__in=value) return queryset class USView(APIView): def post(self, request, *args, **kwargs): ser = UsModelSerializer(data=request.data) if ser.is_valid(): print(\u0026#34;视图\u0026#34;, ser.validated_data) ser.save() else: print(ser.errors) return Response(\u0026#34;...\u0026#34;) 11.3.7 数据校验总结 自定义 Serializer + 字段 自定义 Serializer + 字段（内置加正则） 自定义 Serializer + 字段（内置加正则）+ 字段钩子 + 全局钩子 自定义 ModelSerializer + 自定义字段 + extra_kwargs + save保存数据（字段多：pop；字段少：参数传入） 自定义 ModelSerializer + FK -\u0026gt; 自动获取关联数据 depart -\u0026gt; 自定义depart_id字段 自定义 ModelSerializer + M2M -\u0026gt; 获取关联数据 -\u0026gt; ListField或DictField + 钩子 11.3.8 校验和序列化二合一 序列化与数据校验结合\n创建用户 : {\u0026ldquo;user\u0026rdquo;:\u0026ldquo;xxx\u0026rdquo;,\u0026ldquo;password\u0026rdquo;:\u0026ldquo;xxx\u0026rdquo;}\n数据校验 连接数据库，保存数据，并返回数据库对象 为什么不直接返回创建用户时传递的 {\u0026ldquo;user\u0026rdquo;:\u0026ldquo;xxx\u0026rdquo;,\u0026ldquo;password\u0026rdquo;:\u0026ldquo;xxx\u0026rdquo;} 因为数据库有些字段时自动生成的，只有返回数据库对象才能保证数据的完整 将数据库对象序列化再返回 11.3.8.1 两个序列化器分别实现 我们在数据校验开头部分就提出过这种需求，当数据校验通过存入数据库，还需将创建的数据库对象经过序列化返回回去，现在我们就来看看这个实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class DpModelSerializer(serializers.ModelSerializer): class Meta: model = models.Depart fields = \u0026#34;__all__\u0026#34; class Dp2ModelSerializer(serializers.ModelSerializer): class Meta: model = models.Depart fields = [\u0026#34;id\u0026#34;, \u0026#34;title\u0026#34;, \u0026#34;count\u0026#34;] class DpView(APIView): def post(self, request, *args, **kwargs): ser = DpModelSerializer(data=request.data) if ser.is_valid(): instance = ser.save() print(instance) xx = Dp2ModelSerializer(instance=instance) return Response(xx.data) else: return Response(ser.errors) 上述代码在数据校验时使用DpModelSerializer，校验通过保存到数据库，ser.save()会返回存入数据库的对象，用instance接收，再\n传递给完成序列化功能的Dp2ModelSerializer，实现需求\n11.3.8.2 一个序列化器实现 这样分开写两个序列化器感觉有点繁杂，可以使用一个吗？答案是可以的，但是返回序列化时返回给用户的也是数据库中的所有字段，因为fields = \u0026quot;__all__\u0026quot;\n可以只使用一个序列化器，实现数据校验保存数据时校验保存所有字段，但是序列化返回时只返回三个字段吗？这时候就要用到字段的两个特殊参数read_only和write_only\n1 2 3 4 5 6 7 8 class DpModelSerializer(serializers.ModelSerializer): class Meta: model = models.Depart fields = [\u0026#34;id\u0026#34;, \u0026#34;title\u0026#34;, \u0026#34;order\u0026#34;, \u0026#34;count\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, \u0026#34;count\u0026#34;: {\u0026#34;write_only\u0026#34;: True}, } 上述代码实现在输入时只需要输入title、order、count三个字段，在返回给用户时只返回id、title、order三个字段。完成共用一个序列化器实现数据校验保存和数据序列化字段的灵活自定义。可以应用在用户注册时，在注册时需要用户输入密码，但是返回数据展示时不会将密码返回\n上面我们已经实现了控制哪些字段返回，但是返回的格式还需要进一步操作。例如对于一个choices的gender字段，返回时是返回数据中真实存储的1或2吗，显然不是，而应该是对应的男和女。同样的还有FK字段depart，我们应该单单返回一个depart_id吗？显然也不是，而是应该将其depart_title或其他信息返回，这应该怎么实现呢？\nchoices字段 方式一：自定义一个gender_info字段获取男或女的文字信息，然后将gender_info和gender字段分别设置read_only和write_only\n1 2 3 4 5 6 7 8 9 10 class UusModelSerializer(serializers.ModelSerializer): gender_info = serializers.CharField(source=\u0026#34;get_gender_display\u0026#34;, read_only=True) class Meta: model = models.UserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;gender\u0026#34;, \u0026#34;depart\u0026#34;, \u0026#34;gender_info\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, \u0026#34;gender\u0026#34;: {\u0026#34;write_only\u0026#34;: True} } 方式二：自定义一个方法字段（自带read_only），返回一个字典，包含多个信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 class UusModelSerializer(serializers.ModelSerializer): v1 = serializers.SerializerMethodField() class Meta: model = models.UserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;gender\u0026#34;, \u0026#34;depart\u0026#34;, \u0026#34;v1\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, \u0026#34;gender\u0026#34;: {\u0026#34;write_only\u0026#34;: True} } def get_v1(self, obj): return {\u0026#34;id\u0026#34;: obj.gender, \u0026#34;text\u0026#34;: obj.get_gender_display()} FK字段 方式一：自定义字段加read_only，指定source关联外键数据\n1 2 3 4 5 6 7 8 9 10 class UusModelSerializer(serializers.ModelSerializer): v1 = serializers.CharField(source=\u0026#34;depart.title\u0026#34;, read_only=True) class Meta: model = models.UserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;gender\u0026#34;, \u0026#34;depart\u0026#34;, \u0026#34;v1\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, \u0026#34;depart\u0026#34;: {\u0026#34;write_only\u0026#34;: True} } 方式二：利用序列化器的嵌套\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class P1ModelSerializer(serializers.ModelSerializer): class Meta: model = models.Depart fields = \u0026#34;__all__\u0026#34; class UusModelSerializer(serializers.ModelSerializer): v1 = P1ModelSerializer(read_only=True, source=\u0026#34;depart\u0026#34;) class Meta: model = models.UserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;gender\u0026#34;, \u0026#34;depart\u0026#34;, \u0026#34;v1\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, \u0026#34;depart\u0026#34;: {\u0026#34;write_only\u0026#34;: True} } 如果是二合一的形式，视图函数中可以进一步缩写\n1 2 3 4 5 6 7 8 9 class UusView(APIView): def post(self, request, *args, **kwargs): ser = UusModelSerializer(data=request.data) if ser.is_valid(): ser.save() return Response(ser.data) else: return Response(ser.errors) 不需要重复指定数据校验和序列化数据的序列化器，只需如上编写即可实现同样的功能\n11.3.9 拓展 现在有一个需求，要求编写一个序列化类，实现创建用户\n提供：{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;xsss\u0026rdquo;,\u0026ldquo;age\u0026rdquo;:\u0026ldquo;11\u0026rdquo;,\u0026ldquo;gender\u0026rdquo;:1}\n返回：{\u0026ldquo;id\u0026rdquo;=1,\u0026ldquo;name\u0026rdquo;:\u0026ldquo;xsss\u0026rdquo;,\u0026ldquo;gender\u0026rdquo;:\u0026ldquo;男\u0026rdquo;}\nmodel类如下\n1 2 3 4 class NbUserInfo(models.Model): name = models.CharField(verbose_name=\u0026#34;姓名\u0026#34;, max_length=32) age = models.IntegerField(verbose_name=\u0026#34;年龄\u0026#34;) gender = models.SmallIntegerField(verbose_name=\u0026#34;性别\u0026#34;, choices=((1, \u0026#34;男\u0026#34;), (2, \u0026#34;女\u0026#34;))) 我们上面学习的对choices的处理，都是要新定义一个字段来展示男/女，但需求中不管是提供的字段还是返回的字段都叫gender，显然不是我们原先学习的方法可以实现的\n重点就是要将返回的gender设置为男/女\n如果我们自定义一个名为gender的SerializerMethodField字段，然后在里面去调用get_gender_display，输出是符合要求了，但是SerializerMethodField字段默认是read_only，会导致传过来的gender失效，即用户无法输入了\n如果定义成其他类型的字段，没有read_only，用户可以输入了，但是get_gender的钩子又不执行了，导致输出还是1/2\n可以发现，上面两种实现都只实现了一半功能，那没有可能将他们组合起来呢？\n这就需要我们了解SerializerMethodField字段到底是如何实现钩子的？\n1 2 3 4 5 6 7 8 9 10 11 # 序列化 ser = NbModelSerializer(instance=对象) ser.data # 数据校验+序列化 ser = NbModelSerializer(data=request.data) if ser.is_valid(): ser.save() ser.data # 关键就是ser.data 真正的序列化动作发生在ser.data触发时\nSerializerMethodField字段与其他字段的不同在于：\n类变量维护了一个method_name默认等于None 在实例化前执行bind方法method_name赋值为\u0026rsquo;get_{field_name}' 最后调用to_representation方法处理值时会找到父类的get_{field_name}，返回钩子方法的返回值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class BaseSerializer(Field): @property def data(self): self._data = self.to_representation(self.instance) return self._data class Serializer(BaseSerializer, metaclass=SerializerMetaclass): @property def data(self): ret = super().data return ReturnDict(ret, serializer=self) @property def _readable_fields(self): for field in self.fields.values(): if not field.write_only: yield field def to_representation(self, instance): ret = OrderedDict() # [CharField字段对象，SerializerMethodField字段对象(比其他普通字段多维护了一个method_name)...] 有bind方法会先执行过 fields = self._readable_fields # 找到所有字段，筛选出可读的（可序列化的） ==\u0026gt; 没有写write_only for field in fields: attribute = field.get_attribute(instance) # CharField.get_attribute(instance) ==\u0026gt; instance.字段.字段 (通过循环source列表) # SerializerMethodField.get_attribute(instance) ==\u0026gt; instance.xx ==\u0026gt; None (SerializerMethodField的source默认为*) ret[field.field_name] = field.to_representation(attribute) # CharField.to_representation 就是用str()包裹一下 # SerializerMethodField.to_representation 根据method_name去父类拿钩子方法 return ret class SerializerMethodField(Field): def __init__(self, method_name=None, **kwargs): self.method_name = method_name kwargs[\u0026#39;source\u0026#39;] = \u0026#39;*\u0026#39; kwargs[\u0026#39;read_only\u0026#39;] = True super().__init__(**kwargs) def bind(self, field_name, parent): # The method name defaults to `get_{field_name}`. if self.method_name is None: self.method_name = \u0026#39;get_{field_name}\u0026#39;.format( field_name=field_name) # method_name默认为None，到此处处理为\u0026#34;get_gender\u0026#34; super().bind(field_name, parent) def to_representation(self, value): method = getattr(self.parent, self.method_name) return method(value) class NbModelSerializer(serializers.ModelSerializer): gender = seriallizer.SerializerMethodField() class Meta: model = models.NbUserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;gender\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, } def get_gender(self, obj): return obj.get_gender_display() 明白了它是如何实现钩子方法之后，我们就可以将原先的两种方式进行结合，关键就在于对下面两条语句的拓展，因为他们决定了字段的实际值\nattribute = field.get_attribute(instance) ret[field.field_name] = field.to_representation(attribute) 11.3.9.1 方法一 我们通过自定义一个NbCharField字段，模仿SerializerMethodField维护一个method_name，并且找时机让他根据反射找到钩子并执行即可\n下列实现在__init__和__bind__中维护一个钩子方法，名为xget_字段名，然后在执行get_attribute时让他执行钩子，将1/2变为男/女，因为我们继承的是IntegerField，它的to_representation方法应该是用int()包裹attribute，而我们的attribute不是数字字符串，因此to_representation也需要重写，否则强加int()会报错，至此就完成了功能实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class NbCharField(serializers.IntegerField): def __init__(self, method_name=None, **kwargs): self.method_name = method_name super().__init__(**kwargs) def bind(self, field_name, parent): if self.method_name is None: self.method_name = \u0026#39;xget_{field_name}\u0026#39;.format(field_name=field_name) super().bind(field_name, parent) def get_attribute(self, instance): method = getattr(self.parent, self.method_name) return method(instance) def to_representation(self, value): return str(value) class NbModelSerializer(serializers.ModelSerializer): gender = NbCharField() class Meta: model = models.NbUserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;gender\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, } def xget_gender(self, obj): return obj.get_gender_display() class NbView(APIView): def post(self, request, *args, **kwargs): ser = NbModelSerializer(data=request.data) if ser.is_valid(): ser.save() return Response(ser.data) else: return Response(ser.errors) 可以看到，通过自定义一个字段的方式还是比较繁琐的\n11.3.9.2 方法二 方法一的本质是改变字段的get_attribute和to_representation方法来改变获取字段的值，而这两个方法都定义Serializer类的to_representation方法中，那么我们何不直接重写一个to_representation方法，使得当字段存在名为nb_字段名的钩子方法时，走我们自己的获取数据流程，而没有名为nb_字段名的钩子方法时，就按原本的逻辑走\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class NbModelSerializer(serializers.ModelSerializer): class Meta: model = models.NbUserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;gender\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, } def to_representation(self, instance): ret = OrderedDict() fields = self._readable_fields for field in fields: if hasattr(self, \u0026#39;nb_%s\u0026#39; % field.field_name): value = getattr(self, \u0026#34;nb_%s\u0026#34; % field.field_name)(instance) ret[field.field_name] = value else: try: attribute = field.get_attribute(instance) except SkipField: continue check_for_none = attribute.pk if isinstance(attribute, PKOnlyObject) else attribute if check_for_none is None: ret[field.field_name] = None else: ret[field.field_name] = field.to_representation(attribute) return ret def nb_gender(self, obj): return obj.get_gender_display() class NbView(APIView): def post(self, request, *args, **kwargs): ser = NbModelSerializer(data=request.data) if ser.is_valid(): ser.save() return Response(ser.data) else: return Response(ser.errors) 如果我们还有其他需要序列化器需要实现这个功能，是否需要在每一个序列化器中自定义一遍to_representation？\n我们可以将自定义的方法打包到一个类中，在需要实现该功能的序列化器类中继承即可\next/hook.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from collections import OrderedDict from rest_framework.fields import SkipField from rest_framework.relations import PKOnlyObject class NbHookSerializer(object): def to_representation(self, instance): ret = OrderedDict() fields = self._readable_fields for field in fields: if hasattr(self, \u0026#39;nb_%s\u0026#39; % field.field_name): value = getattr(self, \u0026#34;nb_%s\u0026#34; % field.field_name)(instance) ret[field.field_name] = value else: try: attribute = field.get_attribute(instance) except SkipField: continue check_for_none = attribute.pk if isinstance(attribute, PKOnlyObject) else attribute if check_for_none is None: ret[field.field_name] = None else: ret[field.field_name] = field.to_representation(attribute) return ret views.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from ext.hook import NbHookSerializer class NbModelSerializer(NbHookSerializer, serializers.ModelSerializer): class Meta: model = models.NbUserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;gender\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, } def nb_gender(self, obj): return obj.get_gender_display() class NbView(APIView): def post(self, request, *args, **kwargs): ser = NbModelSerializer(data=request.data) if ser.is_valid(): ser.save() return Response(ser.data) else: return Response(ser.errors) 11.4 博客系统案例 开发一个博客系统，包含：博客列表、详细、登录、注册、评论、点赞、发布博客\n11.4.1 表结构 项目的创建在此不赘述，翻看先前文章即可\n先创建表结构，models.py内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from django.db import models class UserInfo(models.Model): username = models.CharField(verbose_name=\u0026#34;用户名\u0026#34;, max_length=32, db_index=True) password = models.CharField(verbose_name=\u0026#34;密码\u0026#34;, max_length=64) token = models.CharField(verbose_name=\u0026#34;TOKEN\u0026#34;, max_length=64, null=True, blank=True,db_index=True) class Blog(models.Model): category_choices = ((1, \u0026#34;云计算\u0026#34;), (2, \u0026#34;Python全栈\u0026#34;), (3, \u0026#34;Go开发\u0026#34;)) category = models.IntegerField(verbose_name=\u0026#34;分类\u0026#34;, choices=category_choices) image = models.CharField(verbose_name=\u0026#34;封面\u0026#34;, max_length=255) title = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32) summary = models.CharField(verbose_name=\u0026#34;简介\u0026#34;, max_length=256) text = models.TextField(verbose_name=\u0026#34;博文\u0026#34;) ctime = models.DateTimeField(verbose_name=\u0026#34;创建时间\u0026#34;, auto_now_add=True) creator = models.ForeignKey(verbose_name=\u0026#34;创建者\u0026#34;, to=\u0026#34;UserInfo\u0026#34;, on_delete=models.CASCADE) comment_count = models.PositiveIntegerField(verbose_name=\u0026#34;评论数\u0026#34;, default=0) favor_count = models.PositiveIntegerField(verbose_name=\u0026#34;赞数\u0026#34;, default=0) class Favor(models.Model): \u0026#34;\u0026#34;\u0026#34; 赞 \u0026#34;\u0026#34;\u0026#34; blog = models.ForeignKey(verbose_name=\u0026#34;博客\u0026#34;, to=\u0026#34;Blog\u0026#34;, on_delete=models.CASCADE) user = models.ForeignKey(verbose_name=\u0026#34;用户\u0026#34;, to=\u0026#34;UserInfo\u0026#34;, on_delete=models.CASCADE) create_datetime = models.DateTimeField(verbose_name=\u0026#34;创建时间\u0026#34;, auto_now_add=True) class Meta: constraints = [ models.UniqueConstraint(fields=[\u0026#39;blog\u0026#39;, \u0026#39;user\u0026#39;], name=\u0026#39;uni_favor_blog_user\u0026#39;) ] class Comment(models.Model): \u0026#34;\u0026#34;\u0026#34; 评论表 \u0026#34;\u0026#34;\u0026#34; blog = models.ForeignKey(verbose_name=\u0026#34;博客\u0026#34;, to=\u0026#34;Blog\u0026#34;, on_delete=models.CASCADE) user = models.ForeignKey(verbose_name=\u0026#34;用户\u0026#34;, to=\u0026#34;UserInfo\u0026#34;, on_delete=models.CASCADE) content = models.CharField(verbose_name=\u0026#34;内容\u0026#34;, max_length=150) create_datetime = models.DateTimeField(verbose_name=\u0026#34;创建时间\u0026#34;, auto_now_add=True) 做一个数据库迁移\n1 2 makemigrations migrate 添加测试数据(可以采用离线脚本的形式，或者创建一个内容如下的接口，通过访问来创建)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from django.shortcuts import render, HttpResponse from api import models # Create your views here. def db(request): v1 = models.UserInfo.objects.create(username=\u0026#39;qwj\u0026#39;, password=\u0026#39;123\u0026#39;) v2 = models.UserInfo.objects.create(username=\u0026#39;xzq\u0026#39;, password=\u0026#39;123\u0026#39;) models.Blog.objects.create( category=1, image=\u0026#34;xxx/xxxx.pbg\u0026#34;, title=\u0026#39;郑经理\u0026#39;, summary=\u0026#39;...\u0026#39;, text=\u0026#39;说大话电话卡文化的哇\u0026#39;, creator=v1, ) models.Blog.objects.create( category=2, image=\u0026#34;xxx/xxxx.pbg\u0026#34;, title=\u0026#39;证据\u0026#39;, summary=\u0026#39;...\u0026#39;, text=\u0026#39;大家啊我到家啊五角大楼\u0026#39;, creator=v2, ) return HttpResponse(\u0026#34;成功\u0026#34;) 数据如下\n11.4.2 功能实现 11.4.2.1 博客列表 路由\n1 path(\u0026#39;api/blog/\u0026#39;, views.BlogView.as_view()), 视图类\n1 2 3 4 5 6 7 8 9 10 11 12 13 class BlogView(APIView): def get(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;获取博客列表\u0026#34;\u0026#34;\u0026#34; # 1.读取数据库中的博客信息 queryset = models.Blog.objects.all().order_by(\u0026#39;-id\u0026#39;) # 2.序列化 ser = BlogSerializer(queryset, many=True) # 3.返回 context = {\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data} return Response(context) 序列化器\n写法一：自定义字段 1 2 3 4 5 6 7 8 class BlogSerializer(serializers.ModelSerializer): category = serializers.CharField(source=\u0026#34;get_category_display\u0026#34;) ctime = serializers.DateTimeField(format=\u0026#34;%Y-%m-%d\u0026#34;) creator_name = serializers.CharField(source=\u0026#34;creator.username\u0026#34;) class Meta: model = models.Blog fields = [\u0026#34;category\u0026#34;, \u0026#34;image\u0026#34;, \u0026#34;title\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;ctime\u0026#34;, \u0026#34;comment_count\u0026#34;, \u0026#34;favor_count\u0026#34;, \u0026#34;creator\u0026#34;, \u0026#34;creator_name\u0026#34;] 写法二：自定义方法 1 2 3 4 5 6 7 8 9 10 11 class BlogSerializer(serializers.ModelSerializer): category = serializers.CharField(source=\u0026#34;get_category_display\u0026#34;) ctime = serializers.DateTimeField(format=\u0026#34;%Y-%m-%d\u0026#34;) creator = serializers.SerializerMethodField() class Meta: model = models.Blog fields = [\u0026#34;category\u0026#34;, \u0026#34;image\u0026#34;, \u0026#34;title\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;ctime\u0026#34;, \u0026#34;comment_count\u0026#34;, \u0026#34;favor_count\u0026#34;, \u0026#34;creator\u0026#34;] def get_creator(self, obj): return {\u0026#34;id\u0026#34;: obj.creator_id, \u0026#34;name\u0026#34;: obj.creator.username} 写法三：嵌套 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class BlogUserSerializers(serializers.ModelSerializer): class Meta: model = models.UserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;username\u0026#34;] class BlogSerializer(serializers.ModelSerializer): category = serializers.CharField(source=\u0026#34;get_category_display\u0026#34;) ctime = serializers.DateTimeField(format=\u0026#34;%Y-%m-%d\u0026#34;) creator = BlogUserSerializers() class Meta: model = models.Blog fields = [\u0026#34;category\u0026#34;, \u0026#34;image\u0026#34;, \u0026#34;title\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;ctime\u0026#34;, \u0026#34;comment_count\u0026#34;, \u0026#34;favor_count\u0026#34;, \u0026#34;creator\u0026#34;] 11.4.2.2 博客详细与评论 路由\n1 2 3 path(\u0026#39;api/blog/\u0026lt;int:pk\u0026gt;/\u0026#39;, views.BlogDetailView.as_view()), path(\u0026#39;api/comment/\u0026lt;int:blog_id\u0026gt;/\u0026#39;, views.CommentView.as_view()), # path(\u0026#39;api/comment/\u0026#39;, views.CommentView.as_view()), 获取博客评论的接口可以写成api/comment?blog_id=1，但是不太美观，建议使用api/comment/1然后在视图中接收\n博客详细\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class BlogDetailSerializers(serializers.ModelSerializer): category = serializers.CharField(source=\u0026#34;get_category_display\u0026#34;) ctime = serializers.DateTimeField(format=\u0026#34;%Y-%m-%d\u0026#34;) creator = BlogUserSerializers() class Meta: model = models.Blog fields = \u0026#34;__all__\u0026#34; class BlogDetailView(APIView): def get(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;获取博客详细\u0026#34;\u0026#34;\u0026#34; # 1.获取ID pk = kwargs.get(\u0026#39;pk\u0026#39;) # 2.根据ID获取对象 instance = models.Blog.objects.filter(id=pk).first() if not instance: return Response({\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: \u0026#34;不存在\u0026#34;}) # 3.序列化 ser = BlogDetailSerializers(instance, many=False) # 4.返回 context = {\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data} return Response(context) 评论\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class CommentSerializers(serializers.ModelSerializer): user = serializers.CharField(source=\u0026#34;user.username\u0026#34;) class Meta: model = models.Comment fields = [\u0026#34;id\u0026#34;, \u0026#34;content\u0026#34;, \u0026#34;user\u0026#34;] class CommentView(APIView): def get(self, request, blog_id): \u0026#34;\u0026#34;\u0026#34;评论列表\u0026#34;\u0026#34;\u0026#34; # 1.根据ID获取评论对象 queryset = models.Comment.objects.filter(blog_id=blog_id) # 2.序列化 ser = CommentSerializers(queryset, many=True) # 3.返回 context = {\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data} return Response(context) 测试数据还是通过访问/db/来添加:\n1 2 3 # 在def db(request)中添加如下操作 models.Comment.objects.create(content=\u0026#34;yi\u0026#34;, blog_id=1, user_id=1) models.Comment.objects.create(content=\u0026#34;er\u0026#34;, blog_id=1, user_id=2) 结果如下\n基本功能已经实现了，但是现在只是评论的展示，后续如果用户要添加评论时，user字段是需要用户传入id值的，而展示则是展示用户名，所以此处需要我们进行一个拓展，让该字段在校验时传入的是id，在序列化时是返回用户名\n用到先前提到的自定义NbHookSerializer类实现\n在etc/hook.py中定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from collections import OrderedDict from rest_framework.fields import SkipField from rest_framework.relations import PKOnlyObject class NbHookSerializer(object): def to_representation(self, instance): ret = OrderedDict() fields = self._readable_fields for field in fields: if hasattr(self, \u0026#39;nb_%s\u0026#39; % field.field_name): value = getattr(self, \u0026#34;nb_%s\u0026#34; % field.field_name)(instance) ret[field.field_name] = value else: try: attribute = field.get_attribute(instance) except SkipField: continue check_for_none = attribute.pk if isinstance(attribute, PKOnlyObject) else attribute if check_for_none is None: ret[field.field_name] = None else: ret[field.field_name] = field.to_representation(attribute) return ret 对CommentSerializers类做如下修改即可\n1 2 3 4 5 6 7 8 9 10 from ext.hook import NbHookSerializer class CommentSerializers(NbHookSerializer, serializers.ModelSerializer): class Meta: model = models.Comment fields = [\u0026#34;id\u0026#34;, \u0026#34;content\u0026#34;, \u0026#34;user\u0026#34;] def nb_user(self, obj): return obj.user.username 11.4.2.3 注册 路由\n1 path(\u0026#39;api/register/\u0026#39;, views.RegisterView.as_view()), 视图+序列化\n字段的钩子方法执行顺序按fields中定义的顺序来\n通过定义read_only和write_only区别数据校验和序列化字段的异同\nself.initial_data可以拿到传入的所有数据\n数据保存时字段过多的处理方法：pop\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class RegisterSerializers(serializers.ModelSerializer): confirm_password = serializers.CharField(write_only=True) class Meta: model = models.UserInfo fields = [\u0026#34;id\u0026#34;, \u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;, \u0026#34;confirm_password\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, \u0026#34;password\u0026#34;: {\u0026#34;write_only\u0026#34;: True}, } def validate_password(self, value): print(\u0026#34;密码：\u0026#34;, value) return value def validate_confirm_password(self, value): print(\u0026#34;重复密码：\u0026#34;, value) password = self.initial_data.get(\u0026#39;password\u0026#39;) if password != value: raise ValidationError(\u0026#34;密码不一致\u0026#34;) return value class RegisterView(APIView): def post(self, request): \u0026#34;\u0026#34;\u0026#34;注册\u0026#34;\u0026#34;\u0026#34; # 1.提交数据 # {\u0026#34;username\u0026#34;:\u0026#34;qiuwj\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;123\u0026#34;,\u0026#34;confirm_password\u0026#34;:\u0026#34;123\u0026#34;} # 2.数据校验+保存 ser = RegisterSerializers(data=request.data) if ser.is_valid(): confirm_password = ser.validated_data.pop(\u0026#39;confirm_password\u0026#39;) ser.save() return Response({\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data}) else: return Response({\u0026#39;code\u0026#39;: 1001, \u0026#39;error\u0026#39;: \u0026#34;注册失败\u0026#34;, \u0026#39;detail\u0026#39;: ser.errors}) 11.4.2.4 登录 路由\n1 path(\u0026#39;api/login/\u0026#39;, views.LoginView.as_view()), 视图加序列化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class LoginSerializers(serializers.ModelSerializer): class Meta: model = models.UserInfo fields = [\u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;] class LoginView(APIView): def post(self, request): \u0026#34;\u0026#34;\u0026#34;登录\u0026#34;\u0026#34;\u0026#34; # 1.提交数据 # {\u0026#34;username\u0026#34;:\u0026#34;qiuwj\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;123\u0026#34;} # 2.数据校验+保存 ser = LoginSerializers(data=request.data) if not ser.is_valid(): return Response({\u0026#39;code\u0026#39;: 1001, \u0026#39;error\u0026#39;: \u0026#34;校验失败\u0026#34;, \u0026#39;detail\u0026#39;: ser.errors}) instance = models.UserInfo.objects.filter(**ser.validated_data).first() if not instance: return Response({\u0026#39;code\u0026#39;: 1002, \u0026#39;error\u0026#39;: \u0026#34;用户名或密码错误\u0026#34;}) token = str(uuid.uuid4()) instance.token = token instance.save() return Response({\u0026#39;code\u0026#39;: 1000, \u0026#39;token\u0026#39;: token}) 11.4.2.5 发布评论 发表评论可以采用单独写一个视图类的序列化类来实现，但更规范的写法是整合到上面的博客评论中，当GET请求时，是展示评论，当POST请求时，是发布评论\n因为发布评论必须先登录，因此要用到认证类，但是展示评论不需要登录，而这两个功能是写在一个视图类中的，所以我们可以采用匿名用户，当未登录时不让他抛出错误而是返回None，最后如果request.user不为None则说明登陆了，如果是None说明是未登录，不让发表。\n在请求参数中携带token作身份标识，在请求体中传递评论内容\n认证类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from rest_framework.authentication import BaseAuthentication from api import models class BlogAuthentication(BaseAuthentication): def authenticate(self, request): token = request.query_params.get(\u0026#39;token\u0026#39;) if not token: return instance = models.UserInfo.objects.filter(token=token).first() if not instance: return return instance, token def authenticate_header(self, request): return \u0026#39;API\u0026#39; 视图类+序列化类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class CommentSerializers(NbHookSerializer, serializers.ModelSerializer): class Meta: model = models.Comment fields = [\u0026#34;id\u0026#34;, \u0026#34;content\u0026#34;, \u0026#34;user\u0026#34;] extra_kwargs = { \u0026#34;id\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, \u0026#34;user\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, } def nb_user(self, obj): return obj.user.username class CommentView(APIView): authentication_classes = [BlogAuthentication, ] def get(self, request, blog_id): \u0026#34;\u0026#34;\u0026#34;评论列表\u0026#34;\u0026#34;\u0026#34; # 1.根据ID获取评论对象 queryset = models.Comment.objects.filter(blog_id=blog_id) # 2.序列化 ser = CommentSerializers(queryset, many=True) # 3.返回 context = {\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data} return Response(context) def post(self, request, blog_id): \u0026#34;\u0026#34;\u0026#34;发布评论\u0026#34;\u0026#34;\u0026#34; if not request.user: return Response({\u0026#39;code\u0026#39;: 3000, \u0026#39;data\u0026#39;: \u0026#34;认证失败\u0026#34;}) blog_object = models.Blog.objects.filter(id=blog_id).first() if not blog_object: return Response({\u0026#39;code\u0026#39;: 2000, \u0026#39;data\u0026#39;: \u0026#34;博客不存在\u0026#34;}) ser = CommentSerializers(data=request.data) if not ser.is_valid(): return Response({\u0026#39;code\u0026#39;: 1002, \u0026#39;data\u0026#39;: \u0026#34;内容审核不通过\u0026#34;}) ser.save(blog=blog_object, user=request.user) return Response({\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data}) 11.4.2.6 点赞 路由\n1 path(\u0026#39;api/favor/\u0026#39;, views.FavorView.as_view()), 因为点赞功能必须登录，因此新增NoAuthentication认证类，当BlogAuthentication类为校验通过时，就抛出错误\n认证类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from rest_framework.authentication import BaseAuthentication from api import models from rest_framework import exceptions class BlogAuthentication(BaseAuthentication): def authenticate(self, request): token = request.query_params.get(\u0026#39;token\u0026#39;) if not token: return instance = models.UserInfo.objects.filter(token=token).first() if not instance: return return instance, token def authenticate_header(self, request): return \u0026#39;API\u0026#39; class NoAuthentication(BaseAuthentication): def authenticate(self, request): raise exceptions.AuthenticationFailed({\u0026#34;code\u0026#34;: 2000, \u0026#34;error\u0026#34;: \u0026#34;认证失败\u0026#34;}) def authenticate_header(self, request): return \u0026#39;API\u0026#39; 序列化+视图函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class FavorSerializer(serializers.ModelSerializer): class Meta: model = models.Favor fields = [\u0026#34;id\u0026#34;, \u0026#34;blog\u0026#34;] class FavorView(APIView): authentication_classes = [BlogAuthentication, NoAuthentication, ] def post(self, request): ser = FavorSerializer(data=request.data) if not ser.is_valid(): return Response({\u0026#39;code\u0026#39;: 1002, \u0026#39;error\u0026#39;: \u0026#34;校验失败\u0026#34;, \u0026#39;detail\u0026#39;: ser.errors}) # 1.已存在 不赞 exists = models.Favor.objects.filter(user=request.user, **ser.validated_data).exists() if exists: return Response({\u0026#39;code\u0026#39;: 1005, \u0026#39;error\u0026#39;: \u0026#34;已赞过，不允许重复点赞\u0026#34;}) # 2.不存在 ser.save(user=request.user) return Response({\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data}) 12.4.2.7 新建博客 和查看评论与发布评论相同，博客列表与新建博客也放到一个视图类中\n因为新建博客必须登录，可以采取匿名用户+对request.user判断的形式来做权限校验\n视图类\n关键在于对get和post请求时不同字段的隐藏和显示处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class BlogSerializer(NbHookSerializer, serializers.ModelSerializer): ctime = serializers.DateTimeField(format=\u0026#34;%Y-%m-%d\u0026#34;, read_only=True) creator = BlogUserSerializers(read_only=True) class Meta: model = models.Blog fields = [\u0026#34;id\u0026#34;, \u0026#34;category\u0026#34;, \u0026#34;image\u0026#34;, \u0026#34;title\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;text\u0026#34;, \u0026#34;ctime\u0026#34;, \u0026#34;comment_count\u0026#34;, \u0026#34;favor_count\u0026#34;, \u0026#34;creator\u0026#34;] extra_kwargs = { \u0026#34;comment_count\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, \u0026#34;favor_count\u0026#34;: {\u0026#34;read_only\u0026#34;: True}, \u0026#34;text\u0026#34;: {\u0026#34;write_only\u0026#34;: True}, } def nb_category(self, obj): return obj.get_category_display() class BlogView(APIView): authentication_classes = (BlogAuthentication,) def get(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;获取博客列表\u0026#34;\u0026#34;\u0026#34; # 1.读取数据库中的博客信息 queryset = models.Blog.objects.all().order_by(\u0026#39;-id\u0026#39;) # 2.序列化 ser = BlogSerializer(queryset, many=True) # 3.返回 context = {\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data} return Response(context) def post(self, request, *args, **kwargs): if not request.user: return Response({\u0026#39;code\u0026#39;: 3000, \u0026#39;data\u0026#39;: \u0026#34;认证失败\u0026#34;}) ser = BlogSerializer(data=request.data) if not ser.is_valid(): return Response({\u0026#39;code\u0026#39;: 1002, \u0026#39;error\u0026#39;: \u0026#34;校验失败\u0026#34;, \u0026#39;detail\u0026#39;: ser.errors}) ser.save(creator=request.user) return Response({\u0026#39;code\u0026#39;: 1000, \u0026#34;data\u0026#34;: ser.data}) 实现效果\n12.4.3 总结 主要拓展了权限类的或关系以及关于序列化器传入与输出的字段名相同但内容不同的拓展\n但存在几个问题\n点赞评论后博客对应点赞数和评论数未变化 \u0026ndash;\u0026gt; f操作自加一 博客列表和评论列表的分页功能 案例完整项目命名为blog1.zip\n12. 分页 在django中原生的分页组件不够好用，于是我们自定义了一个组件，而在drf中，他为我们提供了三个还不错的分页组件，下面我们来介绍一下比较常用的两个\nPageNumberPagination，适用于显示页面、上一下、下一页\n/accounts/?page=4 /accounts/?page=6 /accounts/?page=7 /accounts/?page=7\u0026amp;page_size=1000000000 /accounts/?page=7\u0026amp;page_size=2 /accounts/?page=7\u0026amp;page_size=4\n后端给前端返回的数据参考，由前端自己划分\nres = { \u0026quot;data\u0026quot;:[xxx,xxxx,xxxx,xxx,xxxx], \u0026quot;total\u0026quot;:1000, \u0026quot;persize\u0026quot;:20 } LimitOffsetPagination，滚动翻页\n从第二条开始,取十条\n/accounts/?offset=2\u0026amp;limit=10 /accounts/?offset=10\u0026amp;limit=10\n还可以添加条件,如id大于10的中从第0个开始,取十条\n/accounts/?lastid=10\u0026amp;offset=0\u0026amp;limit=10 /accounts/?lastid=20\u0026amp;offset=0\u0026amp;limit=10\n12.1 PageNumberPagination 12.1.1 初步使用 在url中传入不同的page,可以返回对应页的数据\n一共有三篇博客,page_size=2,因此第一页两条数据,第二页一条数据\n将该分页组件应用到前面的案例中,新的BlogView类实现如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class BlogView(APIView): authentication_classes = (BlogAuthentication,) def get(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;获取博客列表\u0026#34;\u0026#34;\u0026#34; # 1.读取数据库中的博客信息 queryset = models.Blog.objects.all().order_by(\u0026#39;-id\u0026#39;) # 分页 from rest_framework.pagination import PageNumberPagination pager = PageNumberPagination() result = pager.paginate_queryset(queryset, request, self) # 2.序列化 ser = BlogSerializer(result, many=True) # 3.返回 context = {\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data} return Response(context) 写了三行代码,改了一个值就实现了分页功能\n12.1.2 自定义PageNumberPagination类 通过继承PageNumberPagination类,自定义一些字段的值实现定制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class MyPageNumberPagination(PageNumberPagination): page_size_query_param = \u0026#39;size\u0026#39; page_query_param = \u0026#39;p\u0026#39; max_page_size = 2 page_size = 1 class BlogView(APIView): authentication_classes = (BlogAuthentication,) def get(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;获取博客列表\u0026#34;\u0026#34;\u0026#34; # 1.读取数据库中的博客信息 queryset = models.Blog.objects.all().order_by(\u0026#39;-id\u0026#39;) # 分页 pager = MyPageNumberPagination() result = pager.paginate_queryset(queryset, request, self) # 2.序列化 ser = BlogSerializer(result, many=True) # 3.返回 context = {\u0026#39;code\u0026#39;: 1000, \u0026#39;data\u0026#39;: ser.data} return Response(context) 12.1.3 分页的返回值处理 将序列化后的数据丢入get_paginated_response函数,封装返回值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class BlogView(APIView): authentication_classes = (BlogAuthentication,) def get(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;获取博客列表\u0026#34;\u0026#34;\u0026#34; # 1.读取数据库中的博客信息 queryset = models.Blog.objects.all().order_by(\u0026#39;id\u0026#39;) # 2.处理得到分页后的queryset from rest_framework.pagination import PageNumberPagination pager = PageNumberPagination() result = pager.paginate_queryset(queryset, request, self) # 3.序列化 ser = BlogSerializer(result, many=True) # 4.获取分页返回结果 response = pager.get_paginated_response(ser.data) return response get_paginated_response函数实现逻辑\n1 2 3 4 5 6 7 8 class PageNumberPagination(BasePagination): def get_paginated_response(self, data): return Response(OrderedDict([ (\u0026#39;count\u0026#39;, self.page.paginator.count), (\u0026#39;next\u0026#39;, self.get_next_link()), (\u0026#39;previous\u0026#39;, self.get_previous_link()), (\u0026#39;results\u0026#39;, data) ])) 就是封装了一个有序字典并放到response中,如果不满意它的内容可以自定义PageNumberPagination类重写get_paginated_response方法,手动封装\n12.1.4 终极使用 例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class BlogView(APIView): authentication_classes = (BlogAuthentication,) def get(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;获取博客列表\u0026#34;\u0026#34;\u0026#34; # 1.读取数据库中的博客信息 queryset = models.Blog.objects.all().order_by(\u0026#39;id\u0026#39;) # 2.处理得到分页后的queryset from rest_framework.pagination import PageNumberPagination pager = PageNumberPagination() result = pager.paginate_queryset(queryset, request, self) # 3.序列化 ser = BlogSerializer(result, many=True) # 4.获取分页返回结果 response = pager.get_paginated_response(ser.data) return response 12.2 LimitOffsetPagination 12.2.1 基本使用及拓展 LimitOffsetPagination与PageNumberPagination的使用相同，唯一的区别就是实例化的类不同，还有url中传入的参数不同\n也可以通过继承，自定义一个类，修改其中的参数，例如下列\n1 2 3 4 default_limit = api_settings.PAGE_SIZE limit_query_param = \u0026#39;limit\u0026#39; offset_query_param = \u0026#39;offset\u0026#39; max_limit = None 使用方法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class BlogView(APIView): authentication_classes = (BlogAuthentication,) def get(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;获取博客列表\u0026#34;\u0026#34;\u0026#34; # 1.读取数据库中的博客信息 queryset = models.Blog.objects.all().order_by(\u0026#39;id\u0026#39;) # 2.处理得到分页后的queryset from rest_framework.pagination import LimitOffsetPagination pager = LimitOffsetPagination() result = pager.paginate_queryset(queryset, request, self) # 3.序列化 ser = BlogSerializer(result, many=True) # 4.获取分页返回结果 response = pager.get_paginated_response(ser.data) return response 12.2.2 实际使用 在项目中，很少将LimitOffsetPagination用于普通的分页需求中，而是主要用来实现滚动翻页，比如页面默认显示10条，当滚到底部时才加载后10条，以此类推\n为什么不使用PageNumberPagination呢？我们举个例子来理解\n比如一组倒序排列的数10,9,8\u0026hellip;1\n第一次offset=0\u0026amp;limit=2取到10，9\n第二次offset=2\u0026amp;limit=2取到8，7\n正常来讲前端记录取出的个数然后作为offset不会出错，但如果插入了新的数据到最前端\n第三次offset=0\u0026amp;limit=2取到7，6就会出现重复\n解决办法就是前端记录取出的最后一个数据的id作为max_id，这样就只会从未取出的数据中查找，offset=0\u0026amp;limit=2无需更改\n要拿最新数据只需要限制条件为id大于最上面的一条数据的id即可，即可实现向上滚动翻页和向下滚动翻页\n/accounts/?offset=0\u0026amp;limit=2\u0026amp;lastid=0 13\t武沛齐 12\t武沛齐 max_id=12\n/accounts/?offset=0\u0026amp;limit=2\u0026amp;lastid=12 11\t武沛齐 10\t武沛齐 max_id=10\n/accounts/?offset=0\u0026amp;limit=2\u0026amp;lastid=10 9\t武沛齐 8\t武沛齐\n案例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class BlogView(APIView): authentication_classes = (BlogAuthentication,) def get(self, request, *args, **kwargs): \u0026#34;\u0026#34;\u0026#34;获取博客列表\u0026#34;\u0026#34;\u0026#34; # 1.读取数据库中的博客信息 queryset = models.Blog.objects.all().order_by(\u0026#39;-id\u0026#39;) # ?max_id=1 # ?min_id=13 max_id = request.query_params.get(\u0026#39;max_id\u0026#39;, None) if max_id: queryset = queryset.filter(id__lt=max_id) # 2.处理得到分页后的queryset from rest_framework.pagination import LimitOffsetPagination pager = LimitOffsetPagination() result = pager.paginate_queryset(queryset, request, self) # 3.序列化 ser = BlogSerializer(result, many=True) # 4.获取分页返回结果 response = pager.get_paginated_response(ser.data) return response ","date":"2025-02-27T14:18:29+08:00","permalink":"https://yn0t1me.github.io/p/drf/","title":"DRF"},{"content":"zheshiyige测试文章\n这里是正文\n","date":"2025-02-26T19:23:26+08:00","image":"https://yn0t1me.github.io/post/python/test/12120.jpg","permalink":"https://yn0t1me.github.io/p/first-test/","title":"First Test"},{"content":"zheshiyige测试文章\n这里是正文\n","date":"2025-02-26T19:23:26+08:00","image":"https://yn0t1me.github.io/post/python/test/12121.jpg","permalink":"https://yn0t1me.github.io/p/second-test/","title":"Second Test"},{"content":"Django项目创建 项目+虚拟环境\nDjango项目的创建 1 2 # 安装指定版本的djano pip install django==3.2 命令行操作 1 2 cd 项目目录 django-admin startproject 项目名 项目结构\n1 2 3 4 5 6 7 8 myproject ├── manage.py [项目的管理工具] └── myproject ├── __init__.py ├── settings.py 【配置文件，只有一部分。程序启动时，先读取django内部配置，再读settings.py】 ├── urls.py\t【主路由，在里面编写 /xxx/xxx/xxx ---\u0026gt; index 】 ├── asgi.py 【异步】 └── wsgi.py 【同步，主】 项目启动\n1 2 cd 项目名 python manage.py runserver IP:端口（可默认不写） app\n1 2 cd 项目 python manage.py startapp app名 项目结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 myproject ├── manage.py ├── myproject │ ├── __init__.py │ ├── asgi.py │ ├── settings.py │ ├── urls.py │ └── wsgi.py └── web ├── __init__.py ├── admin.py ├── apps.py ├── migrations │ └── __init__.py ├── models.py ├── tests.py └── views.py Pycharm操作 创建django项目\n生成效果\n虚拟环境 使用虚拟环境可以是各个项目之间的环境隔离开，为每一个项目单独创建一个虚拟环境，而不是使用系统解释器\n命令行 此处只介绍virtualenv的用法\n1 2 3 4 5 6 7 # 首先pip安装virualenv库 随便哪个系统解释器均可 pip install virtualenv cd 目标文件夹 virtualenv 虚拟环境名 --python=系统解释器 virtualenv /目标文件夹/虚拟环境名 --python=系统解释器 操作\n将D:\\envs视为以后存放虚拟环境的目录 1 2 cd \\envs virtualenv crm --python=python39 激活虚拟环境 1 2 cd crm\\Scripts activate 出现图示(虚拟环境名)表明激活成功\n安装包 1 pip install 包名 创建django项目 1 2 cd 项目目录 django-admin startproject crm 1 2 python manage.py startapp xxx python manage.py runserver 退出虚拟环境 1 deactivate Pycharm 创建指定django版本的项目\n创建纯净项目+创建虚拟环境 创建django项目 安装django\n1 pip install django==3.2 创建项目\n1 django-admin startproject myproj 因为我的pycharm虚拟环境有问题，只有在Script目录下才被激活，因此指定了一下创建路径\n配置django的启动按钮 fix键\napp创建 单个app目录结构如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 myproj ├── manage.py ├── myproj │ ├── __init__.py │ ├── asgi.py │ ├── settings.py │ ├── urls.py │ └── wsgi.py └── web ├── __init__.py ├── admin.py ├── apps.py ├── migrations │ └── __init__.py ├── models.py ├── tests.py └── views.py 要使用多app时，建议在根目录建立apps目录，在其中依次建立以app名命名的目录\n1 2 3 4 5 6 7 8 9 10 myproj .venv myproj ... ... manage.py apps web backend api 1 2 3 4 # 先创建如上结构的目录 python manage.py startapp spi apps/api python manage.py startapp web apps/web python manage.py startapp backend apps/backend 纯净版 将不需要使用的app，中间件，模板在settings文件中注释即可得到一个纯净版的django项目\nDjango项目文件结构及作用（个人习惯） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 D:\\Data\\Codefield\\CODE-Python\\py全栈\\模块六\\day06\u0026gt;treee -I .venv -f . |-- ./day06 | |-- ./day06/__init__.py | |-- ./day06/__pycache__ | | |-- 省略 | |-- ./day06/asgi.py | |-- ./day06/local_settings.py【本地配置，如数据库等配置，区别于settings】 | |-- ./day06/settings.py | |-- ./day06/urls.py【书写路由与视图函数对应关系】 | `-- ./day06/wsgi.py |-- ./django_error.log 【错误日志】 |-- ./manage.py |-- ./requirements【库依赖文件】 |-- ./scripts【脚本文件，随意写，放杂物】 | |-- ./scripts/init_admin.py | |-- ./scripts/init_customer.py | `-- ./scripts/\\303\\346\\317\\362\\266\\324\\317\\363\\274\\314\\263\\320.py |-- ./shell【部署时方便操作的bash脚本】 | |-- ./shell/reboot.sh | |-- ./shell/shop.sh | `-- ./shell/uwsgi_day06.ini |-- ./utils【小的功能库】 | |-- ./utils/__pycache__ | | |-- 略 | |-- ./utils/aliyun.py【短信收发】 | |-- ./utils/bootstrap.py【bootstrap样式渲染脚本】 | |-- ./utils/encrypt.py【密码加解密】 | |-- ./utils/group.py | |-- ./utils/link.py | |-- ./utils/md.py | |-- ./utils/pager.py【分页组件】 | |-- ./utils/response.py【response类，用于方便构建返回值】 | `-- ./utils/video.py【获取视频原播放量的脚本】 `-- ./web【单app】 |-- ./web/__init__.py |-- ./web/__pycache__ | |-- 略 |-- ./web/admin.py |-- ./web/apps.py |-- ./web/forms【编写form组件用于生成表单，校验提交信息】 | |-- ./web/forms/__pycache__ | | `-- ./web/forms/__pycache__/account.cpython-39.pyc | `-- ./web/forms/account.py |-- ./web/migrations【数据库操作记录文件】 | |-- ./web/migrations/0001_initial.py | |-- 略 |-- ./web/models.py【编写数据库结构，字段等等】 |-- ./web/static【静态文件存放目录】 | |-- ./web/static/css | | |-- ./web/static/css/commons.css | | |-- 略 | |-- ./web/static/images | | `-- ./web/static/images/default.png | |-- ./web/static/js | | |-- ./web/static/js/JQuery3.6.0.js | | |-- 略 | `-- ./web/static/plugins | |-- ./web/static/plugins/bootstrap | | |-- ./web/static/plugins/bootstrap/css | | |-- ./web/static/plugins/bootstrap/fonts | | `-- ./web/static/plugins/bootstrap/js | `-- ./web/static/plugins/font-awesome | |-- 略 |-- ./web/templates | |-- ./web/templates/form.html【表单显示模板】 | |-- ./web/templates/form2.html【表单显示模板2】 | |-- ./web/templates/home.html【各种页面】 | |-- ./web/templates/include【include】 | | |-- ./web/templates/include/delete_modal.html | | `-- ./web/templates/include/search_group.html | |-- ./web/templates/layout.html【用于继承的模板文件】 | |-- ./web/templates/tag【tag】 | | `-- ./web/templates/tag/my_menu.html | `-- ./web/templates/transaction_list.html |-- ./web/templatetags【处理复杂页面渲染逻辑】 | |-- ./web/templatetags/__pycache__ | | |-- 略 | |-- ./web/templatetags/color.py | |-- ./web/templatetags/menu.py | `-- ./web/templatetags/permission.py |-- ./web/tests.py `-- ./web/views【视图函数，处理逻辑】 |-- ./web/views/__pycache__ | |-- 略 |-- ./web/views/account.py |-- ./web/views/customer.py |-- ./web/views/level.py |-- ./web/views/my_order.py |-- ./web/views/my_transaction.py `-- ./web/views/policy.py 经典的MVC设计模式及其优点：\nMVC即 Model-View-Controller(模型-视图-控制器) ，是经典的软件开发设计模式\nModel (模型) ： 简而言之即数据模型。模型不是数据本身（比如数据库里的数据），而是抽象的描述数据的构成和逻辑关系。通常模型包括了数据表的各个字段（比如人的年龄和出生日期）和相互关系（单对单，单对多关系等)。Web开发框架会根据模型的定义来自动生成数据表。 View (视图)： 主要用于显示数据，用来展示用户可以看到的内容或提供用户可以输入或操作的界面。数据来源于哪里？当然是数据库啦。那么用户输入的数据给谁? 当然是给控制器啦。 Controller(控制器)：应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据（比如增加或更新数据表）。 MVC设计模式实现了软件或网络应用开发过程中数据、业务逻辑和用户界面的分离，使软件开发更清晰，也是维护变得更容易。这与静态网页设计中使用html和css实现了内容和样式的分离是同一个道理。\nDjango的MVT设计模式由Model模型，View（视图）和Template（模板）三部分组成，分别对应单个app目录下的models.py, views.py和templates文件夹\n因实际开发时view函数过多，为了方便管理通常使用views目录取代单个view.py文件，在views目录下按功能编写各个py文件\nDjango Model(模型): 这个与经典MVC模式下的模型Model差不多。 Django View(视图): 这个与MVC下的控制器Controller更像。视图不仅负责根据用户请求从数据库读取数据、指定向用户展示数据的方式(网页或json数据), 还可以指定渲染模板并处理用户提交的数据。 Django Template(模板): 这个与经典MVC模式下的视图View一致。模板用来呈现Django view传来的数据，也决定了用户界面的外观。Template里面也包含了表单，可以用来搜集用户的输入内容。 Django工作流程：\n当用户发来一个请求(request)时，Django会对请求头信息进行解析，解析出用户需要访问的url地址，然后根据路由urls.py中的定义的对应关系把请求转发到相应的视图处理。视图会从数据库读取需要的数据，指定渲染模板，最后返回响应数据\n简易开发流程\n新建app并注册 先使用python manage.py startapp web创建一个名为web的app，并将其添加到settings.py中\n1 2 3 4 5 6 7 8 9 INSTALLED_APPS = [ \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;web.apps.WebConfig\u0026#39;, ] 在urls中添加路径与视图函数对应关系 创建模型 在app下新建名为models.py，在其中编写数据库字段及表与表的关联关系\n使用\u0026lt;font style=\u0026quot;color:rgb(92, 89, 98);background-color:rgb(245, 246, 250);\u0026quot;\u0026gt;python manage.py makemigrations\u0026lt;/font\u0026gt;和\u0026lt;font style=\u0026quot;color:rgb(92, 89, 98);background-color:rgb(245, 246, 250);\u0026quot;\u0026gt;python manage.py migrate\u0026lt;/font\u0026gt;命令让django在数据库中创建数据表\n创建视图函数 在app下新建名为views的目录，根据业务功能创建account.py，并在其中定义login函数，从数据库读取数据，处理逻辑，指定渲染模板并将数据传递给对应模板\n编辑模板 创建在web/templates下创建login.html文件用于展示视图传来的数据，Django还提供了自己的模板语言用来渲染模板。\n路由配置 项目文件夹和每个应用(app)目录下的\u0026lt;font style=\u0026quot;color:rgb(92, 89, 98);background-color:rgb(245, 246, 250);\u0026quot;\u0026gt;urls.py\u0026lt;/font\u0026gt;文件构成了Django的路由配置系统(URLconf)。服务器收到用户请求后，会根据用户请求的url地址和urls.py里配置的url-视图映射关系，去调用执行相应的视图函数或视图类，最后由视图返回给客户端数据\nURLconf如何工作 手动路由分发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from django.urls import path from apps.web import views urlpatterns = [ path(\u0026#39;user/add/\u0026#39;, views.login), path(\u0026#39;user/delete/\u0026#39;, views.login), path(\u0026#39;user/edit/\u0026#39;, views.login), path(\u0026#39;user/list/\u0026#39;, views.login), # 提取公共部分，防止重复编写 path(\u0026#39;user/\u0026#39;, ([ path(\u0026#39;add/\u0026#39;, views.login), path(\u0026#39;delete/\u0026#39;, views.login), # /user/delete/ path(\u0026#39;edit/\u0026#39;, views.login), path(\u0026#39;list/\u0026#39;, views.login), ], None, None)), ] include+app，将功能拆分到不同的app中 要把app的urls加到项目的URL配置中\n1 2 3 4 5 6 from django.urls import include, path urlpatterns = [ path(\u0026#39;web/\u0026#39;, include(\u0026#39;apps.web.urls\u0026#39;)), ... ] 1 2 3 4 5 6 7 from django.urls import include, path from apps.api import views urlpatterns = [ # web/auth path(\u0026#39;auth/\u0026#39;, views.auth), ] URL设计方法 path\u0026lt;font style=\u0026quot;color:rgb(92, 89, 98);background-color:rgb(245, 246, 250);\u0026quot;\u0026gt;\u0026lt;变量类型:变量名\u0026gt;\u0026lt;/font\u0026gt; 1 2 3 urlpatterns = [ path(\u0026#39;news/\u0026lt;int:nid\u0026gt;/edit/\u0026#39;, views.news), ] int，整数 str，字符串 slug，字母+数字+下划线+- uuid，uuid格式 path，路径，可以包含/ re_path(?p\u0026lt;变量名\u0026gt;表达式) 1 2 3 urlpatterns = [ re_path(r\u0026#39;user/(?P\u0026lt;xxid\u0026gt;\\w+-\\d+)/(?P\u0026lt;yid\u0026gt;\\d+)/\u0026#39;, views.user), ] 路由分发本质 URL对应函数\n1 path(\u0026#39;user/add/\u0026#39;, views.login), URL对应元组\n1 path(\u0026#39;user/\u0026#39;, (元素,appname元素,namespance元素) ), 1 2 path(\u0026#39;user/\u0026#39;, include(\u0026#34;apps.api.urls\u0026#34;) ),# include本质返回的就是一个形如([],None,None))的元组 path(\u0026#39;user/\u0026#39;, ([],None,None) ), include源码解读\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def include(arg, namespace=None): app_name = None if isinstance(arg, tuple): try: urlconf_module, app_name = arg # urlconf_module为列表，app_name为None except ValueError: ... else: urlconf_module = arg # urlconf_module被赋值为一个字符串如\u0026#34;apps.api.urls\u0026#34; if isinstance(urlconf_module, str): urlconf_module = import_module(urlconf_module) # urlconf_module为导入的模块如urls patterns = getattr(urlconf_module, \u0026#39;urlpatterns\u0026#39;, urlconf_module) # 利用反射语法去取urls模块中的值，此处patterns为一个列表，当urlconf_module为列表时，patterns为默认值即列表 app_name = getattr(urlconf_module, \u0026#39;app_name\u0026#39;, app_name) # app_name为None if namespace and not app_name: raise ImproperlyConfigured( \u0026#39;Specifying a namespace in include() without providing an app_name \u0026#39; \u0026#39;is not supported. Set the app_name attribute in the included \u0026#39; \u0026#39;module, or pass a 2-tuple containing the list of patterns and \u0026#39; \u0026#39;app_name instead.\u0026#39;, ) namespace = namespace or app_name # namespace=app_name=None if isinstance(patterns, (list, tuple)): for url_pattern in patterns: pattern = getattr(url_pattern, \u0026#39;pattern\u0026#39;, None) if isinstance(pattern, LocalePrefixPattern): raise ImproperlyConfigured( \u0026#39;Using i18n_patterns in an included URLconf is not allowed.\u0026#39; ) return (urlconf_module, app_name, namespace) # ([],None,None) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 path(\u0026#39;user/add/\u0026#39;, views.login), path(\u0026#39;user/delete/\u0026#39;, views.login), path(\u0026#39;user/edit/\u0026#39;, views.login), path(\u0026#39;user/list/\u0026#39;, views.login), path(\u0026#39;user/\u0026#39;, ([ path(\u0026#39;add/\u0026#39;, views.login), path(\u0026#39;delete/\u0026#39;, views.login), path(\u0026#39;edit/\u0026#39;, views.login), path(\u0026#39;list/\u0026#39;, views.login), ], None, None)), path(\u0026#39;users\u0026#39;, include(([ path(\u0026#39;add/\u0026#39;, views.login), path(\u0026#39;delete/\u0026#39;, views.login), path(\u0026#39;edit/\u0026#39;, views.login), path(\u0026#39;list/\u0026#39;, views.login), ], None))), include(\u0026#34;apps.api.urls\u0026#34;) # 一般是每个app中的urls，但其实是可以随意写的，只要其中有urlpatterns参数即可 urlpatterns = [ ] name 相当于给每个URL取了个全局变量的名字。可以让你能够在Django的任意处，尤其是模板内显式地引用它\n1 2 3 4 5 urlpatterns = [ path(\u0026#39;Login/\u0026lt;str:role\u0026gt;/\u0026#39;, views.login, name=\u0026#34;v1\u0026#34;), re_path(r\u0026#39;auth/(\\d+)/(\\w+)/\u0026#39;, views.auth, name=\u0026#34;v2\u0026#34;), re_path(r\u0026#39;xxxx/(?P\u0026lt;nid\u0026gt;\\d+)/(?P\u0026lt;tpl\u0026gt;\\w+)/\u0026#39;, views.auth, name=\u0026#34;v3\u0026#34;), ] 在视图函数中生成URL 有参数名传参用kargs={k1:k2}\n无参数名传参用args=(v1,v2)\n1 2 3 4 from django.urls import reverse url1 = reverse(\u0026#34;v1\u0026#34;, kwargs={\u0026#34;role\u0026#34;: \u0026#34;hhh\u0026#34;}) url2 = reverse(\u0026#34;v2\u0026#34;, args=(666, \u0026#34;hhh\u0026#34;)) 在模板中生成URL \u0026lt;font style=\u0026quot;color:rgb(92, 89, 98);background-color:rgb(245, 246, 250);\u0026quot;\u0026gt;url\u0026lt;/font\u0026gt;是个模板标签，其作用是对命名的url进行方向解析，动态生成链接。\n命名的url里有几个参数，使用\u0026lt;font style=\u0026quot;color:rgb(92, 89, 98);background-color:rgb(245, 246, 250);\u0026quot;\u0026gt;url\u0026lt;/font\u0026gt;模板标签反向生成动态链接时，就需要向它传递几个参数\n有名字的要给他传值，无名字的空格分隔即可\n1 2 \u0026lt;a href=\u0026#34;{% url \u0026#39;v1\u0026#39; role=\u0026#34;111\u0026#34; %}\u0026#34;\u0026gt;跳转\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;{% url \u0026#39;v2\u0026#39; 666 \u0026#34;111\u0026#34; %}\u0026#34;\u0026gt;跳转\u0026lt;/a\u0026gt; 拓展 1 用name属性配合做权限管理 namespace 假设不同的app（比如web和api）中有同名url该如何区分？\n主路由\n1 2 3 4 5 6 7 from django.urls import path, re_path, include # 很多功能，很多URL urlpatterns = [ path(\u0026#39;api/\u0026#39;, include(\u0026#34;apps.api.urls\u0026#34;,namespace=\u0026#39;x1\u0026#39;)), path(\u0026#39;web/\u0026#39;, include(\u0026#34;apps.web.urls\u0026#34;,namespace=\u0026#39;x2\u0026#39;)), ] api/urls.py\n1 2 3 4 5 6 7 8 from django.urls import path, re_path from . import views # 很多功能，很多URL urlpatterns = [ path(\u0026#39;login/\u0026#39;, views.login,name=\u0026#34;login\u0026#34;), path(\u0026#39;auth/\u0026#39;, views.auth, name=\u0026#39;auth\u0026#39;), ] app_name = \u0026#34;api\u0026#34; web/urls.py\n1 2 3 4 5 6 7 8 9 from django.urls import path, re_path from . import views # 很多功能，很多URL urlpatterns = [ path(\u0026#39;home/\u0026#39;, views.home,name=\u0026#39;home\u0026#39;), path(\u0026#39;order/\u0026#39;, views.order,name=\u0026#39;order\u0026#39;), path(\u0026#39;auth/\u0026#39;, views.order, name=\u0026#39;auth\u0026#39;), ] app_name = \u0026#34;web\u0026#34; 只需要在\u0026lt;font style=\u0026quot;color:rgb(92, 89, 98);background-color:rgb(245, 246, 250);\u0026quot;\u0026gt;web/urls.py\u0026lt;/font\u0026gt;加上\u0026lt;font style=\u0026quot;color:rgb(92, 89, 98);background-color:rgb(245, 246, 250);\u0026quot;\u0026gt;app_name='web'\u0026lt;/font\u0026gt;这个命名空间即可\n视图中使用 1 2 3 4 from django.urls import reverse url = reverse(\u0026#34;x1:auth\u0026#34;) # /api/auth/ url2 = reverse(\u0026#34;x2:auth\u0026#34;) # /web/auth/ 模板中使用 1 2 \u0026lt;a href=\u0026#34;{% url \u0026#39;x1:auth\u0026#39; %}\u0026#34;\u0026gt;跳转\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;{% url \u0026#39;x2:auth\u0026#39; %}\u0026#34;\u0026gt;跳转\u0026lt;/a\u0026gt; 补充\nurl末尾的/ APPEND_SLASH是一个设置项，用于确定Django是否自动为没有尾随斜杠（/）的URL添加斜杠。默认情况下，APPEND_SLASH设置为True，这意味着如果用户请求的URL没有以斜杠结尾，Django会发出一个301重定向到带有尾随斜杠的URL\n当前匹配对象 \u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;ResolverMatch\u0026lt;/font\u0026gt;对象是在URL解析过程中创建的，它包含了匹配到的URL模式的相关信息。当你访问一个URL时，Django的URL解析器会尝试找到匹配的模式，如果找到，它会创建一个\u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;ResolverMatch\u0026lt;/font\u0026gt;对象，并将其存储在请求对象的\u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;resolver_match\u0026lt;/font\u0026gt;属性中。\n\u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;ResolverMatch\u0026lt;/font\u0026gt;对象在URL解析发生后才设置，这意味着它在所有视图中都是可用的，但在URL解析发生前的中间件中不可用（process_request）\n1 2 def my_view(request): resolver_match = request.resolver_match 作用\n直接访问URL中捕获的参数 根据参数不同处理视图逻辑分支 URL名称解析，用来动态生成链接 中间件支持，做权限控制 partial 1 2 3 4 5 6 def _xx(a1, a2): return a1 + a2 data = _xx(11, 22) print(data) 1 2 3 4 5 6 7 8 9 from functools import partial def _xx(a1, a2): return a1 + a2 yy = partial(_xx, a2=100) data = yy(2) print(data) 利用partial使得_path函数传入的Pattern不同，处理路由的方式不同\n视图 文件or文件夹 所有视图函数放在一个view.py会难以维护且影响可读性，建议根据功能业务不同命名对应的py文件，将所有py文件放在views目录下\n绝对导入和相对导入 原则：\n能用绝对导入就用绝对导入，层级过深不方便再用相对导入\n一定不要在项目根目录做相对导入\n视图参数 1 2 3 4 5 from django.shortcuts import HttpResponse def login(request): return HttpResponse(\u0026#34;login\u0026#34;) request是什么呢？\nrequest是由Django的中间件系统自动创建并传递给视图的一个对象，封装存放了浏览器发给服务器的所有内容，包括请求相关内容和django额外添加的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from django.shortcuts import HttpResponse def login(request): # 1.当前URL /api/login/ print(request.path_info) # 2.URL传递的参数 print(request.GET) print(request.GET.get(\u0026#34;age\u0026#34;)) # 3.请求方式 GET/POST print(request.method) # 4.如果post请求，传递请求体（原始数据） print(request.body) # b\u0026#39;{\u0026#34;code\u0026#34;:\u0026#34;083Sjmll2yla694F3bll2DguCM2SjmlG\u0026#34;,\u0026#34;unionId\u0026#34;:\u0026#34;oP6QCsyT_9bk1dfSaVf0GEV5Y-yE\u0026#34;}\u0026#39; b\u0026#39;v1=123\u0026amp;v2=456\u0026#39; # 4.1 请求体+请求头 b\u0026#39;v1=123\u0026amp;v2=456\u0026#39; + content-type:application/x-www-form-urlencoded print(request.POST) print(request.POST.get(\u0026#34;v1\u0026#34;)) print(request.POST.get(\u0026#34;v2\u0026#34;)) # 4.2 请求体+请求头 文件 print(request.FILES) # 文件格式 + content-type:multipart/form-data print(request.FILES.get(\u0026#34;n1\u0026#34;)) print(request.FILES.get(\u0026#34;n2\u0026#34;)) # 5.请求头 # {\u0026#39;Content-Length\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;text/plain\u0026#39;, \u0026#39;Host\u0026#39;: \u0026#39;127.0.0.1:8000\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;, \u0026#39;Cache-Control\u0026#39;: \u0026#39;max-age=0\u0026#39;, \u0026#39;Sec-Ch-Ua\u0026#39;: \u0026#39;\u0026#34; Not A;Brand\u0026#34;;v=\u0026#34;99\u0026#34;, \u0026#34;Chromium\u0026#34;;v=\u0026#34;102\u0026#34;, \u0026#34;Google Chrome\u0026#34;;v=\u0026#34;102\u0026#34;\u0026#39;, \u0026#39;Sec-Ch-Ua-Mobile\u0026#39;: \u0026#39;?0\u0026#39;, \u0026#39;Sec-Ch-Ua-Platform\u0026#39;: \u0026#39;\u0026#34;macOS\u0026#34;\u0026#39;, \u0026#39;Upgrade-Insecure-Requests\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\u0026#39;, \u0026#39;Sec-Fetch-Site\u0026#39;: \u0026#39;none\u0026#39;, \u0026#39;Sec-Fetch-Mode\u0026#39;: \u0026#39;navigate\u0026#39;, \u0026#39;Sec-Fetch-User\u0026#39;: \u0026#39;?1\u0026#39;, \u0026#39;Sec-Fetch-Dest\u0026#39;: \u0026#39;document\u0026#39;, \u0026#39;Accept-Encoding\u0026#39;: \u0026#39;gzip, deflate, br\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7\u0026#39;, \u0026#39;Cookie\u0026#39;: \u0026#39;csrftoken=CdidpKSGbLxzmOXnbmlkvrZep1eJmKLAA81T73UjcjxEnMOa4YOZqtc849AkYfUy\u0026#39;} print(request.headers) # 5.1 请求头有个特殊的cookie # request.headers[\u0026#39;cookie\u0026#39;] # \u0026#39;csrftoken=CdidpKSGbLxzmOXnbmlkvrZep1eJmKLAA81T73UjcjxEnMOa4YOZqtc849AkYfUy;session=xxxx\u0026#39; # {\u0026#39;csrftoken\u0026#39;: \u0026#39;CdidpKSGbLxzmOXnbmlkvrZep1eJmKLAA81T73UjcjxEnMOa4YOZqtc849AkYfUy\u0026#39;} print(request.COOKIES) # 6.requests中其他值 print(request.resolver_match) return HttpResponse(\u0026#34;login\u0026#34;) 补充：request源码解读\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def _get_post(self): # 去请求体解析body赋值给_post if not hasattr(self, \u0026#39;_post\u0026#39;): self._load_post_and_files() return self._post def _set_post(self, post): self._post = post @property def FILES(self): # 去请求体解析body赋值给_files if not hasattr(self, \u0026#39;_files\u0026#39;): self._load_post_and_files() return self._files POST = property(_get_post, _set_post) # 查询时执行_get_post，赋值时执行_set_post _load_post_and_files()函数解析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def _load_post_and_files(self): \u0026#34;\u0026#34;\u0026#34;Populate self._post and self._files if the content-type is a form type\u0026#34;\u0026#34;\u0026#34; if self.method != \u0026#39;POST\u0026#39;: self._post, self._files = QueryDict(encoding=self._encoding), MultiValueDict() return if self._read_started and not hasattr(self, \u0026#39;_body\u0026#39;): self._mark_post_parse_error() return if self.content_type == \u0026#39;multipart/form-data\u0026#39;: if hasattr(self, \u0026#39;_body\u0026#39;): # Use already read data data = BytesIO(self._body) else: data = self try: self._post, self._files = self.parse_file_upload(self.META, data) except MultiPartParserError: # An error occurred while parsing POST data. Since when # formatting the error the request handler might access # self.POST, set self._post and self._file to prevent # attempts to parse POST data again. self._mark_post_parse_error() raise elif self.content_type == \u0026#39;application/x-www-form-urlencoded\u0026#39;: self._post, self._files = QueryDict(self.body, encoding=self._encoding), MultiValueDict() else: self._post, self._files = QueryDict(encoding=self._encoding), MultiValueDict() 返回值 HttpResponse JsonResponse render redirect 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 3.1 字符串/字节/文本数据（图片验证码） return HttpResponse(\u0026#34;login\u0026#34;) # 3.2 JSON格式（前后端分离、app小程序后端、ajax请求） data_dict = {\u0026#34;status\u0026#34;: True, \u0026#39;data\u0026#39;: [11, 22, 33]} return JsonResponse(data_dict) # 3.3 重定向 return redirect(\u0026#34;https://www.baidu.com\u0026#34;) return redirect(\u0026#34;http://127.0.0.1:8000/api/auth/\u0026#34;) return redirect(\u0026#34;/api/auth/\u0026#34;) # 省略http://127.0.0.1:8000 return redirect(\u0026#34;auth\u0026#34;) # name from django.urls import reverse url = reverse(\u0026#34;auth\u0026#34;) return redirect(url) # name # 3.4 渲染 # - a.找到 \u0026#39;login.html\u0026#39; 并读取的内容，问题：去哪里找？ # - 默认先去settings.TEMPLATES.DIRS指定的路径找。（公共） # - 按注册顺序每个已注册的app中找他templates目录，去这个目录中寻找\u0026#39;login.html\u0026#39; # - 一般情况下，原则，那个app中的的模板，去哪个那个app中寻找。 # - b.渲染（替换）得到替换完成的字符串 # - c.返回浏览器 return render(request, \u0026#39;api/login.html\u0026#39;) html文件放置\n响应头 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from django.shortcuts import HttpResponse, redirect, render from django.http import JsonResponse def login(request): # 设置响应内容 res = HttpResponse(\u0026#34;login\u0026#34;) # 设置响应头 res[\u0026#39;xx1\u0026#39;] = \u0026#34;hahaha\u0026#34; res[\u0026#39;xx2\u0026#39;] = \u0026#34;hahaha\u0026#34; res[\u0026#39;xx3\u0026#39;] = \u0026#34;hahaha\u0026#34; # 设置cookie res.set_cookie(\u0026#39;k1\u0026#39;,\u0026#34;aaaaaaaa\u0026#34;) res.set_cookie(\u0026#39;k2\u0026#39;,\u0026#34;bbbbbb\u0026#34;) return res FBV和CBV 源码分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 自定义的UsersView类没有as_view()方法，于是找其父类View的as_view()方法 def as_view(cls, **initkwargs): \u0026#34;\u0026#34;\u0026#34;Main entry point for a request-response process.\u0026#34;\u0026#34;\u0026#34; for key in initkwargs: ... def view(request, *args, **kwargs): # self=UsersView() self = cls(**initkwargs) self.setup(request, *args, **kwargs) if not hasattr(self, \u0026#39;request\u0026#39;): ... return self.dispatch(request, *args, **kwargs) ... return view def dispatch(self, request, *args, **kwargs): if request.method.lower() in self.http_method_names: # hander为UsersView对象的get方法或post方法 handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed # hander() 调用 return handler(request, *args, **kwargs) # 本质还是一个函数 静态资源 开发需要：css，js，图片 1 2 - 根目录的 /static/ - 已经app目录下载 /static/ 文件夹下 媒体文件：用户上传的数据 1 - 根目录的 /media/ 静态文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 已注册的app的static目录 INSTALLED_APPS = [ # \u0026#39;django.contrib.admin\u0026#39;, # \u0026#39;django.contrib.auth\u0026#39;, # \u0026#39;django.contrib.contenttypes\u0026#39;, # \u0026#39;django.contrib.sessions\u0026#39;, # \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#34;apps.api.apps.ApiConfig\u0026#34;, \u0026#34;apps.web.apps.WebConfig\u0026#34;, ] ... # 根目录下的static目录 STATIC_URL = \u0026#39;/static/\u0026#39; STATICFILES_DIRS = ( os.path.join(BASE_DIR, \u0026#39;static\u0026#39;), # 项目级别的静态文件目录 ) 顺序：优先查找根目录下的static目录，若找不到再按注册顺序去已注册的app下的static目录\n如何导入？\n导入模块，调用里面的函数帮我去setting文件中读取STATIC_URL\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 {% load static %} \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;登录页面\u0026lt;/h1\u0026gt; \u0026lt;a href=\u0026#34;/xxx/xxxxx/\u0026#34;\u0026gt;调换dao xx\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;{% url \u0026#39;login\u0026#39; %}\u0026#34;\u0026gt;跳转\u0026lt;/a\u0026gt; \u0026lt;img src=\u0026#34;{% static \u0026#39;api/1.png\u0026#39; %}\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 生产环境\n收集静态文件 1 2 # 将所有的静态文件收集到一个位置，以便Web服务器可以高效地提供这些文件 python manage.py collectstatic 配置Web服务器 在生产环境中，你需要配置Web服务器（如Nginx或Apache）来提供静态文件。你需要指定静态文件的目录（通常是 \u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;STATIC_ROOT\u0026lt;/font\u0026gt;）\n媒体文件 在你的 settings.py 文件中，你需要定义两个设置项：\nMEDIA_URL：媒体文件的URL前缀。 MEDIA_ROOT：服务器上存储上传文件的路径。 1 2 3 4 5 6 # settings.py # 上传的文件可以通过类似 http://yourdomain.com/media/yourfile.jpg 的URL来访问。 MEDIA_URL = \u0026#39;/media/\u0026#39; # BASE_DIR 是你的Django项目的根目录，media 是在项目根目录下的一个子目录，用于存储上传的文件 MEDIA_ROOT = BASE_DIR / \u0026#39;media\u0026#39; 在 \u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;urls.py\u0026lt;/font\u0026gt; 中添加以下URL模式，在开发环境中运行服务器时，Django将能够通过 \u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;/media/\u0026lt;/font\u0026gt; URL前缀提供上传的文件\n1 2 3 4 5 6 7 8 9 10 11 # urls.py from django.conf import settings from django.conf.urls.static import static urlpatterns = [ # ... 你的其他url配置 ] if settings.DEBUG: urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) 模板 html模板的寻找顺序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 TEMPLATES = [ { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.template.backends.django.DjangoTemplates\u0026#39;, \u0026#39;DIRS\u0026#39;: [os.path.join(BASE_DIR, \u0026#39;templates\u0026#39;)], \u0026#39;APP_DIRS\u0026#39;: True, \u0026#39;OPTIONS\u0026#39;: { \u0026#39;context_processors\u0026#39;: [ \u0026#39;django.template.context_processors.debug\u0026#39;, \u0026#39;django.template.context_processors.request\u0026#39;, # \u0026#39;django.contrib.auth.context_processors.auth\u0026#39;, # \u0026#39;django.contrib.messages.context_processors.messages\u0026#39;, ], }, }, ] 参数介绍\nBACKEND 指定模板引擎的后端 DIRS 一个包含额外模板目录路径的列表,通常，这里用于存放全局模板 APP_DIRS 如果设置为\u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;True\u0026lt;/font\u0026gt;，则Django会在每个安装的应用的\u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;templates\u0026lt;/font\u0026gt;目录下寻找模板 OPTIONS 一个字典，包含模板引擎的选项 寻找顺序\n如果配置了DIRS目录，则Django会现在这些目录中寻找 在DIRS中找不到，会继续在每个app的templates目录中搜索，且顺序按照INSTALLED_APP的注册顺序进行 如何选择？\n简单的项目，模板都放在根目录 复杂的项目，模板放在各自的app中，公共部分放在templates目录 拓展：修改内置app的模板\n在根目录的templates目录下创建同名文件夹同名html文件，即可覆盖内置app提供的模板，因为有优先查找DIRS目录\n模板处理的本质 渲染完成后，生成了字符串，再返回给浏览器\n文件命名为.html只是为了编写html方便，实际上什么后缀都可以\n模板处理流程\n视图函数获取数据，创建上下文字典并传递给模板 1 2 3 4 5 6 7 from django.shortcuts import render from .models import MyModel def home(request): data = MyModel.objects.all() # 从数据库获取数据 context = {\u0026#39;data\u0026#39;: data} # 创建上下文 return render(request, \u0026#39;myapp/home.html\u0026#39;, context) # 渲染模板 渲染模板 render(）函数 根据模板名称查找模板 加载模板，准备渲染 处理上下文 将上下文字典插入模板。模板中的占位符（变量和标签）会被实际数据替代 处理模板中的模板标签和过滤器，例如：循环遍历数据、条件判断等 1 2 3 4 5 6 \u0026lt;h1\u0026gt;My Data\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; {% for item in data %} \u0026lt;li\u0026gt;{{ item.name }}\u0026lt;/li\u0026gt; {% endfor %} \u0026lt;/ul\u0026gt; 生成最终输出，返回响应 弹窗内容为{{ n2 }}，因为在js文件是在浏览器端发起的请求，此时模板渲染早已完成\n常用语法 变量传递\n调用方法不用加（）\n内置函数\n标签\n1 2 3 4 5 6 7 8 9 10 11 12 # if {% if condition %} \u0026lt;!-- code --\u0026gt; {% endif %} # for {% for item in items %} \u0026lt;!-- code --\u0026gt; {% endfor %} # url {% url \u0026#39;name\u0026#39; arg %} 模板继承\n1 2 3 4 {% extends \u0026#34;base.html\u0026#34; %} {% block title %}{% endblock %} {% block content %}{% endblock %} 自定义模板标签\nfilter 用于修改变量值，通常在模板变量后面使用，用管道符号\u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;|\u0026lt;/font\u0026gt;分隔\n1 2 - 数据处理，参数：1-2个 - 数据处理，if条件 1 2 3 4 5 6 7 8 # 在templatetags/custom_filters.py中 from django import template register = template.Library() @register.filter(name=\u0026#39;lowercase\u0026#39;) def lowercase(value): return value.lower() 模板中\n1 {{ my_variable|lowercase }} simple_tag 一个自定义的模板标签，它不接受任何模板变量，只接收位置参数和关键字参数，并返回一个字符串结果\n1 参数无限制 \u0026amp; 返回文本 1 2 3 4 5 6 7 8 # 在templatetags/custom_tags.py中 from django import template register = template.Library() @register.simple_tag def my_simple_tag(arg): return f\u0026#34;\u0026lt;p\u0026gt;{arg}\u0026lt;/p\u0026gt;\u0026#34; 模板中\n1 {% my_simple_tag \u0026#34;Hello, World!\u0026#34; %} inclusion_tag 类似于simple_tag，但它返回的是渲染后的模板片段，而不是一个简单的字符串。这允许你将模板的某个部分抽象成一个独立的模板文件，并在需要时包含进来\n1 参数无限制，返回html片段 1 2 3 4 5 6 7 8 # 在templatetags/custom_tags.py中 from django import template register = template.Library() @register.inclusion_tag(\u0026#39;custom_template.html\u0026#39;) def my_inclusion_tag(data): return {\u0026#39;data\u0026#39;: data} custom_template.html文件\n1 2 3 \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{{ data }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 模板中\n1 {% my_inclusion_tag \u0026#34;Some data\u0026#34; %} 继承与母版 基础模板（母版） 通常包含以下内容\n通用的HTML结构 占位符（block)，用于字幕版覆盖或扩展内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;{% block title %}My Site{% endblock %}\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;header\u0026gt; \u0026lt;!-- 通用头部内容 --\u0026gt; \u0026lt;/header\u0026gt; {% block content %} \u0026lt;!-- 默认内容，子模板可以覆盖或扩展 --\u0026gt; {% endblock %} \u0026lt;footer\u0026gt; \u0026lt;!-- 通用底部内容 --\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 子模板 子模板继承基础模板，并可以覆盖或扩展其中的内容\n1 2 3 4 5 6 7 8 {% extends \u0026#34;base.html\u0026#34; %} {% block title %}Home Page{% endblock %} {% block content %} \u0026lt;h1\u0026gt;Welcome to the Home Page\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is the home page content.\u0026lt;/p\u0026gt; {% endblock %} 母版一般放在根目录下的templates目录，若要视app为组件，可在app下的templates也放一份\n模板的导入 先继承模板，再导入嵌套模板，最后再进行渲染\n1 {% include \u0026#34;template_name.html\u0026#34; %} 中间件 Django生命周期\n类 定义方法 注册 简单实例（原始） MiddlewareMixin（推荐） 食用方法 自定义process_request和process_response方法，其他继承MiddlewareMixin即可\n源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class MiddlewareMixin: def __init__(self, get_response=None): self.get_response = get_response def __call__(self, request): response = None if hasattr(self, \u0026#39;process_request\u0026#39;): response = self.process_request(request) response = response or self.get_response(request) if hasattr(self, \u0026#39;process_response\u0026#39;): response = self.process_response(request, response) return response class MyMd(MiddlewareMixin): def process_request(self,request): ... def process_response(self,request, response): ... django内部默认执行call方法，传入参数。 执行流程 process_request都没有返回值，如果有返回值则直接执行其process_response，不再执行后续中间件及视图函数\n用于权限判断，ip黑名单拦截\nprocess_response都有返回值，用于给response添加信息\n中间件间的执行顺序按照注册顺序\n总结：\n先按顺序依次执行各个中间件的process_request，再进行路由匹配，在返回去执行process_view方法才进入视图函数，若某一process_view有返回值，则直接跳走，完整执行process_reponse\nprocess_view是在django中写死了的\n其他 process_exception 当视图抛出异常时，Django会寻找一个合适的响应\nDjango会从后向前遍历中间件栈，调用每个中间件的\u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;process_exception\u0026lt;/font\u0026gt;方法，直到找到一个返回了响应对象（\u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;HttpResponse\u0026lt;/font\u0026gt;或其子类实例）的方法，如果到达中间件栈的开始都没有找到返回响应的方法，Django将显示默认的500错误页面（服务器内部错误）\n这个方法允许开发者在异常发生时执行一些清理工作，或者返回一个自定义的响应给客户端，而不是默认的错误页面\nprocess_template_response 在视图被完全执行后调用，如果响应实例有\u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;render()\u0026lt;/font\u0026gt;方法，表明它是一个\u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;TemplateResponse\u0026lt;/font\u0026gt;或等效对象。这个方法允许你在模板渲染之后、响应发送到客户端之前，对\u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;TemplateResponse\u0026lt;/font\u0026gt;对象进行处理\n执行顺序\nprocess_template_response方法在视图函数返回一个TemplateResponse对象后被调用。 如果视图返回的是一个TemplateResponse对象，Django会从中间件栈的末尾开始调用中间件的process_template_response方法，直到找到一个返回了TemplateResponse对象的方法或者到达中间件栈的开始。 中间件在响应阶段会按照相反的顺序运行，其中包括process_template_response。 总结 定义中间类 类方法 process_request process_view process_reponse process_exception，视图函数出现异常，自定义异常页面。 process_template_response，视图函数返回TemplateResponse对象 or 对象中含有.render方法。 ORM操作 ORM（Object-Relational Mapping，对象关系映射）是Django框架的核心组件之一，它允许开发者使用Python代码来操作数据库，而无需编写SQL语句。ORM抽象了数据库的操作，使得开发者可以像操作普通Python对象一样操作数据库\n本质就是翻译的\n特点：开发效率高，执行效率低\nORM基本操作步骤 settings.py，连接数据库 1 2 3 4 5 6 DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.sqlite3\u0026#39;, \u0026#39;NAME\u0026#39;: BASE_DIR / \u0026#39;db.sqlite3\u0026#39;, } } settings.py，注册app 1 2 3 4 INSTALLED_APP = [ ... \u0026#34;app01.apps.App01Config\u0026#34; ] 编写models类 1 2 3 class UserInfo(models.Model): .... ..... 执行命令 1 2 3 python manage.py makemigrations # 创建迁移文件，找到所有已注册的app中的models.py中的类读取 -\u0026gt; migrations配置 python manage.py migrate # 应用迁移到数据库，读取已注册的app下的migrations配置 -\u0026gt; SQL语句 -\u0026gt; 同步数据库 # 自带的app已默认生成migrations 连接数据库 1 2 3 4 5 6 DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.sqlite3\u0026#39;, \u0026#39;NAME\u0026#39;: BASE_DIR / \u0026#39;db.sqlite3\u0026#39;, } } 1 2 3 4 5 6 7 8 9 10 DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.mysql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;xxxxxxxx\u0026#39;, # 数据库名字 \u0026#39;USER\u0026#39;: \u0026#39;root\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;root123\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, # ip \u0026#39;PORT\u0026#39;: 3306, } } 项目连接MySQL： 安装MySQL并启动MySQL服务 手动创建数据库 配置django的settings.py 1 2 3 4 5 6 7 8 9 10 DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.mysql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;xxxxxxxx\u0026#39;, # 数据库名字 \u0026#39;USER\u0026#39;: \u0026#39;root\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;root123\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, # ip \u0026#39;PORT\u0026#39;: 3306, } } 安装第三方组件 选其一即可 pymysql 1 pip install pymysql 1 2 3 项目根目录/项目名目录/__init__.py import pymysql pymysql.install_as_MySQLdb() - mysqlclient 1 pip install mysqlclient 其他数据库 pgsql 1 2 3 4 5 6 7 8 9 10 11 12 DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.postgresql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;mydatabase\u0026#39;, \u0026#39;USER\u0026#39;: \u0026#39;mydatabaseuser\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;mypassword\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;PORT\u0026#39;: 5432, } } # 需要 pip install psycopg2 1 2 3 4 5 6 7 8 9 10 11 DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.oracle\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#34;xxxx\u0026#34;, # 库名 \u0026#34;USER\u0026#34;: \u0026#34;xxxxx\u0026#34;, # 用户名 \u0026#34;PASSWORD\u0026#34;: \u0026#34;xxxxx\u0026#34;, # 密码 \u0026#34;HOST\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, # ip \u0026#34;PORT\u0026#34;: 1521, # 端口 } } # 需要 pip install cx-Oracle 连接池 django默认内置没有连接池\n1 2 pymysql -\u0026gt; 操作数据库 DBUtils -\u0026gt; 连接池 django-db-connection-pool组件\n1 pip install django-db-connection-pool 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 DATABASES = { \u0026#34;default\u0026#34;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;dj_db_conn_pool.backends.mysql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;day04\u0026#39;, # 数据库名字 \u0026#39;USER\u0026#39;: \u0026#39;root\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;root123\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, # ip \u0026#39;PORT\u0026#39;: 3306, \u0026#39;POOL_OPTIONS\u0026#39;: { \u0026#39;POOL_SIZE\u0026#39;: 10, # 最小 \u0026#39;MAX_OVERFLOW\u0026#39;: 10, # 在最小的基础上，还可以增加10个，即：最大20个。 \u0026#39;RECYCLE\u0026#39;: 24 * 60 * 60, # 连接可以被重复用多久，超过会重新创建，-1表示永久。 \u0026#39;TIMEOUT\u0026#39;:30, # 池中没有连接最多等待的时间。 } } } 多数据库 django支持项目连接多个数据库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 DATABASES = { \u0026#34;default\u0026#34;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;dj_db_conn_pool.backends.mysql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;day05db\u0026#39;, # 数据库名字 \u0026#39;USER\u0026#39;: \u0026#39;root\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;root123\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, # ip \u0026#39;PORT\u0026#39;: 3306, \u0026#39;POOL_OPTIONS\u0026#39;: { \u0026#39;POOL_SIZE\u0026#39;: 10, # 最小 \u0026#39;MAX_OVERFLOW\u0026#39;: 10, # 在最小的基础上，还可以增加10个，即：最大20个。 \u0026#39;RECYCLE\u0026#39;: 24 * 60 * 60, # 连接可以被重复用多久，超过会重新创建，-1表示永久。 \u0026#39;TIMEOUT\u0026#39;: 30, # 池中没有连接最多等待的时间。 } }, \u0026#34;bak\u0026#34;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;dj_db_conn_pool.backends.mysql\u0026#39;, \u0026#39;NAME\u0026#39;: \u0026#39;day05bak\u0026#39;, # 数据库名字 \u0026#39;USER\u0026#39;: \u0026#39;root\u0026#39;, \u0026#39;PASSWORD\u0026#39;: \u0026#39;root123\u0026#39;, \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, # ip \u0026#39;PORT\u0026#39;: 3306, \u0026#39;POOL_OPTIONS\u0026#39;: { \u0026#39;POOL_SIZE\u0026#39;: 10, # 最小 \u0026#39;MAX_OVERFLOW\u0026#39;: 10, # 在最小的基础上，还可以增加10个，即：最大20个。 \u0026#39;RECYCLE\u0026#39;: 24 * 60 * 60, # 连接可以被重复用多久，超过会重新创建，-1表示永久。 \u0026#39;TIMEOUT\u0026#39;: 30, # 池中没有连接最多等待的时间。 } }, } 读写分离 1 2 3 192.168.1.2 default master [写] 组件 192.168.2.12 bak slave [读] 生成数据库表 1 2 3 4 5 python manage.py makemigrations # 找到所有已注册的app中的models.py中的类读取 -\u0026gt; migrations配置 python manage.py migrate python manage.py migrate --database=default python manage.py migrate --database=bak 后续再进行开发时 1 2 3 models.UserInfo.objects.using(\u0026#34;default\u0026#34;).create(title=\u0026#34;武沛齐\u0026#34;) models.UserInfo.objects.using(\u0026#34;bak\u0026#34;).all() 编写router类，简化后续开发时操作 1 2 3 4 5 6 7 class DemoRouter(object): def db_for_read(...): return \u0026#34;bak\u0026#34; def db_for_write(...): return \u0026#34;default\u0026#34; 1 router = [\u0026#34;DemoRouter\u0026#34;] 1 2 3 - settings文件配置 DATABASE_ROUTERS - 编写settings中配置的文件和类 进行数据库操作时，会根据读还是写进入db_for_read或db_for_write函数，然后根据其返回的数据库名对其进行操作 分库（多app -\u0026gt; 多数据库） 100张表，A库存放app01生成的50张表，B库存放app02生成的50张表\napp01/models 1 2 3 4 5 from django.db import models class UserInfo(models.Model): title = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32) app02/models 1 2 3 4 5 from django.db import models class Role(models.Model): title = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32) 命令 1 2 3 python manage.py makemigrations python manage.py migrate app01 --database=default python manage.py migrate app02 --database=bak 读写操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from django.shortcuts import render, HttpResponse from app01 import models as m1 from app02 import models as m2 def index(request): # app01中的操作 -\u0026gt; default v1 = m1.UserInfo.objects.all() print(v1) # app02中的操作 -\u0026gt; bak v2 = m2.Role.objects.using(\u0026#39;bak\u0026#39;).all() print(v2) return HttpResponse(\u0026#34;返回\u0026#34;) router 分库（单app） 100张表，20张表-A数据库；50张表-B数据库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from django.shortcuts import render, HttpResponse from app01 import models as m1 def index(request): # app01中的操作 -\u0026gt; default v1 = m1.UserInfo.objects.all() print(v1) # app01中的操作 -\u0026gt; bak v2 = m1.Role.objects.using(\u0026#39;bak\u0026#39;).all() print(v2) return HttpResponse(\u0026#34;返回\u0026#34;) 注意事项 分库，将表拆分到不同的数据库 1 2 3 不要做跨数据库关联 -\u0026gt; django不支持 尽可能将关联的表放到一个库中 为什么分库 减轻数据库压力\n表关系 单表 1 2 class Role(models.Model): title = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32) 一对多 1 2 3 4 class Meta: db_table = \u0026#34;depart\u0026#34; # 自定义表名，默认是app名_表名 index_together={} # 联合索引 unique_together=((),) # 联合唯一索引 多对多 如果关系只有3列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Boy(models.Model): \u0026#34;\u0026#34;\u0026#34; 1 杰森斯坦森 2 汤普森 \u0026#34;\u0026#34;\u0026#34; name = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32, unique=True) b = models.ManyToManyField(to=\u0026#34;Girl\u0026#34;) class Girl(models.Model): \u0026#34;\u0026#34;\u0026#34; 1 alex 2 苑昊 \u0026#34;\u0026#34;\u0026#34; name = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32, unique=True) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Boy(models.Model): \u0026#34;\u0026#34;\u0026#34; 1 杰森斯坦森 2 汤普森 \u0026#34;\u0026#34;\u0026#34; name = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32, unique=True) class Girl(models.Model): \u0026#34;\u0026#34;\u0026#34; 1 alex 2 苑昊 \u0026#34;\u0026#34;\u0026#34; name = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32, unique=True) b = models.ManyToManyField(to=\u0026#34;Boy\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 # 初学阶段建议 class Boy(models.Model): name = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32, unique=True) class Girl(models.Model): name = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32, unique=True) class B2G(models.Model): bid = models.ForeignKey(to=\u0026#34;Boy\u0026#34;, on_delete=models.CASCADE) gid = models.ForeignKey(to=\u0026#34;Girl\u0026#34;, on_delete=models.CASCADE) address = models.CharField(verbose_name=\u0026#34;地点\u0026#34;, max_length=32) 一对一 数据操作 单表 增 1 2 class Role(models.Model): title = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32) 1 2 3 4 5 6 7 8 9 10 11 obj1 = models.Role.objects.create(title=\u0026#34;管理员\u0026#34;, od=1) obj2 = models.Role.objects.create(**{\u0026#34;title\u0026#34;: \u0026#34;管理员\u0026#34;, \u0026#34;od\u0026#34;: 1}) 内存 -\u0026gt; save obj = models.Role(title=\u0026#34;客户\u0026#34;, od=1) obj.od = 100 obj.save() obj = models.Role(**{\u0026#34;title\u0026#34;: \u0026#34;管理员\u0026#34;, \u0026#34;od\u0026#34;: 1}) obj.od = 100 obj.save() 控制输出格式 重写__str__方法\n删 1 2 # models.Role.objects.all().delete() models.Role.objects.filter(title=\u0026#34;管理员\u0026#34;).delete() 改 1 2 3 models.Role.objects.all().update(od=99) models.Role.objects.filter(id=7).update(od=99, title=\u0026#34;管理员\u0026#34;) models.Role.objects.filter(id=7).update(**{\u0026#34;od\u0026#34;: 99, \u0026#34;title\u0026#34;: \u0026#34;管理员\u0026#34;}) 查 条件筛选\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # QuerySet = [obj, obj] v1 = models.Role.objects.all() for obj in v1: print(obj, obj.id, obj.title, obj.od) # QuerySet = [] # v2 = models.Role.objects.filter(od=99, id=99) v2 = models.Role.objects.filter(**{\u0026#34;od\u0026#34;: 99, \u0026#34;id\u0026#34;: 99}) for obj in v2: print(obj, obj.id, obj.title, obj.od) v3 = models.Role.objects.filter(id=99) print(v3.query) v3 = models.Role.objects.filter(id__gt=2) print(v3.query) # \u0026gt; v3 = models.Role.objects.filter(id__gte=2) print(v3.query) # \u0026gt;= v3 = models.Role.objects.filter(id__lt=2) print(v3.query) # \u0026lt; v3 = models.Role.objects.filter(id__in=[11, 22, 33]) print(v3.query) v3 = models.Role.objects.filter(title__contains=\u0026#34;户\u0026#34;) print(v3.query) v3 = models.Role.objects.filter(title__startswith=\u0026#34;户\u0026#34;) print(v3.query) v3 = models.Role.objects.filter(title__isnull=True) print(v3.query) 不等于\n1 2 3 4 5 v3 = models.Role.objects.filter(id=99) print(v3.query) # 不等于 v3 = models.Role.objects.exclude(id=99).filter(od=88) print(v3.query) 获取字典，元组列表\n1 2 3 4 5 6 7 8 9 # queryset=[obj,obj] v3 = models.Role.objects.filter(id=99) # queryset=[{\u0026#39;id\u0026#39;: 6, \u0026#39;title\u0026#39;: \u0026#39;客户\u0026#39;}, {\u0026#39;id\u0026#39;: 7, \u0026#39;title\u0026#39;: \u0026#39;客户\u0026#39;}] v4 = models.Role.objects.filter(id__gt=0).values(\u0026#34;id\u0026#34;, \u0026#39;title\u0026#39;) # QuerySet = [(6, \u0026#39;客户\u0026#39;), (7, \u0026#39;客户\u0026#39;)] v5 = models.Role.objects.filter(id__gt=0).values_list(\u0026#34;id\u0026#34;, \u0026#39;title\u0026#39;) print(v5[0]) 获取单个对象\n1 2 3 4 5 v6 = models.Role.objects.filter(id__gt=0).first() # print(v6) # 对象 v7 = models.Role.objects.filter(id__gt=10).exists() print(v7) # True/False 排序\n1 2 3 4 5 # asc v8 = models.Role.objects.filter(id__gt=0).order_by(\u0026#34;id\u0026#34;) # id desc od asc v9 = models.Role.objects.filter(id__gt=0).order_by(\u0026#34;-id\u0026#34;, \u0026#39;od\u0026#39;) 一对多 1 2 3 4 5 6 7 8 9 10 class Depart(models.Model): \u0026#34;\u0026#34;\u0026#34; 部门 \u0026#34;\u0026#34;\u0026#34; title = models.CharField(verbose_name=\u0026#34;标题\u0026#34;, max_length=32) class Admin(models.Model): name = models.CharField(verbose_name=\u0026#34;姓名\u0026#34;, max_length=32) pwd = models.CharField(verbose_name=\u0026#34;密码\u0026#34;, max_length=32) depart = models.ForeignKey(verbose_name=\u0026#34;部门\u0026#34;, to=\u0026#34;Depart\u0026#34;, on_delete=models.CASCADE) 增 1 2 3 4 5 6 models.Admin.objects.create(name=\u0026#39;武沛齐1\u0026#39;, pwd=\u0026#39;123123123\u0026#39;, depart_id=2) # models.Admin.objects.create(**{..}) obj = models.Depart.objects.filter(id=2).first() models.Admin.objects.create(name=\u0026#39;武沛齐2\u0026#39;, pwd=\u0026#39;123123123\u0026#39;, depart=obj) models.Admin.objects.create(name=\u0026#39;武沛齐2\u0026#39;, pwd=\u0026#39;123123123\u0026#39;, depart_id=obj.id) 删 1 2 3 4 5 6 7 8 9 10 # filter() # 当前表的字段 + depart__字段 -\u0026gt; 连表和条件 # 找到部门id=3的所有的员工，删除 models.Admin.objects.filter(depart_id=3).delete() # 删除销售部的所有员工 obj = models.Depart.objects.filter(title=\u0026#34;销售部\u0026#34;).first() models.Admin.objects.filter(depart_id=obj.id).delete() # 跨表 models.Admin.objects.filter(depart__title=\u0026#34;销售部\u0026#34;, name=\u0026#39;武沛齐\u0026#39;).delete() 改 1 2 3 4 5 # 查询 models.Admin.objects.filter(id=2).update(name=\u0026#39;xxx\u0026#39;, pwd=\u0026#39;xxxx\u0026#39;) models.Admin.objects.filter(name=\u0026#34;武沛齐\u0026#34;).update(depart_id=2) # models.Admin.objects.filter(id=2).update(depart__title=\u0026#34;技术部\u0026#34;) -\u0026gt; 只能更新自己表字段 查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1. select * from admin queryset=[obj,obj,] v1 = models.Admin.objects.filter(id__gt=0) for obj in v1: print(obj.name, obj.pwd, obj.id, obj.depart_id) # 以这种方式查找尽量不要跨表，效率很低 # 2. select * from admin inner join depart queryset=[obj,obj,] v2 = models.Admin.objects.filter(id__gt=0).select_related(\u0026#34;depart\u0026#34;) for obj in v2: print(obj.name, obj.pwd, obj.id, obj.depart_id, obj.depart.title) # 3. select id,name.. from admin inner join depart queryset=[{},{}] v3 = models.Admin.objects.filter(id__gt=0).values(\u0026#34;id\u0026#34;, \u0026#39;name\u0026#39;, \u0026#39;pwd\u0026#39;, \u0026#34;depart__title\u0026#34;) print(v3) # 4. select id,name.. from admin inner join depart queryset=[(),()] v4 = models.Admin.objects.filter(id__gt=0).values_list(\u0026#34;id\u0026#34;, \u0026#39;name\u0026#39;, \u0026#39;pwd\u0026#39;, \u0026#34;depart__title\u0026#34;) print(v4) 多对多 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from django.db import models class Boy(models.Model): name = models.CharField(verbose_name=\u0026#34;姓名\u0026#34;, max_length=32, db_index=True) class Girl(models.Model): name = models.CharField(verbose_name=\u0026#34;姓名\u0026#34;, max_length=32, db_index=True) class B2G(models.Model): bid = models.ForeignKey(to=\u0026#34;Boy\u0026#34;, on_delete=models.CASCADE) gid = models.ForeignKey(to=\u0026#34;Girl\u0026#34;, on_delete=models.CASCADE) address = models.CharField(verbose_name=\u0026#34;地点\u0026#34;, max_length=32) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def index(request): models.Boy.objects.create(name=\u0026#34;宝强\u0026#34;) models.Boy.objects.create(name=\u0026#34;羽凡\u0026#34;) models.Boy.objects.create(name=\u0026#34;乃亮\u0026#34;) models.Girl.objects.bulk_create( objs=[models.Girl(name=\u0026#34;小路\u0026#34;), models.Girl(name=\u0026#34;百合\u0026#34;), models.Girl(name=\u0026#34;马蓉\u0026#34;)], batch_size=3 ) # 创建关系 models.B2G.objects.create(bid_id=1, gid_id=3, address=\u0026#34;北京\u0026#34;) models.B2G.objects.create(bid_id=1, gid_id=2, address=\u0026#34;北京\u0026#34;) models.B2G.objects.create(bid_id=2, gid_id=2, address=\u0026#34;北京\u0026#34;) models.B2G.objects.create(bid_id=2, gid_id=1, address=\u0026#34;北京\u0026#34;) b_obj = models.Boy.objects.filter(name=\u0026#39;宝强\u0026#39;).first() g_object = models.Girl.objects.filter(name=\u0026#34;小路\u0026#34;).first() models.B2G.objects.create(bid=b_obj, gid=g_object, address=\u0026#34;北京\u0026#34;) # 1.宝强都与谁约会。 queyset=[obj,obj,obj] q = models.B2G.objects.filter(bid__name=\u0026#39;宝强\u0026#39;).select_related(\u0026#34;gid\u0026#34;) for item in q: print(item.id, item.address, item.bid.name, item.gid.name) q = models.B2G.objects.filter(bid__name=\u0026#39;宝强\u0026#39;).values(\u0026#34;id\u0026#34;, \u0026#39;bid__name\u0026#39;, \u0026#39;gid__name\u0026#39;) for item in q: print(item[\u0026#39;id\u0026#39;], item[\u0026#39;bid__name\u0026#39;], item[\u0026#39;gid__name\u0026#39;]) # 2.百合 都与谁约会。 q = models.B2G.objects.filter(gid__name=\u0026#39;百合\u0026#39;).values(\u0026#34;id\u0026#34;, \u0026#39;bid__name\u0026#39;, \u0026#39;gid__name\u0026#39;) for item in q: print(item[\u0026#39;id\u0026#39;], item[\u0026#39;bid__name\u0026#39;], item[\u0026#39;gid__name\u0026#39;]) # 3.删除 models.B2G.objects.filter(id=1).delete() models.Boy.objects.filter(id=1).delete() return HttpResponse(\u0026#34;返回\u0026#34;) 一对一 cookie和seeesion cookie 1 2 127.0.0.1 v1.wupeiqi.com 127.0.0.1 v2.wupeiqi.com 配置session 文件版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 MIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, # \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, # \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, ] # session SESSION_ENGINE = \u0026#39;django.contrib.sessions.backends.file\u0026#39; SESSION_FILE_PATH = \u0026#39;xxxx\u0026#39; SESSION_COOKIE_NAME = \u0026#34;sid\u0026#34; # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串 SESSION_COOKIE_PATH = \u0026#34;/\u0026#34; # Session的cookie保存的路径 SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名 SESSION_COOKIE_SECURE = False # 是否Https传输cookie SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输 SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周） SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期 SESSION_SAVE_EVERY_REQUEST = True # 是否每次请求都保存Session，默认修改之后才保存 数据库版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 INSTALLED_APPS = [ # \u0026#39;django.contrib.admin\u0026#39;, # \u0026#39;django.contrib.auth\u0026#39;, # \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, # \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#34;app01.apps.App01Config\u0026#34;, ] MIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, # \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, # \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, ] # session SESSION_ENGINE = \u0026#39;django.contrib.sessions.backends.db\u0026#39; SESSION_COOKIE_NAME = \u0026#34;sid\u0026#34; # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串 SESSION_COOKIE_PATH = \u0026#34;/\u0026#34; # Session的cookie保存的路径 SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名 SESSION_COOKIE_SECURE = False # 是否Https传输cookie SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输 SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周） SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期 SESSION_SAVE_EVERY_REQUEST = True # 是否每次请求都保存Session，默认修改之后才保存 缓存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 INSTALLED_APPS = [ # \u0026#39;django.contrib.admin\u0026#39;, # \u0026#39;django.contrib.auth\u0026#39;, # \u0026#39;django.contrib.contenttypes\u0026#39;, # \u0026#39;django.contrib.sessions\u0026#39;, # \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#34;app01.apps.App01Config\u0026#34;, ] MIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, # \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, # \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, ] # session SESSION_ENGINE = \u0026#39;django.contrib.sessions.backends.cache\u0026#39; SESSION_CACHE_ALIAS = \u0026#39;default\u0026#39; SESSION_COOKIE_NAME = \u0026#34;sid\u0026#34; # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串 SESSION_COOKIE_PATH = \u0026#34;/\u0026#34; # Session的cookie保存的路径 SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名 SESSION_COOKIE_SECURE = False # 是否Https传输cookie SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输 SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周） SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期 SESSION_SAVE_EVERY_REQUEST = True # 是否每次请求都保存Session，默认修改之后才保存 缓存 服务器 + redis安装启动 django 安装连接redis包 1 pip install django-redis - settings.py 1 2 3 4 5 6 7 8 9 10 11 CACHES = { \u0026#34;default\u0026#34;: { \u0026#34;BACKEND\u0026#34;: \u0026#34;django_redis.cache.RedisCache\u0026#34;, \u0026#34;LOCATION\u0026#34;: \u0026#34;redis://127.0.0.1:6379\u0026#34;, \u0026#34;OPTIONS\u0026#34;: { \u0026#34;CLIENT_CLASS\u0026#34;: \u0026#34;django_redis.client.DefaultClient\u0026#34;, \u0026#34;CONNECTION_POOL_KWARGS\u0026#34;: {\u0026#34;max_connections\u0026#34;: 100} # \u0026#34;PASSWORD\u0026#34;: \u0026#34;密码\u0026#34;, } } } - 手动操作redis 1 2 3 4 5 from django_redis import get_redis_connection conn = get_redis_connection(\u0026#34;default\u0026#34;) conn.set(\u0026#34;xx\u0026#34;,\u0026#34;123123\u0026#34;) conn.get(\u0026#34;xx\u0026#34;) ","date":"0001-01-01T00:00:00Z","permalink":"https://yn0t1me.github.io/p/","title":""}]